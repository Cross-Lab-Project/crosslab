/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */
import {
    validateGetDevicesInput,
    validateGetDevicesOutput,
    validatePostDevicesInput,
    validateGetDevicesByDeviceIdInput,
    validateGetDevicesByDeviceIdOutput,
    validatePatchDevicesByDeviceIdInput,
    validatePatchDevicesByDeviceIdOutput,
    validateDeleteDevicesByDeviceIdInput,
    validateDeleteDevicesByDeviceIdOutput,
    validatePostDevicesByDeviceIdInput,
    validatePostDevicesByDeviceIdOutput,
    validateGetDevicesByDeviceIdAvailabilityInput,
    validateGetDevicesByDeviceIdAvailabilityOutput,
    validateDeleteDevicesByDeviceIdAvailabilityInput,
    validateDeleteDevicesByDeviceIdAvailabilityOutput,
    validatePostDevicesByDeviceIdAvailabilityInput,
    validatePostDevicesByDeviceIdAvailabilityOutput,
    validatePostDevicesByDeviceIdWebsocketInput,
    validatePostDevicesByDeviceIdWebsocketOutput,
    validatePostDevicesByDeviceIdSignalingInput,
    validatePostDevicesByDeviceIdSignalingOutput,
    validateGetPeerconnectionsInput,
    validateGetPeerconnectionsOutput,
    validatePostPeerconnectionsInput,
    validatePostPeerconnectionsOutput,
    validateGetPeerconnectionsByPeerconnectionIdInput,
    validateGetPeerconnectionsByPeerconnectionIdOutput,
    validateDeletePeerconnectionsByPeerconnectionIdInput,
    validateDeletePeerconnectionsByPeerconnectionIdOutput,
    validatePatchPeerconnectionsByPeerconnectionIdDeviceStatusInput,
    validatePatchPeerconnectionsByPeerconnectionIdDeviceStatusOutput,
    validatePostDevicesOutput,
} from './generated/requestValidation'
import {
    postDevicesParametersType,
    postDevicesRequestBodyType,
    getDevicesByDeviceIdParametersType,
    patchDevicesByDeviceIdParametersType,
    patchDevicesByDeviceIdRequestBodyType,
    deleteDevicesByDeviceIdParametersType,
    postDevicesByDeviceIdParametersType,
    getDevicesByDeviceIdAvailabilityParametersType,
    deleteDevicesByDeviceIdAvailabilityParametersType,
    postDevicesByDeviceIdAvailabilityParametersType,
    postDevicesByDeviceIdAvailabilityRequestBodyType,
    postDevicesByDeviceIdWebsocketParametersType,
    postDevicesByDeviceIdSignalingParametersType,
    postDevicesByDeviceIdSignalingRequestBodyType,
    postPeerconnectionsParametersType,
    postPeerconnectionsRequestBodyType,
    getPeerconnectionsByPeerconnectionIdParametersType,
    deletePeerconnectionsByPeerconnectionIdParametersType,
    patchPeerconnectionsByPeerconnectionIdDeviceStatusParametersType,
    patchPeerconnectionsByPeerconnectionIdDeviceStatusRequestBodyType,
} from './generated/signatures'
import { TypedRequest, ValidationError } from './generated/types'
import operations from './operations'
import express from 'express'

export const router = express.Router()

router.get('/devices', async (_req, res, next) => {
    const userData = {
        JWT: {
            url: 'deprecated',
            username: 'user:anonymous',
            scopes: [],
            jwt: 'deprecated',
        },
    }

    try {
        if (!validateGetDevicesInput()) {
            throw new ValidationError(
                'Request validation failed',
                (validateGetDevicesInput as unknown as {errors: object}).errors,
                400
            )
        }

        const result = await operations.getDevices(userData)

        if (!validateGetDevicesOutput(result)) {
            throw new ValidationError(
                'Response validation failed',
                (validateGetDevicesOutput as unknown as {errors: object}).errors,
                500
            )
        }

        for (const headerName in result.headers) {
            const header = result.headers[headerName]
            if (header) {
                res.setHeader(headerName, header)
            }
        }

        return res.status(result.status).send(result.body)
    } catch (error) {
        next(error)
        return
    }
})

router.post('/devices', async (req, res, next) => {
    const userData = {
        JWT: {
            url: 'deprecated',
            username: 'user:anonymous',
            scopes: [],
            jwt: 'deprecated',
        },
    }

    const parameters: postDevicesParametersType = {
        changedUrl: req.query['changedUrl'] as string,
    }

    const body: postDevicesRequestBodyType = req.body

    try {
        if (!validatePostDevicesInput(parameters, body)) {
            throw new ValidationError(
                'Request validation failed',
                (validatePostDevicesInput as unknown as {errors: object}).errors,
                400
            )
        }

        const result = await operations.postDevices(parameters, body, userData)

        if (!validatePostDevicesOutput(result)) {
            console.log( (validatePostDevicesOutput as unknown as {errors: object}).errors)
            throw new ValidationError(
                'Response validation failed',
                (validatePostDevicesOutput as unknown as {errors: object}).errors,
                500
            )
        }

        for (const headerName in result.headers) {
            const header = result.headers[headerName]
            if (header) {
                res.setHeader(headerName, header)
            }
        }

        return res.status(result.status).send(result.body)
    } catch (error) {
        next(error)
        return
    }
})

router.get('/devices/:device_id', async (req, res, next) => {
    const userData = {
        JWT: {
            url: 'deprecated',
            username: 'user:anonymous',
            scopes: [],
            jwt: 'deprecated',
        },
    }

    const parameters: getDevicesByDeviceIdParametersType = {
        device_id: req.params['device_id'],
        flat_group: req.query['flat_group'] === 'true',
        execute_for: req.get('execute_for'),
    }

    try {
        if (!validateGetDevicesByDeviceIdInput(parameters)) {
            throw new ValidationError(
                'Request validation failed',
                (validateGetDevicesByDeviceIdInput as unknown as {errors: object}).errors,
                400
            )
        }

        const result = await operations.getDevicesByDeviceId(parameters, userData)

        if (!validateGetDevicesByDeviceIdOutput(result)) {
            throw new ValidationError(
                'Response validation failed',
                (validateGetDevicesByDeviceIdOutput as unknown as {errors: object}).errors,
                500
            )
        }

        for (const headerName in result.headers) {
            const header = result.headers[headerName]
            if (header) {
                res.setHeader(headerName, header)
            }
        }

        return res.status(result.status).send(result.body)
    } catch (error) {
        next(error)
        return
    }
})

router.patch(
    '/devices/:device_id',
    async (
        req: TypedRequest<
            { device_id: string },
            patchDevicesByDeviceIdRequestBodyType,
            { changedUrl: string }
        >,
        res,
        next
    ) => {
        const userData = {
            JWT: {
                url: 'deprecated',
                username: 'user:anonymous',
                scopes: [],
                jwt: 'deprecated',
            },
        }

        const parameters: patchDevicesByDeviceIdParametersType = {
            device_id: req.params['device_id'],
            changedUrl: req.query['changedUrl'],
        }

        const body: patchDevicesByDeviceIdRequestBodyType = req.body

        try {
            if (!validatePatchDevicesByDeviceIdInput(parameters, body)) {
                throw new ValidationError(
                    'Request validation failed',
                    (validatePatchDevicesByDeviceIdInput as unknown as {errors: object}).errors,
                    400
                )
            }

            const result = await operations.patchDevicesByDeviceId(
                parameters,
                body,
                userData
            )

            if (!validatePatchDevicesByDeviceIdOutput(result)) {
                throw new ValidationError(
                    'Response validation failed',
                    (validatePatchDevicesByDeviceIdOutput as unknown as {errors: object}).errors,
                    500
                )
            }

            for (const headerName in result.headers) {
                const header = result.headers[headerName]
                if (header) {
                    res.setHeader(headerName, header)
                }
            }

            return res.status(result.status).send(result.body)
        } catch (error) {
            next(error)
            return
        }
    }
)

router.delete('/devices/:device_id', async (req, res, next) => {
    const userData = {
        JWT: {
            url: 'deprecated',
            username: 'user:anonymous',
            scopes: [],
            jwt: 'deprecated',
        },
    }

    const parameters: deleteDevicesByDeviceIdParametersType = {
        device_id: req.params['device_id'],
    }

    try {
        if (!validateDeleteDevicesByDeviceIdInput(parameters)) {
            throw new ValidationError(
                'Request validation failed',
                (validateDeleteDevicesByDeviceIdInput as unknown as {errors: object}).errors,
                400
            )
        }

        const result = await operations.deleteDevicesByDeviceId(parameters, userData)

        if (!validateDeleteDevicesByDeviceIdOutput(result)) {
            throw new ValidationError(
                'Response validation failed',
                (validateDeleteDevicesByDeviceIdOutput as unknown as {errors: object}).errors,
                500
            )
        }

        for (const headerName in result.headers) {
            const header = result.headers[headerName]
            if (header) {
                res.setHeader(headerName, header)
            }
        }

        return res.status(result.status).send(result.body)
    } catch (error) {
        next(error)
        return
    }
})

router.post('/devices/:device_id', async (req, res, next) => {
    const userData = {
        JWT: {
            url: 'deprecated',
            username: 'user:anonymous',
            scopes: [],
            jwt: 'deprecated',
        },
    }

    const parameters: postDevicesByDeviceIdParametersType = {
        device_id: req.params['device_id'],
        changedUrl: req.query['changedUrl'] as string,
    }

    try {
        if (!validatePostDevicesByDeviceIdInput(parameters)) {
            throw new ValidationError(
                'Request validation failed',
                (validatePostDevicesByDeviceIdInput as unknown as {errors: object}).errors,
                400
            )
        }

        const result = await operations.postDevicesByDeviceId(parameters, userData)

        if (!validatePostDevicesByDeviceIdOutput(result)) {
            throw new ValidationError(
                'Response validation failed',
                (validatePostDevicesByDeviceIdOutput as unknown as {errors: object}).errors,
                500
            )
        }

        for (const headerName in result.headers) {
            const header = result.headers[headerName]
            if (header) {
                res.setHeader(headerName, header)
            }
        }

        return res.status(result.status).send(result.body)
    } catch (error) {
        next(error)
        return
    }
})

router.get('/devices/:device_id/availability', async (req, res, next) => {
    const userData = {
        JWT: {
            url: 'deprecated',
            username: 'user:anonymous',
            scopes: [],
            jwt: 'deprecated',
        },
    }

    const parameters: getDevicesByDeviceIdAvailabilityParametersType = {
        device_id: req.params['device_id'],
        startTime: req.query['startTime'] as string,
        endTime: req.query['endTime'] as string,
    }

    try {
        if (!validateGetDevicesByDeviceIdAvailabilityInput(parameters)) {
            throw new ValidationError(
                'Request validation failed',
                (validateGetDevicesByDeviceIdAvailabilityInput as unknown as {errors: object}).errors,
                400
            )
        }

        const result = await operations.getDevicesByDeviceIdAvailability(
            parameters,
            userData
        )

        if (!validateGetDevicesByDeviceIdAvailabilityOutput(result)) {
            throw new ValidationError(
                'Response validation failed',
                (validateGetDevicesByDeviceIdAvailabilityOutput as unknown as {errors: object}).errors,
                500
            )
        }

        for (const headerName in result.headers) {
            const header = result.headers[headerName]
            if (header) {
                res.setHeader(headerName, header)
            }
        }

        return res.status(result.status).send(result.body)
    } catch (error) {
        next(error)
        return
    }
})

router.delete('/devices/:device_id/availability', async (req, res, next) => {
    const userData = {
        JWT: {
            url: 'deprecated',
            username: 'user:anonymous',
            scopes: [],
            jwt: 'deprecated',
        },
    }

    const parameters: deleteDevicesByDeviceIdAvailabilityParametersType = {
        device_id: req.params['device_id'],
    }

    try {
        if (!validateDeleteDevicesByDeviceIdAvailabilityInput(parameters)) {
            throw new ValidationError(
                'Request validation failed',
                (validateDeleteDevicesByDeviceIdAvailabilityInput as unknown as {errors: object}).errors,
                400
            )
        }

        const result = await operations.deleteDevicesByDeviceIdAvailability(
            parameters,
            userData
        )

        if (!validateDeleteDevicesByDeviceIdAvailabilityOutput(result)) {
            throw new ValidationError(
                'Response validation failed',
                (validateDeleteDevicesByDeviceIdAvailabilityOutput as unknown as {errors: object}).errors,
                500
            )
        }

        for (const headerName in result.headers) {
            const header = result.headers[headerName]
            if (header) {
                res.setHeader(headerName, header)
            }
        }

        return res.status(result.status).send(result.body)
    } catch (error) {
        next(error)
        return
    }
})

router.post('/devices/:device_id/availability', async (req, res, next) => {
    const userData = {
        JWT: {
            url: 'deprecated',
            username: 'user:anonymous',
            scopes: [],
            jwt: 'deprecated',
        },
    }

    const parameters: postDevicesByDeviceIdAvailabilityParametersType = {
        device_id: req.params['device_id'],
    }

    const body: postDevicesByDeviceIdAvailabilityRequestBodyType = req.body

    try {
        if (!validatePostDevicesByDeviceIdAvailabilityInput(parameters, body)) {
            throw new ValidationError(
                'Request validation failed',
                (validatePostDevicesByDeviceIdAvailabilityInput as unknown as {errors: object}).errors,
                400
            )
        }

        const result = await operations.postDevicesByDeviceIdAvailability(
            parameters,
            body,
            userData
        )

        if (!validatePostDevicesByDeviceIdAvailabilityOutput(result)) {
            throw new ValidationError(
                'Response validation failed',
                (validatePostDevicesByDeviceIdAvailabilityOutput as unknown as {errors: object}).errors,
                500
            )
        }

        for (const headerName in result.headers) {
            const header = result.headers[headerName]
            if (header) {
                res.setHeader(headerName, header)
            }
        }

        return res.status(result.status).send(result.body)
    } catch (error) {
        next(error)
        return
    }
})

router.post('/devices/:device_id/websocket', async (req, res, next) => {
    const userData = {
        JWT: {
            url: 'deprecated',
            username: 'user:anonymous',
            scopes: [],
            jwt: 'deprecated',
        },
    }

    const parameters: postDevicesByDeviceIdWebsocketParametersType = {
        device_id: req.params['device_id'],
    }

    try {
        if (!validatePostDevicesByDeviceIdWebsocketInput(parameters)) {
            throw new ValidationError(
                'Request validation failed',
                (validatePostDevicesByDeviceIdWebsocketInput as unknown as {errors: object}).errors,
                400
            )
        }

        const result = await operations.postDevicesByDeviceIdWebsocket(
            parameters,
            userData
        )

        if (!validatePostDevicesByDeviceIdWebsocketOutput(result)) {
            throw new ValidationError(
                'Response validation failed',
                (validatePostDevicesByDeviceIdWebsocketOutput as unknown as {errors: object}).errors,
                500
            )
        }

        for (const headerName in result.headers) {
            const header = result.headers[headerName]
            if (header) {
                res.setHeader(headerName, header)
            }
        }

        return res.status(result.status).send(result.body)
    } catch (error) {
        next(error)
        return
    }
})

router.post(
    '/devices/:device_id/signaling',
    async (
        req: TypedRequest<
            { device_id: string },
            postDevicesByDeviceIdSignalingRequestBodyType,
            { peerconnection_url: string }
        >,
        res,
        next
    ) => {
        const userData = {
            JWT: {
                url: 'deprecated',
                username: 'user:anonymous',
                scopes: [],
                jwt: 'deprecated',
            },
        }

        const parameters: postDevicesByDeviceIdSignalingParametersType = {
            device_id: req.params['device_id'],
            peerconnection_url: req.query['peerconnection_url'],
        }

        const body: postDevicesByDeviceIdSignalingRequestBodyType = req.body

        try {
            if (!validatePostDevicesByDeviceIdSignalingInput(parameters, body)) {
                throw new ValidationError(
                    'Request validation failed',
                    (validatePostDevicesByDeviceIdSignalingInput as unknown as {errors: object}).errors,
                    400
                )
            }

            const result = await operations.postDevicesByDeviceIdSignaling(
                parameters,
                body,
                userData
            )

            if (!validatePostDevicesByDeviceIdSignalingOutput(result)) {
                throw new ValidationError(
                    'Response validation failed',
                    (validatePostDevicesByDeviceIdSignalingOutput as unknown as {errors: object}).errors,
                    500
                )
            }

            for (const headerName in result.headers) {
                const header = result.headers[headerName]
                if (header) {
                    res.setHeader(headerName, header)
                }
            }

            return res.status(result.status).send(result.body)
        } catch (error) {
            next(error)
            return
        }
    }
)

router.get('/peerconnections', async (_req, res, next) => {
    const userData = {
        JWT: {
            url: 'deprecated',
            username: 'user:anonymous',
            scopes: [],
            jwt: 'deprecated',
        },
    }

    try {
        if (!validateGetPeerconnectionsInput()) {
            throw new ValidationError(
                'Request validation failed',
                (validateGetPeerconnectionsInput as unknown as {errors: object}).errors,
                400
            )
        }

        const result = await operations.getPeerconnections(userData)

        if (!validateGetPeerconnectionsOutput(result)) {
            throw new ValidationError(
                'Response validation failed',
                (validateGetPeerconnectionsOutput as unknown as {errors: object}).errors,
                500
            )
        }

        for (const headerName in result.headers) {
            const header = result.headers[headerName]
            if (header) {
                res.setHeader(headerName, header)
            }
        }

        return res.status(result.status).send(result.body)
    } catch (error) {
        next(error)
        return
    }
})

router.post('/peerconnections', async (req, res, next) => {
    const userData = {
        JWT: {
            url: 'deprecated',
            username: 'user:anonymous',
            scopes: [],
            jwt: 'deprecated',
        },
    }

    const parameters: postPeerconnectionsParametersType = {
        closedUrl: req.query['closedUrl'] as string,
        statusChangedUrl: req.query['statusChangedUrl'] as string,
    }

    const body: postPeerconnectionsRequestBodyType = req.body

    try {
        if (!validatePostPeerconnectionsInput(parameters, body)) {
            throw new ValidationError(
                'Request validation failed',
                (validatePostPeerconnectionsInput as unknown as {errors: object}).errors,
                400
            )
        }

        const result = await operations.postPeerconnections(parameters, body, userData)

        if (!validatePostPeerconnectionsOutput(result)) {
            throw new ValidationError(
                'Response validation failed',
                (validatePostPeerconnectionsOutput as unknown as {errors: object}).errors,
                500
            )
        }

        for (const headerName in result.headers) {
            const header = result.headers[headerName]
            if (header) {
                res.setHeader(headerName, header)
            }
        }

        return res.status(result.status).send(result.body)
    } catch (error) {
        next(error)
        return
    }
})

router.get('/peerconnections/:peerconnection_id', async (req, res, next) => {
    const userData = {
        JWT: {
            url: 'deprecated',
            username: 'user:anonymous',
            scopes: [],
            jwt: 'deprecated',
        },
    }

    const parameters: getPeerconnectionsByPeerconnectionIdParametersType = {
        peerconnection_id: req.params['peerconnection_id'],
    }

    try {
        if (!validateGetPeerconnectionsByPeerconnectionIdInput(parameters)) {
            throw new ValidationError(
                'Request validation failed',
                (validateGetPeerconnectionsByPeerconnectionIdInput as unknown as {errors: object}).errors,
                400
            )
        }

        const result = await operations.getPeerconnectionsByPeerconnectionId(
            parameters,
            userData
        )

        if (!validateGetPeerconnectionsByPeerconnectionIdOutput(result)) {
            throw new ValidationError(
                'Response validation failed',
                (validateGetPeerconnectionsByPeerconnectionIdOutput as unknown as {errors: object}).errors,
                500
            )
        }

        for (const headerName in result.headers) {
            const header = result.headers[headerName]
            if (header) {
                res.setHeader(headerName, header)
            }
        }

        return res.status(result.status).send(result.body)
    } catch (error) {
        next(error)
        return
    }
})

router.delete('/peerconnections/:peerconnection_id', async (req, res, next) => {
    const userData = {
        JWT: {
            url: 'deprecated',
            username: 'user:anonymous',
            scopes: [],
            jwt: 'deprecated',
        },
    }

    const parameters: deletePeerconnectionsByPeerconnectionIdParametersType = {
        peerconnection_id: req.params['peerconnection_id'],
    }

    try {
        if (!validateDeletePeerconnectionsByPeerconnectionIdInput(parameters)) {
            throw new ValidationError(
                'Request validation failed',
                (validateDeletePeerconnectionsByPeerconnectionIdInput as unknown as {errors: object}).errors,
                400
            )
        }

        const result = await operations.deletePeerconnectionsByPeerconnectionId(
            parameters,
            userData
        )

        if (!validateDeletePeerconnectionsByPeerconnectionIdOutput(result)) {
            throw new ValidationError(
                'Response validation failed',
                (validateDeletePeerconnectionsByPeerconnectionIdOutput as unknown as {errors: object}).errors,
                500
            )
        }

        for (const headerName in result.headers) {
            const header = result.headers[headerName]
            if (header) {
                res.setHeader(headerName, header)
            }
        }

        return res.status(result.status).send(result.body)
    } catch (error) {
        next(error)
        return
    }
})

router.patch(
    '/peerconnections/:peerconnection_id/device_status',
    async (
        req: TypedRequest<
            { peerconnection_id: string },
            patchPeerconnectionsByPeerconnectionIdDeviceStatusRequestBodyType,
            { device_url: string }
        >,
        res,
        next
    ) => {
        const userData = {
            JWT: {
                url: 'deprecated',
                username: 'user:anonymous',
                scopes: [],
                jwt: 'deprecated',
            },
        }

        const parameters: patchPeerconnectionsByPeerconnectionIdDeviceStatusParametersType =
            {
                peerconnection_id: req.params['peerconnection_id'],
                device_url: req.query['device_url'],
            }

        const body: patchPeerconnectionsByPeerconnectionIdDeviceStatusRequestBodyType =
            req.body

        try {
            if (
                !validatePatchPeerconnectionsByPeerconnectionIdDeviceStatusInput(
                    parameters,
                    body
                )
            ) {
                throw new ValidationError(
                    'Request validation failed',
                    (
                        validatePatchPeerconnectionsByPeerconnectionIdDeviceStatusInput as unknown as {errors: object}
                    ).errors,
                    400
                )
            }

            const result =
                await operations.patchPeerconnectionsByPeerconnectionIdDeviceStatus(
                    parameters,
                    body,
                    userData
                )

            if (
                !validatePatchPeerconnectionsByPeerconnectionIdDeviceStatusOutput(result)
            ) {
                throw new ValidationError(
                    'Response validation failed',
                    (
                        validatePatchPeerconnectionsByPeerconnectionIdDeviceStatusOutput as unknown as {errors: object}
                    ).errors,
                    500
                )
            }

            for (const headerName in result.headers) {
                const header = result.headers[headerName]
                if (header) {
                    res.setHeader(headerName, header)
                }
            }

            return res.status(result.status).send(result.body)
        } catch (error) {
            next(error)
            return
        }
    }
)
