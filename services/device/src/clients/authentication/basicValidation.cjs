/* eslint-disable */
//@ts-nocheck
/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */
'use strict';
exports.validateCredentials = validate21;
const schema6 = {
  title: 'Credentials',
  type: 'object',
  properties: {
    username: { description: 'Username of the user.', type: 'string' },
    password: { description: 'Password of the user.', type: 'string' },
  },
  required: ['username', 'password'],
  'x-standalone': true,
  'x-name': 'Credentials',
  'x-location': '#/components/schemas/credentials',
  'x-schema-type': 'all',
};
function validate21(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate21.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema6.required,
            parentSchema: schema6,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate21.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema6.properties.username.type,
                parentSchema: schema6.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate21.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema6.properties.password.type,
                  parentSchema: schema6.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate21.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema6.type,
          parentSchema: schema6,
          data,
        },
      ];
      return false;
    }
  }
  validate21.errors = vErrors;
  return errors === 0;
}
exports.validateAuthMethod = validate22;
const schema7 = {
  title: 'AuthMethod',
  type: 'string',
  description: 'Authentication method.',
  enum: ['tui', 'local'],
  'x-standalone': true,
  'x-name': 'AuthMethod',
  'x-location': '#/components/schemas/auth_method',
  'x-schema-type': 'all',
};
function validate22(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate22.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema7.type,
        parentSchema: schema7,
        data,
      },
    ];
    return false;
  }
  if (!(data === 'tui' || data === 'local')) {
    validate22.errors = [
      {
        instancePath,
        schemaPath: '#/enum',
        keyword: 'enum',
        params: { allowedValues: schema7.enum },
        message: 'must be equal to one of the allowed values',
        schema: schema7.enum,
        parentSchema: schema7,
        data,
      },
    ];
    return false;
  }
  validate22.errors = vErrors;
  return errors === 0;
}
exports.validateUser = validate23;
const schema8 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['url', 'id', 'username', 'password'],
  'x-standalone': true,
  'x-name': 'User',
  'x-location': '#/components/schemas/user',
  'x-schema-type': 'all',
};
const formats0 = require('ajv-formats/dist/formats').fullFormats.uri;
function validate23(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate23.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema8.required,
            parentSchema: schema8,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate23.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema8.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate23.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema8.properties.url.type,
                    parentSchema: schema8.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate23.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema8.properties.id.type,
                  parentSchema: schema8.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate23.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema8.properties.username.type,
                    parentSchema: schema8.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== 'string') {
                  validate23.errors = [
                    {
                      instancePath: instancePath + '/password',
                      schemaPath: '#/properties/password/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema8.properties.password.type,
                      parentSchema: schema8.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate23.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema8.type,
          parentSchema: schema8,
          data,
        },
      ];
      return false;
    }
  }
  validate23.errors = vErrors;
  return errors === 0;
}
exports.validateUserUpdate = validate24;
const schema9 = {
  title: 'User Update',
  type: 'object',
  properties: { password: { type: 'string', writeOnly: true } },
  required: ['password'],
  'x-standalone': true,
  'x-name': 'UserUpdate',
  'x-location': '#/components/schemas/user_update',
  'x-schema-type': 'all',
};
function validate24(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = 'password')) {
        validate24.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema9.required,
            parentSchema: schema9,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== 'string') {
            validate24.errors = [
              {
                instancePath: instancePath + '/password',
                schemaPath: '#/properties/password/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema9.properties.password.type,
                parentSchema: schema9.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate24.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema9.type,
          parentSchema: schema9,
          data,
        },
      ];
      return false;
    }
  }
  validate24.errors = vErrors;
  return errors === 0;
}
exports.validateAuthorization = validate25;
const schema10 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'Authorization',
  'x-location': '#/components/parameters/authorization/schema',
  'x-schema-type': 'all',
};
function validate25(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate25.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema10.type,
        parentSchema: schema10,
        data,
      },
    ];
    return false;
  }
  validate25.errors = vErrors;
  return errors === 0;
}
exports.validateXRealIP = validate26;
const schema11 = {
  type: 'string',
  format: 'ipv4',
  description: 'The IP address of the client.',
  'x-standalone': false,
  'x-name': 'XRealIP',
  'x-location': '#/components/parameters/x_real_ip/schema',
  'x-schema-type': 'all',
};
const formats2 =
  /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
function validate26(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === 'string') {
        if (!formats2.test(data)) {
          validate26.errors = [
            {
              instancePath,
              schemaPath: '#/format',
              keyword: 'format',
              params: { format: 'ipv4' },
              message: 'must match format "' + 'ipv4' + '"',
              schema: 'ipv4',
              parentSchema: schema11,
              data,
            },
          ];
          return false;
        }
      } else {
        validate26.errors = [
          {
            instancePath,
            schemaPath: '#/type',
            keyword: 'type',
            params: { type: 'string' },
            message: 'must be string',
            schema: schema11.type,
            parentSchema: schema11,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate26.errors = vErrors;
  return errors === 0;
}
exports.validateXForwardedProto = validate27;
const schema12 = {
  type: 'string',
  description: 'The protocol of the client.',
  'x-standalone': false,
  'x-name': 'XForwardedProto',
  'x-location': '#/components/parameters/x_forwarded_proto/schema',
  'x-schema-type': 'all',
};
function validate27(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate27.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema12.type,
        parentSchema: schema12,
        data,
      },
    ];
    return false;
  }
  validate27.errors = vErrors;
  return errors === 0;
}
exports.validateUserId = validate28;
const schema13 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'UserId',
  'x-location': '#/components/parameters/user_id/schema',
  'x-schema-type': 'all',
};
function validate28(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate28.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema13.type,
        parentSchema: schema13,
        data,
      },
    ];
    return false;
  }
  validate28.errors = vErrors;
  return errors === 0;
}
exports.validateAuthXRequestAuthentication = validate29;
const schema14 = {
  type: 'string',
  format: 'jwt',
  description: 'The JWT which represents the authenticated user.',
  'x-standalone': false,
  'x-name': 'authXRequestAuthentication',
  'x-location': '#/paths//auth/get/responses/200/headers/X-Request-Authentication/schema',
  'x-schema-type': 'all',
};
const formats4 = /^Bearer ([a-zA-Z0-9_=]+)\.([a-zA-Z0-9_=]+)\.([a-zA-Z0-9_\-+/=]*)/;
function validate29(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === 'string') {
        if (!formats4.test(data)) {
          validate29.errors = [
            {
              instancePath,
              schemaPath: '#/format',
              keyword: 'format',
              params: { format: 'jwt' },
              message: 'must match format "' + 'jwt' + '"',
              schema: 'jwt',
              parentSchema: schema14,
              data,
            },
          ];
          return false;
        }
      } else {
        validate29.errors = [
          {
            instancePath,
            schemaPath: '#/type',
            keyword: 'type',
            params: { type: 'string' },
            message: 'must be string',
            schema: schema14.type,
            parentSchema: schema14,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate29.errors = vErrors;
  return errors === 0;
}
exports.validateLoginBody = validate30;
const schema15 = {
  allOf: [
    {
      title: 'Credentials',
      type: 'object',
      properties: {
        username: { description: 'Username of the user.', type: 'string' },
        password: { description: 'Password of the user.', type: 'string' },
      },
      required: ['username', 'password'],
    },
    {
      type: 'object',
      properties: {
        method: {
          title: 'AuthMethod',
          type: 'string',
          description: 'Authentication method.',
          enum: ['tui', 'local'],
        },
      },
    },
  ],
  'x-standalone': false,
  'x-name': 'loginBody',
  'x-location': '#/paths//login/post/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate30(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  if (errors === _errs0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate30.errors = [
          {
            instancePath,
            schemaPath: '#/allOf/0/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema15.allOf[0].required,
            parentSchema: schema15.allOf[0],
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs2 = errors;
          if (typeof data0 !== 'string') {
            validate30.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/allOf/0/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema15.allOf[0].properties.username.type,
                parentSchema: schema15.allOf[0].properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid1 = _errs2 === errors;
        } else {
          var valid1 = true;
        }
        if (valid1) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs4 = errors;
            if (typeof data1 !== 'string') {
              validate30.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/allOf/0/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema15.allOf[0].properties.password.type,
                  parentSchema: schema15.allOf[0].properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid1 = _errs4 === errors;
          } else {
            var valid1 = true;
          }
        }
      }
    } else {
      validate30.errors = [
        {
          instancePath,
          schemaPath: '#/allOf/0/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema15.allOf[0].type,
          parentSchema: schema15.allOf[0],
          data,
        },
      ];
      return false;
    }
  }
  var valid0 = _errs0 === errors;
  if (valid0) {
    const _errs6 = errors;
    if (errors === _errs6) {
      if (data && typeof data == 'object' && !Array.isArray(data)) {
        if (data.method !== undefined) {
          let data2 = data.method;
          if (typeof data2 !== 'string') {
            validate30.errors = [
              {
                instancePath: instancePath + '/method',
                schemaPath: '#/allOf/1/properties/method/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema15.allOf[1].properties.method.type,
                parentSchema: schema15.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
          if (!(data2 === 'tui' || data2 === 'local')) {
            validate30.errors = [
              {
                instancePath: instancePath + '/method',
                schemaPath: '#/allOf/1/properties/method/enum',
                keyword: 'enum',
                params: { allowedValues: schema15.allOf[1].properties.method.enum },
                message: 'must be equal to one of the allowed values',
                schema: schema15.allOf[1].properties.method.enum,
                parentSchema: schema15.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
        }
      } else {
        validate30.errors = [
          {
            instancePath,
            schemaPath: '#/allOf/1/type',
            keyword: 'type',
            params: { type: 'object' },
            message: 'must be object',
            schema: schema15.allOf[1].type,
            parentSchema: schema15.allOf[1],
            data,
          },
        ];
        return false;
      }
    }
    var valid0 = _errs6 === errors;
  }
  validate30.errors = vErrors;
  return errors === 0;
}
exports.validateLoginResponse201 = validate31;
const schema16 = {
  description: 'The access token.',
  type: 'string',
  'x-standalone': false,
  'x-name': 'loginResponse201',
  'x-location': '#/paths//login/post/responses/201/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate31(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate31.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema16.type,
        parentSchema: schema16,
        data,
      },
    ];
    return false;
  }
  validate31.errors = vErrors;
  return errors === 0;
}
exports.validateLogoutBody = validate32;
const schema17 = {
  type: 'object',
  properties: { token: { type: 'string', description: 'The token to be invalidated.' } },
  'x-standalone': false,
  'x-name': 'logoutBody',
  'x-location': '#/paths//logout/post/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate32(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.token !== undefined) {
        let data0 = data.token;
        if (typeof data0 !== 'string') {
          validate32.errors = [
            {
              instancePath: instancePath + '/token',
              schemaPath: '#/properties/token/type',
              keyword: 'type',
              params: { type: 'string' },
              message: 'must be string',
              schema: schema17.properties.token.type,
              parentSchema: schema17.properties.token,
              data: data0,
            },
          ];
          return false;
        }
      }
    } else {
      validate32.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema17.type,
          parentSchema: schema17,
          data,
        },
      ];
      return false;
    }
  }
  validate32.errors = vErrors;
  return errors === 0;
}
exports.validateListUsersResponse200 = validate33;
const schema18 = {
  type: 'array',
  items: {
    title: 'User',
    type: 'object',
    properties: {
      url: { type: 'string', format: 'uri', readOnly: true },
      id: { type: 'string', readOnly: true },
      username: { type: 'string' },
      password: { type: 'string', writeOnly: true },
    },
    required: ['url', 'id', 'username', 'password'],
  },
  'x-standalone': false,
  'x-name': 'listUsersResponse200',
  'x-location': '#/paths//users/get/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate33(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.url === undefined && (missing0 = 'url')) ||
              (data0.id === undefined && (missing0 = 'id')) ||
              (data0.username === undefined && (missing0 = 'username')) ||
              (data0.password === undefined && (missing0 = 'password'))
            ) {
              validate33.errors = [
                {
                  instancePath: instancePath + '/' + i0,
                  schemaPath: '#/items/required',
                  keyword: 'required',
                  params: { missingProperty: missing0 },
                  message: "must have required property '" + missing0 + "'",
                  schema: schema18.items.required,
                  parentSchema: schema18.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.url !== undefined) {
                let data1 = data0.url;
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (errors === _errs3) {
                    if (typeof data1 === 'string') {
                      if (!formats0(data1)) {
                        validate33.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/url',
                            schemaPath: '#/items/properties/url/format',
                            keyword: 'format',
                            params: { format: 'uri' },
                            message: 'must match format "' + 'uri' + '"',
                            schema: 'uri',
                            parentSchema: schema18.items.properties.url,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    } else {
                      validate33.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/url',
                          schemaPath: '#/items/properties/url/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema18.items.properties.url.type,
                          parentSchema: schema18.items.properties.url,
                          data: data1,
                        },
                      ];
                      return false;
                    }
                  }
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.id !== undefined) {
                  let data2 = data0.id;
                  const _errs5 = errors;
                  if (typeof data2 !== 'string') {
                    validate33.errors = [
                      {
                        instancePath: instancePath + '/' + i0 + '/id',
                        schemaPath: '#/items/properties/id/type',
                        keyword: 'type',
                        params: { type: 'string' },
                        message: 'must be string',
                        schema: schema18.items.properties.id.type,
                        parentSchema: schema18.items.properties.id,
                        data: data2,
                      },
                    ];
                    return false;
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.username !== undefined) {
                    let data3 = data0.username;
                    const _errs7 = errors;
                    if (typeof data3 !== 'string') {
                      validate33.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/username',
                          schemaPath: '#/items/properties/username/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema18.items.properties.username.type,
                          parentSchema: schema18.items.properties.username,
                          data: data3,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs7 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data0.password !== undefined) {
                      let data4 = data0.password;
                      const _errs9 = errors;
                      if (typeof data4 !== 'string') {
                        validate33.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/password',
                            schemaPath: '#/items/properties/password/type',
                            keyword: 'type',
                            params: { type: 'string' },
                            message: 'must be string',
                            schema: schema18.items.properties.password.type,
                            parentSchema: schema18.items.properties.password,
                            data: data4,
                          },
                        ];
                        return false;
                      }
                      var valid1 = _errs9 === errors;
                    } else {
                      var valid1 = true;
                    }
                  }
                }
              }
            }
          } else {
            validate33.errors = [
              {
                instancePath: instancePath + '/' + i0,
                schemaPath: '#/items/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema18.items.type,
                parentSchema: schema18.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate33.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
          schema: schema18.type,
          parentSchema: schema18,
          data,
        },
      ];
      return false;
    }
  }
  validate33.errors = vErrors;
  return errors === 0;
}
exports.validateCreateUserBody = validate34;
const schema19 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['url', 'id', 'username', 'password'],
  'x-standalone': false,
  'x-name': 'createUserBody',
  'x-location': '#/paths//users/post/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate34(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate34.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema19.required,
            parentSchema: schema19,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate34.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema19.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate34.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema19.properties.url.type,
                    parentSchema: schema19.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate34.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema19.properties.id.type,
                  parentSchema: schema19.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate34.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema19.properties.username.type,
                    parentSchema: schema19.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== 'string') {
                  validate34.errors = [
                    {
                      instancePath: instancePath + '/password',
                      schemaPath: '#/properties/password/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema19.properties.password.type,
                      parentSchema: schema19.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate34.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema19.type,
          parentSchema: schema19,
          data,
        },
      ];
      return false;
    }
  }
  validate34.errors = vErrors;
  return errors === 0;
}
exports.validateCreateUserResponse201 = validate35;
const schema20 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['url', 'id', 'username', 'password'],
  'x-standalone': false,
  'x-name': 'createUserResponse201',
  'x-location': '#/paths//users/post/responses/201/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate35(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate35.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema20.required,
            parentSchema: schema20,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate35.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema20.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate35.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema20.properties.url.type,
                    parentSchema: schema20.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate35.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema20.properties.id.type,
                  parentSchema: schema20.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate35.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema20.properties.username.type,
                    parentSchema: schema20.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== 'string') {
                  validate35.errors = [
                    {
                      instancePath: instancePath + '/password',
                      schemaPath: '#/properties/password/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema20.properties.password.type,
                      parentSchema: schema20.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate35.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema20.type,
          parentSchema: schema20,
          data,
        },
      ];
      return false;
    }
  }
  validate35.errors = vErrors;
  return errors === 0;
}
exports.validateGetUserResponse200 = validate36;
const schema21 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['url', 'id', 'username', 'password'],
  'x-standalone': false,
  'x-name': 'getUserResponse200',
  'x-location':
    '#/paths//users/{user_id}/get/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate36(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate36.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema21.required,
            parentSchema: schema21,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate36.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema21.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate36.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema21.properties.url.type,
                    parentSchema: schema21.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate36.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema21.properties.id.type,
                  parentSchema: schema21.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate36.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema21.properties.username.type,
                    parentSchema: schema21.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== 'string') {
                  validate36.errors = [
                    {
                      instancePath: instancePath + '/password',
                      schemaPath: '#/properties/password/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema21.properties.password.type,
                      parentSchema: schema21.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate36.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema21.type,
          parentSchema: schema21,
          data,
        },
      ];
      return false;
    }
  }
  validate36.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateUserBody = validate37;
const schema22 = {
  title: 'User Update',
  type: 'object',
  properties: { password: { type: 'string', writeOnly: true } },
  required: ['password'],
  'x-standalone': false,
  'x-name': 'updateUserBody',
  'x-location':
    '#/paths//users/{user_id}/patch/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate37(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = 'password')) {
        validate37.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema22.required,
            parentSchema: schema22,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== 'string') {
            validate37.errors = [
              {
                instancePath: instancePath + '/password',
                schemaPath: '#/properties/password/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema22.properties.password.type,
                parentSchema: schema22.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate37.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema22.type,
          parentSchema: schema22,
          data,
        },
      ];
      return false;
    }
  }
  validate37.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateUserResponse200 = validate38;
const schema23 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['url', 'id', 'username', 'password'],
  'x-standalone': false,
  'x-name': 'updateUserResponse200',
  'x-location':
    '#/paths//users/{user_id}/patch/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate38(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate38.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema23.required,
            parentSchema: schema23,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate38.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema23.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate38.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema23.properties.url.type,
                    parentSchema: schema23.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate38.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema23.properties.id.type,
                  parentSchema: schema23.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate38.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema23.properties.username.type,
                    parentSchema: schema23.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== 'string') {
                  validate38.errors = [
                    {
                      instancePath: instancePath + '/password',
                      schemaPath: '#/properties/password/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema23.properties.password.type,
                      parentSchema: schema23.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate38.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema23.type,
          parentSchema: schema23,
          data,
        },
      ];
      return false;
    }
  }
  validate38.errors = vErrors;
  return errors === 0;
}
exports.validateGetIdentityResponse200 = validate39;
const schema24 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['url', 'id', 'username', 'password'],
  'x-standalone': false,
  'x-name': 'getIdentityResponse200',
  'x-location': '#/paths//identity/get/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate39(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate39.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema24.required,
            parentSchema: schema24,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate39.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema24.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate39.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema24.properties.url.type,
                    parentSchema: schema24.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate39.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema24.properties.id.type,
                  parentSchema: schema24.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate39.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema24.properties.username.type,
                    parentSchema: schema24.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== 'string') {
                  validate39.errors = [
                    {
                      instancePath: instancePath + '/password',
                      schemaPath: '#/properties/password/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema24.properties.password.type,
                      parentSchema: schema24.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate39.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema24.type,
          parentSchema: schema24,
          data,
        },
      ];
      return false;
    }
  }
  validate39.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateIdentityBody = validate40;
const schema25 = {
  title: 'User Update',
  type: 'object',
  properties: { password: { type: 'string', writeOnly: true } },
  required: ['password'],
  'x-standalone': false,
  'x-name': 'updateIdentityBody',
  'x-location': '#/paths//identity/patch/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate40(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = 'password')) {
        validate40.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema25.required,
            parentSchema: schema25,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== 'string') {
            validate40.errors = [
              {
                instancePath: instancePath + '/password',
                schemaPath: '#/properties/password/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema25.properties.password.type,
                parentSchema: schema25.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate40.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema25.type,
          parentSchema: schema25,
          data,
        },
      ];
      return false;
    }
  }
  validate40.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateIdentityResponse200 = validate41;
const schema26 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['url', 'id', 'username', 'password'],
  'x-standalone': false,
  'x-name': 'updateIdentityResponse200',
  'x-location': '#/paths//identity/patch/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate41(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate41.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema26.required,
            parentSchema: schema26,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate41.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema26.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate41.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema26.properties.url.type,
                    parentSchema: schema26.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate41.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema26.properties.id.type,
                  parentSchema: schema26.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate41.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema26.properties.username.type,
                    parentSchema: schema26.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== 'string') {
                  validate41.errors = [
                    {
                      instancePath: instancePath + '/password',
                      schemaPath: '#/properties/password/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema26.properties.password.type,
                      parentSchema: schema26.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate41.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema26.type,
          parentSchema: schema26,
          data,
        },
      ];
      return false;
    }
  }
  validate41.errors = vErrors;
  return errors === 0;
}
exports.validateCreateTokenBody = validate42;
const schema27 = {
  type: 'object',
  properties: {
    username: { type: 'string', description: 'The username of the user.' },
    claims: {
      type: 'object',
      description:
        'The claims that will be added to the token. If left empty, the token will have the full scope of the user.\n',
    },
  },
  'x-standalone': false,
  'x-name': 'createTokenBody',
  'x-location': '#/paths//token/post/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate42(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.username !== undefined) {
        let data0 = data.username;
        const _errs1 = errors;
        if (typeof data0 !== 'string') {
          validate42.errors = [
            {
              instancePath: instancePath + '/username',
              schemaPath: '#/properties/username/type',
              keyword: 'type',
              params: { type: 'string' },
              message: 'must be string',
              schema: schema27.properties.username.type,
              parentSchema: schema27.properties.username,
              data: data0,
            },
          ];
          return false;
        }
        var valid0 = _errs1 === errors;
      } else {
        var valid0 = true;
      }
      if (valid0) {
        if (data.claims !== undefined) {
          let data1 = data.claims;
          const _errs3 = errors;
          if (!(data1 && typeof data1 == 'object' && !Array.isArray(data1))) {
            validate42.errors = [
              {
                instancePath: instancePath + '/claims',
                schemaPath: '#/properties/claims/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema27.properties.claims.type,
                parentSchema: schema27.properties.claims,
                data: data1,
              },
            ];
            return false;
          }
          var valid0 = _errs3 === errors;
        } else {
          var valid0 = true;
        }
      }
    } else {
      validate42.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema27.type,
          parentSchema: schema27,
          data,
        },
      ];
      return false;
    }
  }
  validate42.errors = vErrors;
  return errors === 0;
}
exports.validateCreateTokenResponse201 = validate43;
const schema28 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'createTokenResponse201',
  'x-location': '#/paths//token/post/responses/201/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate43(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate43.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema28.type,
        parentSchema: schema28,
        data,
      },
    ];
    return false;
  }
  validate43.errors = vErrors;
  return errors === 0;
}
exports.validateCredentialsRequest = validate44;
const schema29 = {
  title: 'Credentials',
  type: 'object',
  properties: {
    username: { description: 'Username of the user.', type: 'string' },
    password: { description: 'Password of the user.', type: 'string' },
  },
  required: ['username', 'password'],
  'x-standalone': true,
  'x-name': 'CredentialsRequest',
  'x-location': '#/components/schemas/credentials_request',
  'x-schema-type': 'request',
};
function validate44(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate44.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema29.required,
            parentSchema: schema29,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate44.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema29.properties.username.type,
                parentSchema: schema29.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate44.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema29.properties.password.type,
                  parentSchema: schema29.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate44.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema29.type,
          parentSchema: schema29,
          data,
        },
      ];
      return false;
    }
  }
  validate44.errors = vErrors;
  return errors === 0;
}
exports.validateCredentialsResponse = validate45;
const schema30 = {
  title: 'Credentials',
  type: 'object',
  properties: {
    username: { description: 'Username of the user.', type: 'string' },
    password: { description: 'Password of the user.', type: 'string' },
  },
  required: ['username', 'password'],
  'x-standalone': true,
  'x-name': 'CredentialsResponse',
  'x-location': '#/components/schemas/credentials_response',
  'x-schema-type': 'response',
};
function validate45(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate45.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema30.required,
            parentSchema: schema30,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate45.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema30.properties.username.type,
                parentSchema: schema30.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate45.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema30.properties.password.type,
                  parentSchema: schema30.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate45.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema30.type,
          parentSchema: schema30,
          data,
        },
      ];
      return false;
    }
  }
  validate45.errors = vErrors;
  return errors === 0;
}
exports.validateAuthMethodRequest = validate46;
const schema31 = {
  title: 'AuthMethod',
  type: 'string',
  description: 'Authentication method.',
  enum: ['tui', 'local'],
  'x-standalone': true,
  'x-name': 'AuthMethodRequest',
  'x-location': '#/components/schemas/auth_method_request',
  'x-schema-type': 'request',
};
function validate46(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate46.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema31.type,
        parentSchema: schema31,
        data,
      },
    ];
    return false;
  }
  if (!(data === 'tui' || data === 'local')) {
    validate46.errors = [
      {
        instancePath,
        schemaPath: '#/enum',
        keyword: 'enum',
        params: { allowedValues: schema31.enum },
        message: 'must be equal to one of the allowed values',
        schema: schema31.enum,
        parentSchema: schema31,
        data,
      },
    ];
    return false;
  }
  validate46.errors = vErrors;
  return errors === 0;
}
exports.validateAuthMethodResponse = validate47;
const schema32 = {
  title: 'AuthMethod',
  type: 'string',
  description: 'Authentication method.',
  enum: ['tui', 'local'],
  'x-standalone': true,
  'x-name': 'AuthMethodResponse',
  'x-location': '#/components/schemas/auth_method_response',
  'x-schema-type': 'response',
};
function validate47(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate47.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema32.type,
        parentSchema: schema32,
        data,
      },
    ];
    return false;
  }
  if (!(data === 'tui' || data === 'local')) {
    validate47.errors = [
      {
        instancePath,
        schemaPath: '#/enum',
        keyword: 'enum',
        params: { allowedValues: schema32.enum },
        message: 'must be equal to one of the allowed values',
        schema: schema32.enum,
        parentSchema: schema32,
        data,
      },
    ];
    return false;
  }
  validate47.errors = vErrors;
  return errors === 0;
}
exports.validateUserRequest = validate48;
const schema33 = {
  title: 'User',
  type: 'object',
  properties: {
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['username', 'password'],
  'x-standalone': true,
  'x-name': 'UserRequest',
  'x-location': '#/components/schemas/user_request',
  'x-schema-type': 'request',
};
function validate48(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate48.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema33.required,
            parentSchema: schema33,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate48.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema33.properties.username.type,
                parentSchema: schema33.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate48.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema33.properties.password.type,
                  parentSchema: schema33.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate48.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema33.type,
          parentSchema: schema33,
          data,
        },
      ];
      return false;
    }
  }
  validate48.errors = vErrors;
  return errors === 0;
}
exports.validateUserResponse = validate49;
const schema34 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
  },
  required: ['url', 'id', 'username'],
  'x-standalone': true,
  'x-name': 'UserResponse',
  'x-location': '#/components/schemas/user_response',
  'x-schema-type': 'response',
};
function validate49(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username'))
      ) {
        validate49.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema34.required,
            parentSchema: schema34,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate49.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema34.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate49.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema34.properties.url.type,
                    parentSchema: schema34.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate49.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema34.properties.id.type,
                  parentSchema: schema34.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate49.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema34.properties.username.type,
                    parentSchema: schema34.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate49.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema34.type,
          parentSchema: schema34,
          data,
        },
      ];
      return false;
    }
  }
  validate49.errors = vErrors;
  return errors === 0;
}
exports.validateUserUpdateRequest = validate50;
const schema35 = {
  title: 'User Update',
  type: 'object',
  properties: { password: { type: 'string', writeOnly: true } },
  required: ['password'],
  'x-standalone': true,
  'x-name': 'UserUpdateRequest',
  'x-location': '#/components/schemas/user_update_request',
  'x-schema-type': 'request',
};
function validate50(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = 'password')) {
        validate50.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema35.required,
            parentSchema: schema35,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== 'string') {
            validate50.errors = [
              {
                instancePath: instancePath + '/password',
                schemaPath: '#/properties/password/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema35.properties.password.type,
                parentSchema: schema35.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate50.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema35.type,
          parentSchema: schema35,
          data,
        },
      ];
      return false;
    }
  }
  validate50.errors = vErrors;
  return errors === 0;
}
exports.validateUserUpdateResponse = validate51;
const schema36 = {
  title: 'User Update',
  type: 'object',
  properties: {},
  required: [],
  'x-standalone': true,
  'x-name': 'UserUpdateResponse',
  'x-location': '#/components/schemas/user_update_response',
  'x-schema-type': 'response',
};
function validate51(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (!(data && typeof data == 'object' && !Array.isArray(data))) {
      validate51.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema36.type,
          parentSchema: schema36,
          data,
        },
      ];
      return false;
    }
  }
  validate51.errors = vErrors;
  return errors === 0;
}
exports.validateAuthorizationRequest = validate52;
const schema37 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'AuthorizationRequest',
  'x-location': '#/components/parameters/authorization/schema_request',
  'x-schema-type': 'request',
};
function validate52(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate52.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema37.type,
        parentSchema: schema37,
        data,
      },
    ];
    return false;
  }
  validate52.errors = vErrors;
  return errors === 0;
}
exports.validateAuthorizationResponse = validate53;
const schema38 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'AuthorizationResponse',
  'x-location': '#/components/parameters/authorization/schema_response',
  'x-schema-type': 'response',
};
function validate53(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate53.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema38.type,
        parentSchema: schema38,
        data,
      },
    ];
    return false;
  }
  validate53.errors = vErrors;
  return errors === 0;
}
exports.validateXRealIPRequest = validate54;
const schema39 = {
  type: 'string',
  format: 'ipv4',
  description: 'The IP address of the client.',
  'x-standalone': false,
  'x-name': 'XRealIPRequest',
  'x-location': '#/components/parameters/x_real_ip/schema_request',
  'x-schema-type': 'request',
};
function validate54(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === 'string') {
        if (!formats2.test(data)) {
          validate54.errors = [
            {
              instancePath,
              schemaPath: '#/format',
              keyword: 'format',
              params: { format: 'ipv4' },
              message: 'must match format "' + 'ipv4' + '"',
              schema: 'ipv4',
              parentSchema: schema39,
              data,
            },
          ];
          return false;
        }
      } else {
        validate54.errors = [
          {
            instancePath,
            schemaPath: '#/type',
            keyword: 'type',
            params: { type: 'string' },
            message: 'must be string',
            schema: schema39.type,
            parentSchema: schema39,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate54.errors = vErrors;
  return errors === 0;
}
exports.validateXRealIPResponse = validate55;
const schema40 = {
  type: 'string',
  format: 'ipv4',
  description: 'The IP address of the client.',
  'x-standalone': false,
  'x-name': 'XRealIPResponse',
  'x-location': '#/components/parameters/x_real_ip/schema_response',
  'x-schema-type': 'response',
};
function validate55(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === 'string') {
        if (!formats2.test(data)) {
          validate55.errors = [
            {
              instancePath,
              schemaPath: '#/format',
              keyword: 'format',
              params: { format: 'ipv4' },
              message: 'must match format "' + 'ipv4' + '"',
              schema: 'ipv4',
              parentSchema: schema40,
              data,
            },
          ];
          return false;
        }
      } else {
        validate55.errors = [
          {
            instancePath,
            schemaPath: '#/type',
            keyword: 'type',
            params: { type: 'string' },
            message: 'must be string',
            schema: schema40.type,
            parentSchema: schema40,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate55.errors = vErrors;
  return errors === 0;
}
exports.validateXForwardedProtoRequest = validate56;
const schema41 = {
  type: 'string',
  description: 'The protocol of the client.',
  'x-standalone': false,
  'x-name': 'XForwardedProtoRequest',
  'x-location': '#/components/parameters/x_forwarded_proto/schema_request',
  'x-schema-type': 'request',
};
function validate56(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate56.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema41.type,
        parentSchema: schema41,
        data,
      },
    ];
    return false;
  }
  validate56.errors = vErrors;
  return errors === 0;
}
exports.validateXForwardedProtoResponse = validate57;
const schema42 = {
  type: 'string',
  description: 'The protocol of the client.',
  'x-standalone': false,
  'x-name': 'XForwardedProtoResponse',
  'x-location': '#/components/parameters/x_forwarded_proto/schema_response',
  'x-schema-type': 'response',
};
function validate57(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate57.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema42.type,
        parentSchema: schema42,
        data,
      },
    ];
    return false;
  }
  validate57.errors = vErrors;
  return errors === 0;
}
exports.validateUserIdRequest = validate58;
const schema43 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'UserIdRequest',
  'x-location': '#/components/parameters/user_id/schema_request',
  'x-schema-type': 'request',
};
function validate58(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate58.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema43.type,
        parentSchema: schema43,
        data,
      },
    ];
    return false;
  }
  validate58.errors = vErrors;
  return errors === 0;
}
exports.validateUserIdResponse = validate59;
const schema44 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'UserIdResponse',
  'x-location': '#/components/parameters/user_id/schema_response',
  'x-schema-type': 'response',
};
function validate59(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate59.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema44.type,
        parentSchema: schema44,
        data,
      },
    ];
    return false;
  }
  validate59.errors = vErrors;
  return errors === 0;
}
exports.validateAuthXRequestAuthenticationRequest = validate60;
const schema45 = {
  type: 'string',
  format: 'jwt',
  description: 'The JWT which represents the authenticated user.',
  'x-standalone': false,
  'x-name': 'authXRequestAuthenticationRequest',
  'x-location':
    '#/paths//auth/get/responses/200/headers/X-Request-Authentication/schema_request',
  'x-schema-type': 'request',
};
function validate60(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === 'string') {
        if (!formats4.test(data)) {
          validate60.errors = [
            {
              instancePath,
              schemaPath: '#/format',
              keyword: 'format',
              params: { format: 'jwt' },
              message: 'must match format "' + 'jwt' + '"',
              schema: 'jwt',
              parentSchema: schema45,
              data,
            },
          ];
          return false;
        }
      } else {
        validate60.errors = [
          {
            instancePath,
            schemaPath: '#/type',
            keyword: 'type',
            params: { type: 'string' },
            message: 'must be string',
            schema: schema45.type,
            parentSchema: schema45,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate60.errors = vErrors;
  return errors === 0;
}
exports.validateAuthXRequestAuthenticationResponse = validate61;
const schema46 = {
  type: 'string',
  format: 'jwt',
  description: 'The JWT which represents the authenticated user.',
  'x-standalone': false,
  'x-name': 'authXRequestAuthenticationResponse',
  'x-location':
    '#/paths//auth/get/responses/200/headers/X-Request-Authentication/schema_response',
  'x-schema-type': 'response',
};
function validate61(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === 'string') {
        if (!formats4.test(data)) {
          validate61.errors = [
            {
              instancePath,
              schemaPath: '#/format',
              keyword: 'format',
              params: { format: 'jwt' },
              message: 'must match format "' + 'jwt' + '"',
              schema: 'jwt',
              parentSchema: schema46,
              data,
            },
          ];
          return false;
        }
      } else {
        validate61.errors = [
          {
            instancePath,
            schemaPath: '#/type',
            keyword: 'type',
            params: { type: 'string' },
            message: 'must be string',
            schema: schema46.type,
            parentSchema: schema46,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate61.errors = vErrors;
  return errors === 0;
}
exports.validateLoginBodyRequest = validate62;
const schema47 = {
  allOf: [
    {
      title: 'Credentials',
      type: 'object',
      properties: {
        username: { description: 'Username of the user.', type: 'string' },
        password: { description: 'Password of the user.', type: 'string' },
      },
      required: ['username', 'password'],
    },
    {
      type: 'object',
      properties: {
        method: {
          title: 'AuthMethod',
          type: 'string',
          description: 'Authentication method.',
          enum: ['tui', 'local'],
        },
      },
    },
  ],
  'x-standalone': false,
  'x-name': 'loginBodyRequest',
  'x-location': '#/paths//login/post/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate62(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  if (errors === _errs0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate62.errors = [
          {
            instancePath,
            schemaPath: '#/allOf/0/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema47.allOf[0].required,
            parentSchema: schema47.allOf[0],
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs2 = errors;
          if (typeof data0 !== 'string') {
            validate62.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/allOf/0/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema47.allOf[0].properties.username.type,
                parentSchema: schema47.allOf[0].properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid1 = _errs2 === errors;
        } else {
          var valid1 = true;
        }
        if (valid1) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs4 = errors;
            if (typeof data1 !== 'string') {
              validate62.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/allOf/0/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema47.allOf[0].properties.password.type,
                  parentSchema: schema47.allOf[0].properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid1 = _errs4 === errors;
          } else {
            var valid1 = true;
          }
        }
      }
    } else {
      validate62.errors = [
        {
          instancePath,
          schemaPath: '#/allOf/0/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema47.allOf[0].type,
          parentSchema: schema47.allOf[0],
          data,
        },
      ];
      return false;
    }
  }
  var valid0 = _errs0 === errors;
  if (valid0) {
    const _errs6 = errors;
    if (errors === _errs6) {
      if (data && typeof data == 'object' && !Array.isArray(data)) {
        if (data.method !== undefined) {
          let data2 = data.method;
          if (typeof data2 !== 'string') {
            validate62.errors = [
              {
                instancePath: instancePath + '/method',
                schemaPath: '#/allOf/1/properties/method/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema47.allOf[1].properties.method.type,
                parentSchema: schema47.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
          if (!(data2 === 'tui' || data2 === 'local')) {
            validate62.errors = [
              {
                instancePath: instancePath + '/method',
                schemaPath: '#/allOf/1/properties/method/enum',
                keyword: 'enum',
                params: { allowedValues: schema47.allOf[1].properties.method.enum },
                message: 'must be equal to one of the allowed values',
                schema: schema47.allOf[1].properties.method.enum,
                parentSchema: schema47.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
        }
      } else {
        validate62.errors = [
          {
            instancePath,
            schemaPath: '#/allOf/1/type',
            keyword: 'type',
            params: { type: 'object' },
            message: 'must be object',
            schema: schema47.allOf[1].type,
            parentSchema: schema47.allOf[1],
            data,
          },
        ];
        return false;
      }
    }
    var valid0 = _errs6 === errors;
  }
  validate62.errors = vErrors;
  return errors === 0;
}
exports.validateLoginBodyResponse = validate63;
const schema48 = {
  allOf: [
    {
      title: 'Credentials',
      type: 'object',
      properties: {
        username: { description: 'Username of the user.', type: 'string' },
        password: { description: 'Password of the user.', type: 'string' },
      },
      required: ['username', 'password'],
    },
    {
      type: 'object',
      properties: {
        method: {
          title: 'AuthMethod',
          type: 'string',
          description: 'Authentication method.',
          enum: ['tui', 'local'],
        },
      },
    },
  ],
  'x-standalone': false,
  'x-name': 'loginBodyResponse',
  'x-location':
    '#/paths//login/post/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate63(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  if (errors === _errs0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate63.errors = [
          {
            instancePath,
            schemaPath: '#/allOf/0/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema48.allOf[0].required,
            parentSchema: schema48.allOf[0],
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs2 = errors;
          if (typeof data0 !== 'string') {
            validate63.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/allOf/0/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema48.allOf[0].properties.username.type,
                parentSchema: schema48.allOf[0].properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid1 = _errs2 === errors;
        } else {
          var valid1 = true;
        }
        if (valid1) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs4 = errors;
            if (typeof data1 !== 'string') {
              validate63.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/allOf/0/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema48.allOf[0].properties.password.type,
                  parentSchema: schema48.allOf[0].properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid1 = _errs4 === errors;
          } else {
            var valid1 = true;
          }
        }
      }
    } else {
      validate63.errors = [
        {
          instancePath,
          schemaPath: '#/allOf/0/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema48.allOf[0].type,
          parentSchema: schema48.allOf[0],
          data,
        },
      ];
      return false;
    }
  }
  var valid0 = _errs0 === errors;
  if (valid0) {
    const _errs6 = errors;
    if (errors === _errs6) {
      if (data && typeof data == 'object' && !Array.isArray(data)) {
        if (data.method !== undefined) {
          let data2 = data.method;
          if (typeof data2 !== 'string') {
            validate63.errors = [
              {
                instancePath: instancePath + '/method',
                schemaPath: '#/allOf/1/properties/method/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema48.allOf[1].properties.method.type,
                parentSchema: schema48.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
          if (!(data2 === 'tui' || data2 === 'local')) {
            validate63.errors = [
              {
                instancePath: instancePath + '/method',
                schemaPath: '#/allOf/1/properties/method/enum',
                keyword: 'enum',
                params: { allowedValues: schema48.allOf[1].properties.method.enum },
                message: 'must be equal to one of the allowed values',
                schema: schema48.allOf[1].properties.method.enum,
                parentSchema: schema48.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
        }
      } else {
        validate63.errors = [
          {
            instancePath,
            schemaPath: '#/allOf/1/type',
            keyword: 'type',
            params: { type: 'object' },
            message: 'must be object',
            schema: schema48.allOf[1].type,
            parentSchema: schema48.allOf[1],
            data,
          },
        ];
        return false;
      }
    }
    var valid0 = _errs6 === errors;
  }
  validate63.errors = vErrors;
  return errors === 0;
}
exports.validateLoginResponse201Request = validate64;
const schema49 = {
  description: 'The access token.',
  type: 'string',
  'x-standalone': false,
  'x-name': 'loginResponse201Request',
  'x-location':
    '#/paths//login/post/responses/201/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate64(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate64.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema49.type,
        parentSchema: schema49,
        data,
      },
    ];
    return false;
  }
  validate64.errors = vErrors;
  return errors === 0;
}
exports.validateLoginResponse201Response = validate65;
const schema50 = {
  description: 'The access token.',
  type: 'string',
  'x-standalone': false,
  'x-name': 'loginResponse201Response',
  'x-location':
    '#/paths//login/post/responses/201/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate65(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate65.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema50.type,
        parentSchema: schema50,
        data,
      },
    ];
    return false;
  }
  validate65.errors = vErrors;
  return errors === 0;
}
exports.validateLogoutBodyRequest = validate66;
const schema51 = {
  type: 'object',
  properties: { token: { type: 'string', description: 'The token to be invalidated.' } },
  'x-standalone': false,
  'x-name': 'logoutBodyRequest',
  'x-location':
    '#/paths//logout/post/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate66(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.token !== undefined) {
        let data0 = data.token;
        if (typeof data0 !== 'string') {
          validate66.errors = [
            {
              instancePath: instancePath + '/token',
              schemaPath: '#/properties/token/type',
              keyword: 'type',
              params: { type: 'string' },
              message: 'must be string',
              schema: schema51.properties.token.type,
              parentSchema: schema51.properties.token,
              data: data0,
            },
          ];
          return false;
        }
      }
    } else {
      validate66.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema51.type,
          parentSchema: schema51,
          data,
        },
      ];
      return false;
    }
  }
  validate66.errors = vErrors;
  return errors === 0;
}
exports.validateLogoutBodyResponse = validate67;
const schema52 = {
  type: 'object',
  properties: { token: { type: 'string', description: 'The token to be invalidated.' } },
  'x-standalone': false,
  'x-name': 'logoutBodyResponse',
  'x-location':
    '#/paths//logout/post/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate67(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.token !== undefined) {
        let data0 = data.token;
        if (typeof data0 !== 'string') {
          validate67.errors = [
            {
              instancePath: instancePath + '/token',
              schemaPath: '#/properties/token/type',
              keyword: 'type',
              params: { type: 'string' },
              message: 'must be string',
              schema: schema52.properties.token.type,
              parentSchema: schema52.properties.token,
              data: data0,
            },
          ];
          return false;
        }
      }
    } else {
      validate67.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema52.type,
          parentSchema: schema52,
          data,
        },
      ];
      return false;
    }
  }
  validate67.errors = vErrors;
  return errors === 0;
}
exports.validateListUsersResponse200Request = validate68;
const schema53 = {
  type: 'array',
  items: {
    title: 'User',
    type: 'object',
    properties: {
      username: { type: 'string' },
      password: { type: 'string', writeOnly: true },
    },
    required: ['username', 'password'],
  },
  'x-standalone': false,
  'x-name': 'listUsersResponse200Request',
  'x-location':
    '#/paths//users/get/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate68(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.username === undefined && (missing0 = 'username')) ||
              (data0.password === undefined && (missing0 = 'password'))
            ) {
              validate68.errors = [
                {
                  instancePath: instancePath + '/' + i0,
                  schemaPath: '#/items/required',
                  keyword: 'required',
                  params: { missingProperty: missing0 },
                  message: "must have required property '" + missing0 + "'",
                  schema: schema53.items.required,
                  parentSchema: schema53.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.username !== undefined) {
                let data1 = data0.username;
                const _errs3 = errors;
                if (typeof data1 !== 'string') {
                  validate68.errors = [
                    {
                      instancePath: instancePath + '/' + i0 + '/username',
                      schemaPath: '#/items/properties/username/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema53.items.properties.username.type,
                      parentSchema: schema53.items.properties.username,
                      data: data1,
                    },
                  ];
                  return false;
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.password !== undefined) {
                  let data2 = data0.password;
                  const _errs5 = errors;
                  if (typeof data2 !== 'string') {
                    validate68.errors = [
                      {
                        instancePath: instancePath + '/' + i0 + '/password',
                        schemaPath: '#/items/properties/password/type',
                        keyword: 'type',
                        params: { type: 'string' },
                        message: 'must be string',
                        schema: schema53.items.properties.password.type,
                        parentSchema: schema53.items.properties.password,
                        data: data2,
                      },
                    ];
                    return false;
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
              }
            }
          } else {
            validate68.errors = [
              {
                instancePath: instancePath + '/' + i0,
                schemaPath: '#/items/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema53.items.type,
                parentSchema: schema53.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate68.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
          schema: schema53.type,
          parentSchema: schema53,
          data,
        },
      ];
      return false;
    }
  }
  validate68.errors = vErrors;
  return errors === 0;
}
exports.validateListUsersResponse200Response = validate69;
const schema54 = {
  type: 'array',
  items: {
    title: 'User',
    type: 'object',
    properties: {
      url: { type: 'string', format: 'uri', readOnly: true },
      id: { type: 'string', readOnly: true },
      username: { type: 'string' },
    },
    required: ['url', 'id', 'username'],
  },
  'x-standalone': false,
  'x-name': 'listUsersResponse200Response',
  'x-location':
    '#/paths//users/get/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate69(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.url === undefined && (missing0 = 'url')) ||
              (data0.id === undefined && (missing0 = 'id')) ||
              (data0.username === undefined && (missing0 = 'username'))
            ) {
              validate69.errors = [
                {
                  instancePath: instancePath + '/' + i0,
                  schemaPath: '#/items/required',
                  keyword: 'required',
                  params: { missingProperty: missing0 },
                  message: "must have required property '" + missing0 + "'",
                  schema: schema54.items.required,
                  parentSchema: schema54.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.url !== undefined) {
                let data1 = data0.url;
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (errors === _errs3) {
                    if (typeof data1 === 'string') {
                      if (!formats0(data1)) {
                        validate69.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/url',
                            schemaPath: '#/items/properties/url/format',
                            keyword: 'format',
                            params: { format: 'uri' },
                            message: 'must match format "' + 'uri' + '"',
                            schema: 'uri',
                            parentSchema: schema54.items.properties.url,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    } else {
                      validate69.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/url',
                          schemaPath: '#/items/properties/url/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema54.items.properties.url.type,
                          parentSchema: schema54.items.properties.url,
                          data: data1,
                        },
                      ];
                      return false;
                    }
                  }
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.id !== undefined) {
                  let data2 = data0.id;
                  const _errs5 = errors;
                  if (typeof data2 !== 'string') {
                    validate69.errors = [
                      {
                        instancePath: instancePath + '/' + i0 + '/id',
                        schemaPath: '#/items/properties/id/type',
                        keyword: 'type',
                        params: { type: 'string' },
                        message: 'must be string',
                        schema: schema54.items.properties.id.type,
                        parentSchema: schema54.items.properties.id,
                        data: data2,
                      },
                    ];
                    return false;
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.username !== undefined) {
                    let data3 = data0.username;
                    const _errs7 = errors;
                    if (typeof data3 !== 'string') {
                      validate69.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/username',
                          schemaPath: '#/items/properties/username/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema54.items.properties.username.type,
                          parentSchema: schema54.items.properties.username,
                          data: data3,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs7 === errors;
                  } else {
                    var valid1 = true;
                  }
                }
              }
            }
          } else {
            validate69.errors = [
              {
                instancePath: instancePath + '/' + i0,
                schemaPath: '#/items/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema54.items.type,
                parentSchema: schema54.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate69.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
          schema: schema54.type,
          parentSchema: schema54,
          data,
        },
      ];
      return false;
    }
  }
  validate69.errors = vErrors;
  return errors === 0;
}
exports.validateCreateUserBodyRequest = validate70;
const schema55 = {
  title: 'User',
  type: 'object',
  properties: {
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['username', 'password'],
  'x-standalone': false,
  'x-name': 'createUserBodyRequest',
  'x-location': '#/paths//users/post/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate70(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate70.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema55.required,
            parentSchema: schema55,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate70.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema55.properties.username.type,
                parentSchema: schema55.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate70.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema55.properties.password.type,
                  parentSchema: schema55.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate70.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema55.type,
          parentSchema: schema55,
          data,
        },
      ];
      return false;
    }
  }
  validate70.errors = vErrors;
  return errors === 0;
}
exports.validateCreateUserBodyResponse = validate71;
const schema56 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
  },
  required: ['url', 'id', 'username'],
  'x-standalone': false,
  'x-name': 'createUserBodyResponse',
  'x-location':
    '#/paths//users/post/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate71(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username'))
      ) {
        validate71.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema56.required,
            parentSchema: schema56,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate71.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema56.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate71.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema56.properties.url.type,
                    parentSchema: schema56.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate71.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema56.properties.id.type,
                  parentSchema: schema56.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate71.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema56.properties.username.type,
                    parentSchema: schema56.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate71.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema56.type,
          parentSchema: schema56,
          data,
        },
      ];
      return false;
    }
  }
  validate71.errors = vErrors;
  return errors === 0;
}
exports.validateCreateUserResponse201Request = validate72;
const schema57 = {
  title: 'User',
  type: 'object',
  properties: {
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['username', 'password'],
  'x-standalone': false,
  'x-name': 'createUserResponse201Request',
  'x-location':
    '#/paths//users/post/responses/201/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate72(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate72.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema57.required,
            parentSchema: schema57,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate72.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema57.properties.username.type,
                parentSchema: schema57.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate72.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema57.properties.password.type,
                  parentSchema: schema57.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate72.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema57.type,
          parentSchema: schema57,
          data,
        },
      ];
      return false;
    }
  }
  validate72.errors = vErrors;
  return errors === 0;
}
exports.validateCreateUserResponse201Response = validate73;
const schema58 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
  },
  required: ['url', 'id', 'username'],
  'x-standalone': false,
  'x-name': 'createUserResponse201Response',
  'x-location':
    '#/paths//users/post/responses/201/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate73(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username'))
      ) {
        validate73.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema58.required,
            parentSchema: schema58,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate73.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema58.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate73.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema58.properties.url.type,
                    parentSchema: schema58.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate73.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema58.properties.id.type,
                  parentSchema: schema58.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate73.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema58.properties.username.type,
                    parentSchema: schema58.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate73.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema58.type,
          parentSchema: schema58,
          data,
        },
      ];
      return false;
    }
  }
  validate73.errors = vErrors;
  return errors === 0;
}
exports.validateGetUserResponse200Request = validate74;
const schema59 = {
  title: 'User',
  type: 'object',
  properties: {
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['username', 'password'],
  'x-standalone': false,
  'x-name': 'getUserResponse200Request',
  'x-location':
    '#/paths//users/{user_id}/get/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate74(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate74.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema59.required,
            parentSchema: schema59,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate74.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema59.properties.username.type,
                parentSchema: schema59.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate74.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema59.properties.password.type,
                  parentSchema: schema59.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate74.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema59.type,
          parentSchema: schema59,
          data,
        },
      ];
      return false;
    }
  }
  validate74.errors = vErrors;
  return errors === 0;
}
exports.validateGetUserResponse200Response = validate75;
const schema60 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
  },
  required: ['url', 'id', 'username'],
  'x-standalone': false,
  'x-name': 'getUserResponse200Response',
  'x-location':
    '#/paths//users/{user_id}/get/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate75(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username'))
      ) {
        validate75.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema60.required,
            parentSchema: schema60,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate75.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema60.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate75.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema60.properties.url.type,
                    parentSchema: schema60.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate75.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema60.properties.id.type,
                  parentSchema: schema60.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate75.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema60.properties.username.type,
                    parentSchema: schema60.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate75.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema60.type,
          parentSchema: schema60,
          data,
        },
      ];
      return false;
    }
  }
  validate75.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateUserBodyRequest = validate76;
const schema61 = {
  title: 'User Update',
  type: 'object',
  properties: { password: { type: 'string', writeOnly: true } },
  required: ['password'],
  'x-standalone': false,
  'x-name': 'updateUserBodyRequest',
  'x-location':
    '#/paths//users/{user_id}/patch/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate76(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = 'password')) {
        validate76.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema61.required,
            parentSchema: schema61,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== 'string') {
            validate76.errors = [
              {
                instancePath: instancePath + '/password',
                schemaPath: '#/properties/password/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema61.properties.password.type,
                parentSchema: schema61.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate76.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema61.type,
          parentSchema: schema61,
          data,
        },
      ];
      return false;
    }
  }
  validate76.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateUserBodyResponse = validate77;
const schema62 = {
  title: 'User Update',
  type: 'object',
  properties: {},
  required: [],
  'x-standalone': false,
  'x-name': 'updateUserBodyResponse',
  'x-location':
    '#/paths//users/{user_id}/patch/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate77(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (!(data && typeof data == 'object' && !Array.isArray(data))) {
      validate77.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema62.type,
          parentSchema: schema62,
          data,
        },
      ];
      return false;
    }
  }
  validate77.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateUserResponse200Request = validate78;
const schema63 = {
  title: 'User',
  type: 'object',
  properties: {
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['username', 'password'],
  'x-standalone': false,
  'x-name': 'updateUserResponse200Request',
  'x-location':
    '#/paths//users/{user_id}/patch/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate78(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate78.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema63.required,
            parentSchema: schema63,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate78.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema63.properties.username.type,
                parentSchema: schema63.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate78.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema63.properties.password.type,
                  parentSchema: schema63.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate78.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema63.type,
          parentSchema: schema63,
          data,
        },
      ];
      return false;
    }
  }
  validate78.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateUserResponse200Response = validate79;
const schema64 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
  },
  required: ['url', 'id', 'username'],
  'x-standalone': false,
  'x-name': 'updateUserResponse200Response',
  'x-location':
    '#/paths//users/{user_id}/patch/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate79(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username'))
      ) {
        validate79.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema64.required,
            parentSchema: schema64,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate79.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema64.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate79.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema64.properties.url.type,
                    parentSchema: schema64.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate79.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema64.properties.id.type,
                  parentSchema: schema64.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate79.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema64.properties.username.type,
                    parentSchema: schema64.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate79.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema64.type,
          parentSchema: schema64,
          data,
        },
      ];
      return false;
    }
  }
  validate79.errors = vErrors;
  return errors === 0;
}
exports.validateGetIdentityResponse200Request = validate80;
const schema65 = {
  title: 'User',
  type: 'object',
  properties: {
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['username', 'password'],
  'x-standalone': false,
  'x-name': 'getIdentityResponse200Request',
  'x-location':
    '#/paths//identity/get/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate80(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate80.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema65.required,
            parentSchema: schema65,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate80.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema65.properties.username.type,
                parentSchema: schema65.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate80.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema65.properties.password.type,
                  parentSchema: schema65.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate80.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema65.type,
          parentSchema: schema65,
          data,
        },
      ];
      return false;
    }
  }
  validate80.errors = vErrors;
  return errors === 0;
}
exports.validateGetIdentityResponse200Response = validate81;
const schema66 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
  },
  required: ['url', 'id', 'username'],
  'x-standalone': false,
  'x-name': 'getIdentityResponse200Response',
  'x-location':
    '#/paths//identity/get/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate81(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username'))
      ) {
        validate81.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema66.required,
            parentSchema: schema66,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate81.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema66.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate81.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema66.properties.url.type,
                    parentSchema: schema66.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate81.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema66.properties.id.type,
                  parentSchema: schema66.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate81.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema66.properties.username.type,
                    parentSchema: schema66.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate81.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema66.type,
          parentSchema: schema66,
          data,
        },
      ];
      return false;
    }
  }
  validate81.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateIdentityBodyRequest = validate82;
const schema67 = {
  title: 'User Update',
  type: 'object',
  properties: { password: { type: 'string', writeOnly: true } },
  required: ['password'],
  'x-standalone': false,
  'x-name': 'updateIdentityBodyRequest',
  'x-location':
    '#/paths//identity/patch/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate82(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = 'password')) {
        validate82.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema67.required,
            parentSchema: schema67,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== 'string') {
            validate82.errors = [
              {
                instancePath: instancePath + '/password',
                schemaPath: '#/properties/password/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema67.properties.password.type,
                parentSchema: schema67.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate82.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema67.type,
          parentSchema: schema67,
          data,
        },
      ];
      return false;
    }
  }
  validate82.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateIdentityBodyResponse = validate83;
const schema68 = {
  title: 'User Update',
  type: 'object',
  properties: {},
  required: [],
  'x-standalone': false,
  'x-name': 'updateIdentityBodyResponse',
  'x-location':
    '#/paths//identity/patch/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate83(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (!(data && typeof data == 'object' && !Array.isArray(data))) {
      validate83.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema68.type,
          parentSchema: schema68,
          data,
        },
      ];
      return false;
    }
  }
  validate83.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateIdentityResponse200Request = validate84;
const schema69 = {
  title: 'User',
  type: 'object',
  properties: {
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['username', 'password'],
  'x-standalone': false,
  'x-name': 'updateIdentityResponse200Request',
  'x-location':
    '#/paths//identity/patch/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate84(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate84.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema69.required,
            parentSchema: schema69,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate84.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema69.properties.username.type,
                parentSchema: schema69.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate84.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema69.properties.password.type,
                  parentSchema: schema69.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate84.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema69.type,
          parentSchema: schema69,
          data,
        },
      ];
      return false;
    }
  }
  validate84.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateIdentityResponse200Response = validate85;
const schema70 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
  },
  required: ['url', 'id', 'username'],
  'x-standalone': false,
  'x-name': 'updateIdentityResponse200Response',
  'x-location':
    '#/paths//identity/patch/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate85(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username'))
      ) {
        validate85.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema70.required,
            parentSchema: schema70,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate85.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema70.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate85.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema70.properties.url.type,
                    parentSchema: schema70.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate85.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema70.properties.id.type,
                  parentSchema: schema70.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate85.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema70.properties.username.type,
                    parentSchema: schema70.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate85.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema70.type,
          parentSchema: schema70,
          data,
        },
      ];
      return false;
    }
  }
  validate85.errors = vErrors;
  return errors === 0;
}
exports.validateCreateTokenBodyRequest = validate86;
const schema71 = {
  type: 'object',
  properties: {
    username: { type: 'string', description: 'The username of the user.' },
    claims: {
      type: 'object',
      description:
        'The claims that will be added to the token. If left empty, the token will have the full scope of the user.\n',
    },
  },
  'x-standalone': false,
  'x-name': 'createTokenBodyRequest',
  'x-location': '#/paths//token/post/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate86(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.username !== undefined) {
        let data0 = data.username;
        const _errs1 = errors;
        if (typeof data0 !== 'string') {
          validate86.errors = [
            {
              instancePath: instancePath + '/username',
              schemaPath: '#/properties/username/type',
              keyword: 'type',
              params: { type: 'string' },
              message: 'must be string',
              schema: schema71.properties.username.type,
              parentSchema: schema71.properties.username,
              data: data0,
            },
          ];
          return false;
        }
        var valid0 = _errs1 === errors;
      } else {
        var valid0 = true;
      }
      if (valid0) {
        if (data.claims !== undefined) {
          let data1 = data.claims;
          const _errs3 = errors;
          if (!(data1 && typeof data1 == 'object' && !Array.isArray(data1))) {
            validate86.errors = [
              {
                instancePath: instancePath + '/claims',
                schemaPath: '#/properties/claims/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema71.properties.claims.type,
                parentSchema: schema71.properties.claims,
                data: data1,
              },
            ];
            return false;
          }
          var valid0 = _errs3 === errors;
        } else {
          var valid0 = true;
        }
      }
    } else {
      validate86.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema71.type,
          parentSchema: schema71,
          data,
        },
      ];
      return false;
    }
  }
  validate86.errors = vErrors;
  return errors === 0;
}
exports.validateCreateTokenBodyResponse = validate87;
const schema72 = {
  type: 'object',
  properties: {
    username: { type: 'string', description: 'The username of the user.' },
    claims: {
      type: 'object',
      description:
        'The claims that will be added to the token. If left empty, the token will have the full scope of the user.\n',
    },
  },
  'x-standalone': false,
  'x-name': 'createTokenBodyResponse',
  'x-location':
    '#/paths//token/post/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate87(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.username !== undefined) {
        let data0 = data.username;
        const _errs1 = errors;
        if (typeof data0 !== 'string') {
          validate87.errors = [
            {
              instancePath: instancePath + '/username',
              schemaPath: '#/properties/username/type',
              keyword: 'type',
              params: { type: 'string' },
              message: 'must be string',
              schema: schema72.properties.username.type,
              parentSchema: schema72.properties.username,
              data: data0,
            },
          ];
          return false;
        }
        var valid0 = _errs1 === errors;
      } else {
        var valid0 = true;
      }
      if (valid0) {
        if (data.claims !== undefined) {
          let data1 = data.claims;
          const _errs3 = errors;
          if (!(data1 && typeof data1 == 'object' && !Array.isArray(data1))) {
            validate87.errors = [
              {
                instancePath: instancePath + '/claims',
                schemaPath: '#/properties/claims/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema72.properties.claims.type,
                parentSchema: schema72.properties.claims,
                data: data1,
              },
            ];
            return false;
          }
          var valid0 = _errs3 === errors;
        } else {
          var valid0 = true;
        }
      }
    } else {
      validate87.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema72.type,
          parentSchema: schema72,
          data,
        },
      ];
      return false;
    }
  }
  validate87.errors = vErrors;
  return errors === 0;
}
exports.validateCreateTokenResponse201Request = validate88;
const schema73 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'createTokenResponse201Request',
  'x-location':
    '#/paths//token/post/responses/201/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate88(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate88.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema73.type,
        parentSchema: schema73,
        data,
      },
    ];
    return false;
  }
  validate88.errors = vErrors;
  return errors === 0;
}
exports.validateCreateTokenResponse201Response = validate89;
const schema74 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'createTokenResponse201Response',
  'x-location':
    '#/paths//token/post/responses/201/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate89(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate89.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema74.type,
        parentSchema: schema74,
        data,
      },
    ];
    return false;
  }
  validate89.errors = vErrors;
  return errors === 0;
}
