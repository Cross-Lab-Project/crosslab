/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */

/* eslint-disable @typescript-eslint/no-unused-vars */

/* eslint-disable @typescript-eslint/ban-ts-comment */
import fetch, { RequestInfo, RequestInit, Response } from 'node-fetch';

import * as RequestValidation from './requestValidation.js';
import * as Signatures from './signatures.js';
import * as Types from './types.js';
// @ts-ignore
import { type Require } from './types.js';

/**
 * This error class should be used if an error occurs during validation of a request/response.
 * @category Errors
 */
export class ValidationError extends Error {
  public errors: unknown;

  constructor(message: string, errors: unknown) {
    super(message);
    this.name = 'ValidationError';
    this.errors = errors;
  }
}

/**
 * This error class should be used if an error occurs while fetching a request.
 * @category Errors
 */
export class FetchError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'FetchError';
  }
}

/**
 * This error class should be used if the response of the server has a status
 * greater than or equal to 400. This error should contain the validated response.
 * @category Errors
 */
export class UnsuccessfulRequestError extends Error {
  public response: Types.ResponseData;

  constructor(message: string, response: Types.ResponseData) {
    super(message);
    this.response = response;
    this.name = 'UnsuccessfulRequestError';
  }
}

/**
 * This error class should be used if the validation of an url fails.
 * @category Errors
 */
export class InvalidUrlError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InvalidUrlError';
  }
}

/**
 * This function attempts to parse a Response as ResponseData.
 */
async function parseResponse(response: Response): Promise<Types.ResponseData> {
  let text = null;
  try {
    text = await response.text();
    const json = JSON.parse(text);
    return { status: response.status, body: json };
  } catch {
    return { status: response.status, body: text };
  }
}

/**
 * This function checks if a string is a valid http url.
 * @param string The string to be checked.
 * @returns True if the string is a valid http url.
 */
function isValidHttpUrl(string: string) {
  let url;

  try {
    url = new URL(string);
  } catch (_) {
    return false;
  }

  return url.protocol === 'http:' || url.protocol === 'https:';
}

/**
 * This function takes an url and a pattern for the requested endpoint and parses the contained path parameters.
 * @param url The url to be parsed.
 * @param endpoint Pattern of the requested endpoint.
 * @throws {InvalidUrlError} Thrown if the provided url does not end with the provided endpoint.
 * @returns An array containing all parsed path parameters in order of appearance.
 * @example
 * // returns ["username", "role_name"]
 * parsePathParameters("https://api.example.com/users/username/roles/role_name", "/users/{}/roles/{}")
 */
function parsePathParameters(url: string, endpoint: string): string[] {
  const parameterRegex = '([a-zA-Z0-9-:]+)';
  const regex = new RegExp(endpoint.replaceAll('{}', parameterRegex) + '(?:.(?!\\\\))?$');
  const matches = url.match(regex);

  if (!matches) throw new InvalidUrlError('Url does not end with the provided endpoint');

  return matches.slice(1);
}

/**
 * This function validates a given http url and parses its path parameters.
 * @param url The url to be validated.
 * @param endpoint Pattern of the requested endpoint.
 * @throws {InvalidUrlError} Thrown if the validation of the provided url fails.
 * @returns An array containing all parsed path parameters in order of appearance (see {@link parsePathParameters}).
 * @example
 * // returns ["username", "role_name"]
 * validateUrl("https://api.example.com/users/username/roles/role_name", "/users/{}/roles/{}")
 */
function validateUrl(url: string, baseUrl: string, endpoint: string): string[] {
  if (!isValidHttpUrl(url))
    throw new InvalidUrlError('Provided url is not a valid http url');
  if (!url.startsWith(baseUrl))
    throw new InvalidUrlError('Provided url does not start with the provided base url');
  const pathParameters = parsePathParameters(url, endpoint);

  let extendedBaseUrl = baseUrl + endpoint;

  pathParameters.forEach(pathParameter => {
    extendedBaseUrl = extendedBaseUrl.replace('{}', pathParameter);
  });

  if (url !== extendedBaseUrl)
    throw new InvalidUrlError('Provided url does not match extended base url');

  return pathParameters;
}

/**
 * This function appends a given endpoint to an url.
 * @param url The url to append the endpoint to.
 * @param endpoint The endpoint to be appended.
 * @example
 * // returns "https://api.example.com/devices/device_id/token"
 * appendToUrl("https://api.example.com/devices/device_id", "/token")
 * @example
 * // returns "https://api.example.com/devices/device_id/token"
 * appendToUrl("https://api.example.com/devices/device_id/", "/token")
 * @returns The url with the appended endpoint.
 */
function appendToUrl(url: string, endpoint: string) {
  return url.endsWith('/') ? `${url.slice(0, -1)}${endpoint}` : `${url}${endpoint}`;
}

/**
 * Client for the use of the Crosslab API
 * @category Client
 */
export class Client {
  public readonly baseUrl: string;
  public readonly serviceUrl: string;
  public accessToken: string;
  private fixedHeaders: [string, string][];
  private fetch = async (url: RequestInfo | URL, init: RequestInit) => {
    let raw_response;
    try {
      if (
        url.toString().startsWith(this.baseUrl) ||
        url.toString().startsWith(this.serviceUrl)
      ) {
        raw_response = await fetch(url, init);
      } else {
        raw_response = await fetch(
          appendToUrl(
            this.baseUrl,
            '/proxy?' + new URLSearchParams([['URL', url.toString()]]).toString(),
          ),
          init,
        );
      }
    } catch (error) {
      if (error instanceof Error) {
        throw new FetchError(error.message);
      } else if (typeof error === 'string') {
        throw new FetchError(error);
      } else {
        throw new FetchError('Something went wrong while trying to fetch the request');
      }
    }
    return await parseResponse(raw_response);
  };

  /**
   * @category Constructors
   */
  constructor(
    baseUrl: string,
    options: {
      serviceUrl?: string;
      accessToken?: string;
      fixedHeaders?: [string, string][];
    },
  ) {
    this.baseUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
    this.serviceUrl = options.serviceUrl
      ? options.serviceUrl.endsWith('/')
        ? options.serviceUrl.slice(0, -1)
        : options.serviceUrl
      : this.baseUrl;
    this.accessToken = options.accessToken ?? '';
    this.fixedHeaders = options.fixedHeaders ?? [];
  }

  /**
   * Locks the current booking so the devices can be used.  This sets the status to "active" This means that the booking can not be cancelled or (currently not implemented) the end time can not be set to a prior time. If called multiple times, the booking will be locked only once.
   *
   * @param url
   * Url of the resource to be accessed.
   *
   * @throws {@link FetchError | FetchError }
   * Thrown if fetch fails.
   * @throws {@link ValidationError | ValidationError }
   * Thrown if the request/response validation fails.
   * @throws {@link InvalidUrlError | InvalidUrlError }
   * Thrown if the provided url is not valid for this request.
   * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError }
   * Thrown if response is validated but has status greater than or equal to 400.
   *
   * @returns
   * All devices were booked by user.
   */
  public async lockBooking(
    url: string,
    options?: {
      headers?: [string, string][];
    },
  ): Promise<Signatures.LockBookingSuccessResponse['body']> {
    const urlSuffix = '/booking/{}/lock'.split('{}').at(-1) ?? '';
    if (urlSuffix && !url.endsWith(urlSuffix)) url = appendToUrl(url, urlSuffix);
    const [ID] = validateUrl(url, this.baseUrl, '/booking/{}/lock');

    const parameters = {
      ID: ID,
    };

    if (!RequestValidation.validateLockBookingInput(parameters))
      throw new ValidationError(
        'Request validation failed!',
        (RequestValidation.validateLockBookingInput as Types.FunctionWithErrors).errors,
      );

    const authorization: string = `Bearer ${this.accessToken}`;

    const response = await this.fetch(url.replace(this.baseUrl, this.serviceUrl), {
      method: 'PUT',
      headers: [
        ['Content-Type', 'application/json'],
        ['Authorization', authorization],
        ...this.fixedHeaders,
        ...(options?.headers ?? []),
      ],
    });

    if (!RequestValidation.validateLockBookingOutput(response))
      throw new ValidationError(
        'Response validation failed!',
        (RequestValidation.validateLockBookingOutput as Types.FunctionWithErrors).errors,
      );

    if (Types.isErrorResponse(response))
      throw new UnsuccessfulRequestError(
        `Server returned response with status ${response.status}`,
        response,
      );

    return response.body;
  }

  /**
   * Unlocks all devices belonging to a booking, status will be set to 'booked'.
   *
   * @param url
   * Url of the resource to be accessed.
   *
   * @throws {@link FetchError | FetchError }
   * Thrown if fetch fails.
   * @throws {@link ValidationError | ValidationError }
   * Thrown if the request/response validation fails.
   * @throws {@link InvalidUrlError | InvalidUrlError }
   * Thrown if the provided url is not valid for this request.
   * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError }
   * Thrown if response is validated but has status greater than or equal to 400.
   *
   * @returns
   * Unlocking was successful.
   */
  public async unlockBooking(
    url: string,
    options?: {
      headers?: [string, string][];
    },
  ): Promise<void> {
    const urlSuffix = '/booking/{}/lock'.split('{}').at(-1) ?? '';
    if (urlSuffix && !url.endsWith(urlSuffix)) url = appendToUrl(url, urlSuffix);
    const [ID] = validateUrl(url, this.baseUrl, '/booking/{}/lock');

    const parameters = {
      ID: ID,
    };

    if (!RequestValidation.validateUnlockBookingInput(parameters))
      throw new ValidationError(
        'Request validation failed!',
        (RequestValidation.validateUnlockBookingInput as Types.FunctionWithErrors).errors,
      );

    const authorization: string = `Bearer ${this.accessToken}`;

    const response = await this.fetch(url.replace(this.baseUrl, this.serviceUrl), {
      method: 'DELETE',
      headers: [
        ['Content-Type', 'application/json'],
        ['Authorization', authorization],
        ...this.fixedHeaders,
        ...(options?.headers ?? []),
      ],
    });

    if (!RequestValidation.validateUnlockBookingOutput(response))
      throw new ValidationError(
        'Response validation failed!',
        (
          RequestValidation.validateUnlockBookingOutput as Types.FunctionWithErrors
        ).errors,
      );

    if (Types.isErrorResponse(response))
      throw new UnsuccessfulRequestError(
        `Server returned response with status ${response.status}`,
        response,
      );
  }

  /**
   * Callback used for updating device info / booking info.
   *
   * @param url
   * Url of the resource to be accessed.
   *
   * @throws {@link FetchError | FetchError }
   * Thrown if fetch fails.
   * @throws {@link ValidationError | ValidationError }
   * Thrown if the request/response validation fails.
   * @throws {@link InvalidUrlError | InvalidUrlError }
   * Thrown if the provided url is not valid for this request.
   * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError }
   * Thrown if response is validated but has status greater than or equal to 400.
   *
   * @returns
   * Update was processed.
   */
  public async bookingCallback(
    url: string,
    options?: {
      headers?: [string, string][];
    },
  ): Promise<void> {
    const urlSuffix = '/booking_callback/{}'.split('{}').at(-1) ?? '';
    if (urlSuffix && !url.endsWith(urlSuffix)) url = appendToUrl(url, urlSuffix);
    const [ID] = validateUrl(url, this.baseUrl, '/booking_callback/{}');

    const parameters = {
      ID: ID,
    };

    if (!RequestValidation.validateBookingCallbackInput(parameters))
      throw new ValidationError(
        'Request validation failed!',
        (
          RequestValidation.validateBookingCallbackInput as Types.FunctionWithErrors
        ).errors,
      );

    const authorization: string = `Bearer ${this.accessToken}`;

    const response = await this.fetch(url.replace(this.baseUrl, this.serviceUrl), {
      method: 'POST',
      headers: [
        ['Content-Type', 'application/json'],
        ['Authorization', authorization],
        ...this.fixedHeaders,
        ...(options?.headers ?? []),
      ],
    });

    if (!RequestValidation.validateBookingCallbackOutput(response))
      throw new ValidationError(
        'Response validation failed!',
        (
          RequestValidation.validateBookingCallbackOutput as Types.FunctionWithErrors
        ).errors,
      );

    if (Types.isErrorResponse(response))
      throw new UnsuccessfulRequestError(
        `Server returned response with status ${response.status}`,
        response,
      );
  }
}
