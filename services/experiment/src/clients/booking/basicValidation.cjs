/* eslint-disable */
//@ts-nocheck
/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */
'use strict';
exports.validateBooking = validate21;
const schema6 = {
  title: 'Booking',
  description: 'A booking in the booking system.',
  type: 'object',
  required: ['ID', 'Time', 'Devices', 'Status', 'You', 'External'],
  properties: {
    ID: { type: 'string', format: 'uri', description: 'Unique ID of the booking.' },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Devices: { type: 'array', items: { type: 'string', format: 'uri' } },
    Type: {
      description:
        "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
      type: 'string',
      enum: ['normal'],
    },
    Status: {
      description:
        "Current status of the booking. While the booking is pending, it can not be used. Will change automatically and can not be set by user. 'rejected' is set when the initial booking failed, 'cancelled' when the booking was deleted / cancelled after it was once active. The 'active-*' will be used when a device was added after the booking was locked.",
      type: 'string',
      enum: [
        'pending',
        'booked',
        'rejected',
        'cancelled',
        'active',
        'active-pending',
        'active-rejected',
      ],
    },
    You: { type: 'boolean', description: 'If true, this booking was done by you.' },
    External: {
      type: 'boolean',
      description: 'Shows whether the booking was done by an external institution.',
    },
    Message: {
      type: 'string',
      description:
        'User readable notes about the status of the booking (e.g. if devices are unknown).',
    },
  },
  'x-standalone': true,
  'x-name': 'Booking',
  'x-location': '#/components/schemas/Booking',
  'x-schema-type': 'all',
};
const formats0 = require('ajv-formats/dist/formats').fullFormats.uri;
const formats2 = require('ajv-formats/dist/formats').fullFormats['date-time'];
function validate21(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.ID === undefined && (missing0 = 'ID')) ||
        (data.Time === undefined && (missing0 = 'Time')) ||
        (data.Devices === undefined && (missing0 = 'Devices')) ||
        (data.Status === undefined && (missing0 = 'Status')) ||
        (data.You === undefined && (missing0 = 'You')) ||
        (data.External === undefined && (missing0 = 'External'))
      ) {
        validate21.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema6.required,
            parentSchema: schema6,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema6.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate21.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema6.properties.ID.type,
                    parentSchema: schema6.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data1 = data.Time;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                let missing1;
                if (
                  (data1.Start === undefined && (missing1 = 'Start')) ||
                  (data1.End === undefined && (missing1 = 'End'))
                ) {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing1 },
                      message: "must have required property '" + missing1 + "'",
                      schema: schema6.properties.Time.required,
                      parentSchema: schema6.properties.Time,
                      data: data1,
                    },
                  ];
                  return false;
                } else {
                  if (data1.Start !== undefined) {
                    let data2 = data1.Start;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (errors === _errs5) {
                        if (typeof data2 === 'string') {
                          if (!formats2.validate(data2)) {
                            validate21.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema6.properties.Time.properties.Start,
                                data: data2,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate21.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema6.properties.Time.properties.Start.type,
                              parentSchema: schema6.properties.Time.properties.Start,
                              data: data2,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data1.End !== undefined) {
                      let data3 = data1.End;
                      const _errs7 = errors;
                      if (errors === _errs7) {
                        if (errors === _errs7) {
                          if (typeof data3 === 'string') {
                            if (!formats2.validate(data3)) {
                              validate21.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema6.properties.Time.properties.End,
                                  data: data3,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate21.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema6.properties.Time.properties.End.type,
                                parentSchema: schema6.properties.Time.properties.End,
                                data: data3,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid1 = _errs7 === errors;
                    } else {
                      var valid1 = true;
                    }
                  }
                }
              } else {
                validate21.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema6.properties.Time.type,
                    parentSchema: schema6.properties.Time,
                    data: data1,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Devices !== undefined) {
              let data4 = data.Devices;
              const _errs9 = errors;
              if (errors === _errs9) {
                if (Array.isArray(data4)) {
                  var valid2 = true;
                  const len0 = data4.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data5 = data4[i0];
                    const _errs11 = errors;
                    if (errors === _errs11) {
                      if (errors === _errs11) {
                        if (typeof data5 === 'string') {
                          if (!formats0(data5)) {
                            validate21.errors = [
                              {
                                instancePath: instancePath + '/Devices/' + i0,
                                schemaPath: '#/properties/Devices/items/format',
                                keyword: 'format',
                                params: { format: 'uri' },
                                message: 'must match format "' + 'uri' + '"',
                                schema: 'uri',
                                parentSchema: schema6.properties.Devices.items,
                                data: data5,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate21.errors = [
                            {
                              instancePath: instancePath + '/Devices/' + i0,
                              schemaPath: '#/properties/Devices/items/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema6.properties.Devices.items.type,
                              parentSchema: schema6.properties.Devices.items,
                              data: data5,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid2 = _errs11 === errors;
                    if (!valid2) {
                      break;
                    }
                  }
                } else {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/Devices',
                      schemaPath: '#/properties/Devices/type',
                      keyword: 'type',
                      params: { type: 'array' },
                      message: 'must be array',
                      schema: schema6.properties.Devices.type,
                      parentSchema: schema6.properties.Devices,
                      data: data4,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs9 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.Type !== undefined) {
                let data6 = data.Type;
                const _errs13 = errors;
                if (typeof data6 !== 'string') {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema6.properties.Type.type,
                      parentSchema: schema6.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                if (!(data6 === 'normal')) {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/enum',
                      keyword: 'enum',
                      params: { allowedValues: schema6.properties.Type.enum },
                      message: 'must be equal to one of the allowed values',
                      schema: schema6.properties.Type.enum,
                      parentSchema: schema6.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs13 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.Status !== undefined) {
                  let data7 = data.Status;
                  const _errs15 = errors;
                  if (typeof data7 !== 'string') {
                    validate21.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/type',
                        keyword: 'type',
                        params: { type: 'string' },
                        message: 'must be string',
                        schema: schema6.properties.Status.type,
                        parentSchema: schema6.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  if (
                    !(
                      data7 === 'pending' ||
                      data7 === 'booked' ||
                      data7 === 'rejected' ||
                      data7 === 'cancelled' ||
                      data7 === 'active' ||
                      data7 === 'active-pending' ||
                      data7 === 'active-rejected'
                    )
                  ) {
                    validate21.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/enum',
                        keyword: 'enum',
                        params: { allowedValues: schema6.properties.Status.enum },
                        message: 'must be equal to one of the allowed values',
                        schema: schema6.properties.Status.enum,
                        parentSchema: schema6.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  var valid0 = _errs15 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.You !== undefined) {
                    let data8 = data.You;
                    const _errs17 = errors;
                    if (typeof data8 !== 'boolean') {
                      validate21.errors = [
                        {
                          instancePath: instancePath + '/You',
                          schemaPath: '#/properties/You/type',
                          keyword: 'type',
                          params: { type: 'boolean' },
                          message: 'must be boolean',
                          schema: schema6.properties.You.type,
                          parentSchema: schema6.properties.You,
                          data: data8,
                        },
                      ];
                      return false;
                    }
                    var valid0 = _errs17 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.External !== undefined) {
                      let data9 = data.External;
                      const _errs19 = errors;
                      if (typeof data9 !== 'boolean') {
                        validate21.errors = [
                          {
                            instancePath: instancePath + '/External',
                            schemaPath: '#/properties/External/type',
                            keyword: 'type',
                            params: { type: 'boolean' },
                            message: 'must be boolean',
                            schema: schema6.properties.External.type,
                            parentSchema: schema6.properties.External,
                            data: data9,
                          },
                        ];
                        return false;
                      }
                      var valid0 = _errs19 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.Message !== undefined) {
                        let data10 = data.Message;
                        const _errs21 = errors;
                        if (typeof data10 !== 'string') {
                          validate21.errors = [
                            {
                              instancePath: instancePath + '/Message',
                              schemaPath: '#/properties/Message/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema6.properties.Message.type,
                              parentSchema: schema6.properties.Message,
                              data: data10,
                            },
                          ];
                          return false;
                        }
                        var valid0 = _errs21 === errors;
                      } else {
                        var valid0 = true;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate21.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema6.type,
          parentSchema: schema6,
          data,
        },
      ];
      return false;
    }
  }
  validate21.errors = vErrors;
  return errors === 0;
}
exports.validateDevice = validate22;
const schema7 = {
  title: 'Device',
  description: 'A device might either be a physical/virtual device or a group of device.',
  type: 'object',
  required: ['ID'],
  properties: {
    ID: {
      type: 'string',
      description:
        'Unique ID of the device. Contains the institution (by having an end point at that institution)',
      format: 'uri',
    },
  },
  'x-standalone': true,
  'x-name': 'Device',
  'x-location': '#/components/schemas/Device',
  'x-schema-type': 'all',
};
function validate22(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.ID === undefined && (missing0 = 'ID')) {
        validate22.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema7.required,
            parentSchema: schema7,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate22.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema7.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate22.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema7.properties.ID.type,
                    parentSchema: schema7.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate22.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema7.type,
          parentSchema: schema7,
          data,
        },
      ];
      return false;
    }
  }
  validate22.errors = vErrors;
  return errors === 0;
}
exports.validateExperiment = validate23;
const schema8 = {
  title: 'Experiment',
  description:
    'An experiment describes a set of devices and how they should be connected (potentially among other metadata).',
  type: 'object',
  required: ['Devices'],
  properties: {
    Devices: {
      type: 'array',
      description: 'List of devices used in experiment.',
      items: {
        title: 'Device',
        description:
          'A device might either be a physical/virtual device or a group of device.',
        type: 'object',
        required: ['ID'],
        properties: {
          ID: {
            type: 'string',
            description:
              'Unique ID of the device. Contains the institution (by having an end point at that institution)',
            format: 'uri',
          },
        },
      },
    },
    Description: {
      type: 'string',
      description:
        'User provided description, for example might be a reason for the booking (e.g. maintenance) or a link to the experiment. Might be empty or missing.',
    },
  },
  'x-standalone': true,
  'x-name': 'Experiment',
  'x-location': '#/components/schemas/Experiment',
  'x-schema-type': 'all',
};
function validate23(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.Devices === undefined && (missing0 = 'Devices')) {
        validate23.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema8.required,
            parentSchema: schema8,
            data,
          },
        ];
        return false;
      } else {
        if (data.Devices !== undefined) {
          let data0 = data.Devices;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (Array.isArray(data0)) {
              var valid1 = true;
              const len0 = data0.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data1 = data0[i0];
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                    let missing1;
                    if (data1.ID === undefined && (missing1 = 'ID')) {
                      validate23.errors = [
                        {
                          instancePath: instancePath + '/Devices/' + i0,
                          schemaPath: '#/properties/Devices/items/required',
                          keyword: 'required',
                          params: { missingProperty: missing1 },
                          message: "must have required property '" + missing1 + "'",
                          schema: schema8.properties.Devices.items.required,
                          parentSchema: schema8.properties.Devices.items,
                          data: data1,
                        },
                      ];
                      return false;
                    } else {
                      if (data1.ID !== undefined) {
                        let data2 = data1.ID;
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (errors === _errs5) {
                            if (typeof data2 === 'string') {
                              if (!formats0(data2)) {
                                validate23.errors = [
                                  {
                                    instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                    schemaPath:
                                      '#/properties/Devices/items/properties/ID/format',
                                    keyword: 'format',
                                    params: { format: 'uri' },
                                    message: 'must match format "' + 'uri' + '"',
                                    schema: 'uri',
                                    parentSchema:
                                      schema8.properties.Devices.items.properties.ID,
                                    data: data2,
                                  },
                                ];
                                return false;
                              }
                            } else {
                              validate23.errors = [
                                {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/properties/Devices/items/properties/ID/type',
                                  keyword: 'type',
                                  params: { type: 'string' },
                                  message: 'must be string',
                                  schema:
                                    schema8.properties.Devices.items.properties.ID.type,
                                  parentSchema:
                                    schema8.properties.Devices.items.properties.ID,
                                  data: data2,
                                },
                              ];
                              return false;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate23.errors = [
                      {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/properties/Devices/items/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                        schema: schema8.properties.Devices.items.type,
                        parentSchema: schema8.properties.Devices.items,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                }
                var valid1 = _errs3 === errors;
                if (!valid1) {
                  break;
                }
              }
            } else {
              validate23.errors = [
                {
                  instancePath: instancePath + '/Devices',
                  schemaPath: '#/properties/Devices/type',
                  keyword: 'type',
                  params: { type: 'array' },
                  message: 'must be array',
                  schema: schema8.properties.Devices.type,
                  parentSchema: schema8.properties.Devices,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Description !== undefined) {
            let data3 = data.Description;
            const _errs7 = errors;
            if (typeof data3 !== 'string') {
              validate23.errors = [
                {
                  instancePath: instancePath + '/Description',
                  schemaPath: '#/properties/Description/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema8.properties.Description.type,
                  parentSchema: schema8.properties.Description,
                  data: data3,
                },
              ];
              return false;
            }
            var valid0 = _errs7 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate23.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema8.type,
          parentSchema: schema8,
          data,
        },
      ];
      return false;
    }
  }
  validate23.errors = vErrors;
  return errors === 0;
}
exports.validateTimeslot = validate24;
const schema9 = {
  title: 'Timeslot',
  description: 'A time slot represents a slice of time used for bookings.',
  type: 'object',
  required: ['Start', 'End'],
  properties: {
    Start: {
      type: 'string',
      description: 'Start time of the booking.',
      format: 'date-time',
    },
    End: { type: 'string', description: 'End time of the booking.', format: 'date-time' },
  },
  'x-standalone': true,
  'x-name': 'Timeslot',
  'x-location': '#/components/schemas/Timeslot',
  'x-schema-type': 'all',
};
function validate24(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Start === undefined && (missing0 = 'Start')) ||
        (data.End === undefined && (missing0 = 'End'))
      ) {
        validate24.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema9.required,
            parentSchema: schema9,
            data,
          },
        ];
        return false;
      } else {
        if (data.Start !== undefined) {
          let data0 = data.Start;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats2.validate(data0)) {
                  validate24.errors = [
                    {
                      instancePath: instancePath + '/Start',
                      schemaPath: '#/properties/Start/format',
                      keyword: 'format',
                      params: { format: 'date-time' },
                      message: 'must match format "' + 'date-time' + '"',
                      schema: 'date-time',
                      parentSchema: schema9.properties.Start,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate24.errors = [
                  {
                    instancePath: instancePath + '/Start',
                    schemaPath: '#/properties/Start/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema9.properties.Start.type,
                    parentSchema: schema9.properties.Start,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.End !== undefined) {
            let data1 = data.End;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (errors === _errs3) {
                if (typeof data1 === 'string') {
                  if (!formats2.validate(data1)) {
                    validate24.errors = [
                      {
                        instancePath: instancePath + '/End',
                        schemaPath: '#/properties/End/format',
                        keyword: 'format',
                        params: { format: 'date-time' },
                        message: 'must match format "' + 'date-time' + '"',
                        schema: 'date-time',
                        parentSchema: schema9.properties.End,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                } else {
                  validate24.errors = [
                    {
                      instancePath: instancePath + '/End',
                      schemaPath: '#/properties/End/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema9.properties.End.type,
                      parentSchema: schema9.properties.End,
                      data: data1,
                    },
                  ];
                  return false;
                }
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate24.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema9.type,
          parentSchema: schema9,
          data,
        },
      ];
      return false;
    }
  }
  validate24.errors = vErrors;
  return errors === 0;
}
exports.validateID = validate25;
const schema10 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'ID',
  'x-location': '#/components/parameters/ID/schema',
  'x-schema-type': 'all',
};
function validate25(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate25.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema10.type,
        parentSchema: schema10,
        data,
      },
    ];
    return false;
  }
  validate25.errors = vErrors;
  return errors === 0;
}
exports.validateScheduleBody = validate26;
const schema11 = {
  type: 'object',
  required: ['Experiment', 'Time'],
  properties: {
    Experiment: {
      title: 'Experiment',
      description:
        'An experiment describes a set of devices and how they should be connected (potentially among other metadata).',
      type: 'object',
      required: ['Devices'],
      properties: {
        Devices: {
          type: 'array',
          description: 'List of devices used in experiment.',
          items: {
            title: 'Device',
            description:
              'A device might either be a physical/virtual device or a group of device.',
            type: 'object',
            required: ['ID'],
            properties: {
              ID: {
                type: 'string',
                description:
                  'Unique ID of the device. Contains the institution (by having an end point at that institution)',
                format: 'uri',
              },
            },
          },
        },
        Description: {
          type: 'string',
          description:
            'User provided description, for example might be a reason for the booking (e.g. maintenance) or a link to the experiment. Might be empty or missing.',
        },
      },
    },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Combined: {
      type: 'boolean',
      description:
        'If true, show only one timetable per device instead of one for all available physical devices.',
    },
    onlyOwn: {
      type: 'boolean',
      description:
        '(private) Show only devices of this institution. Give an error if a device of an other institution is requested.',
    },
  },
  'x-standalone': false,
  'x-name': 'scheduleBody',
  'x-location': '#/paths//schedule/post/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate26(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Experiment === undefined && (missing0 = 'Experiment')) ||
        (data.Time === undefined && (missing0 = 'Time'))
      ) {
        validate26.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema11.required,
            parentSchema: schema11,
            data,
          },
        ];
        return false;
      } else {
        if (data.Experiment !== undefined) {
          let data0 = data.Experiment;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
              let missing1;
              if (data0.Devices === undefined && (missing1 = 'Devices')) {
                validate26.errors = [
                  {
                    instancePath: instancePath + '/Experiment',
                    schemaPath: '#/properties/Experiment/required',
                    keyword: 'required',
                    params: { missingProperty: missing1 },
                    message: "must have required property '" + missing1 + "'",
                    schema: schema11.properties.Experiment.required,
                    parentSchema: schema11.properties.Experiment,
                    data: data0,
                  },
                ];
                return false;
              } else {
                if (data0.Devices !== undefined) {
                  let data1 = data0.Devices;
                  const _errs3 = errors;
                  if (errors === _errs3) {
                    if (Array.isArray(data1)) {
                      var valid2 = true;
                      const len0 = data1.length;
                      for (let i0 = 0; i0 < len0; i0++) {
                        let data2 = data1[i0];
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (
                            data2 &&
                            typeof data2 == 'object' &&
                            !Array.isArray(data2)
                          ) {
                            let missing2;
                            if (data2.ID === undefined && (missing2 = 'ID')) {
                              validate26.errors = [
                                {
                                  instancePath:
                                    instancePath + '/Experiment/Devices/' + i0,
                                  schemaPath:
                                    '#/properties/Experiment/properties/Devices/items/required',
                                  keyword: 'required',
                                  params: { missingProperty: missing2 },
                                  message:
                                    "must have required property '" + missing2 + "'",
                                  schema:
                                    schema11.properties.Experiment.properties.Devices
                                      .items.required,
                                  parentSchema:
                                    schema11.properties.Experiment.properties.Devices
                                      .items,
                                  data: data2,
                                },
                              ];
                              return false;
                            } else {
                              if (data2.ID !== undefined) {
                                let data3 = data2.ID;
                                const _errs7 = errors;
                                if (errors === _errs7) {
                                  if (errors === _errs7) {
                                    if (typeof data3 === 'string') {
                                      if (!formats0(data3)) {
                                        validate26.errors = [
                                          {
                                            instancePath:
                                              instancePath +
                                              '/Experiment/Devices/' +
                                              i0 +
                                              '/ID',
                                            schemaPath:
                                              '#/properties/Experiment/properties/Devices/items/properties/ID/format',
                                            keyword: 'format',
                                            params: { format: 'uri' },
                                            message: 'must match format "' + 'uri' + '"',
                                            schema: 'uri',
                                            parentSchema:
                                              schema11.properties.Experiment.properties
                                                .Devices.items.properties.ID,
                                            data: data3,
                                          },
                                        ];
                                        return false;
                                      }
                                    } else {
                                      validate26.errors = [
                                        {
                                          instancePath:
                                            instancePath +
                                            '/Experiment/Devices/' +
                                            i0 +
                                            '/ID',
                                          schemaPath:
                                            '#/properties/Experiment/properties/Devices/items/properties/ID/type',
                                          keyword: 'type',
                                          params: { type: 'string' },
                                          message: 'must be string',
                                          schema:
                                            schema11.properties.Experiment.properties
                                              .Devices.items.properties.ID.type,
                                          parentSchema:
                                            schema11.properties.Experiment.properties
                                              .Devices.items.properties.ID,
                                          data: data3,
                                        },
                                      ];
                                      return false;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            validate26.errors = [
                              {
                                instancePath: instancePath + '/Experiment/Devices/' + i0,
                                schemaPath:
                                  '#/properties/Experiment/properties/Devices/items/type',
                                keyword: 'type',
                                params: { type: 'object' },
                                message: 'must be object',
                                schema:
                                  schema11.properties.Experiment.properties.Devices.items
                                    .type,
                                parentSchema:
                                  schema11.properties.Experiment.properties.Devices.items,
                                data: data2,
                              },
                            ];
                            return false;
                          }
                        }
                        var valid2 = _errs5 === errors;
                        if (!valid2) {
                          break;
                        }
                      }
                    } else {
                      validate26.errors = [
                        {
                          instancePath: instancePath + '/Experiment/Devices',
                          schemaPath: '#/properties/Experiment/properties/Devices/type',
                          keyword: 'type',
                          params: { type: 'array' },
                          message: 'must be array',
                          schema: schema11.properties.Experiment.properties.Devices.type,
                          parentSchema: schema11.properties.Experiment.properties.Devices,
                          data: data1,
                        },
                      ];
                      return false;
                    }
                  }
                  var valid1 = _errs3 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.Description !== undefined) {
                    let data4 = data0.Description;
                    const _errs9 = errors;
                    if (typeof data4 !== 'string') {
                      validate26.errors = [
                        {
                          instancePath: instancePath + '/Experiment/Description',
                          schemaPath:
                            '#/properties/Experiment/properties/Description/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema:
                            schema11.properties.Experiment.properties.Description.type,
                          parentSchema:
                            schema11.properties.Experiment.properties.Description,
                          data: data4,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs9 === errors;
                  } else {
                    var valid1 = true;
                  }
                }
              }
            } else {
              validate26.errors = [
                {
                  instancePath: instancePath + '/Experiment',
                  schemaPath: '#/properties/Experiment/type',
                  keyword: 'type',
                  params: { type: 'object' },
                  message: 'must be object',
                  schema: schema11.properties.Experiment.type,
                  parentSchema: schema11.properties.Experiment,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data5 = data.Time;
            const _errs11 = errors;
            if (errors === _errs11) {
              if (data5 && typeof data5 == 'object' && !Array.isArray(data5)) {
                let missing3;
                if (
                  (data5.Start === undefined && (missing3 = 'Start')) ||
                  (data5.End === undefined && (missing3 = 'End'))
                ) {
                  validate26.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing3 },
                      message: "must have required property '" + missing3 + "'",
                      schema: schema11.properties.Time.required,
                      parentSchema: schema11.properties.Time,
                      data: data5,
                    },
                  ];
                  return false;
                } else {
                  if (data5.Start !== undefined) {
                    let data6 = data5.Start;
                    const _errs13 = errors;
                    if (errors === _errs13) {
                      if (errors === _errs13) {
                        if (typeof data6 === 'string') {
                          if (!formats2.validate(data6)) {
                            validate26.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema11.properties.Time.properties.Start,
                                data: data6,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate26.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema11.properties.Time.properties.Start.type,
                              parentSchema: schema11.properties.Time.properties.Start,
                              data: data6,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid4 = _errs13 === errors;
                  } else {
                    var valid4 = true;
                  }
                  if (valid4) {
                    if (data5.End !== undefined) {
                      let data7 = data5.End;
                      const _errs15 = errors;
                      if (errors === _errs15) {
                        if (errors === _errs15) {
                          if (typeof data7 === 'string') {
                            if (!formats2.validate(data7)) {
                              validate26.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema11.properties.Time.properties.End,
                                  data: data7,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate26.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema11.properties.Time.properties.End.type,
                                parentSchema: schema11.properties.Time.properties.End,
                                data: data7,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid4 = _errs15 === errors;
                    } else {
                      var valid4 = true;
                    }
                  }
                }
              } else {
                validate26.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema11.properties.Time.type,
                    parentSchema: schema11.properties.Time,
                    data: data5,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs11 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Combined !== undefined) {
              let data8 = data.Combined;
              const _errs17 = errors;
              if (typeof data8 !== 'boolean') {
                validate26.errors = [
                  {
                    instancePath: instancePath + '/Combined',
                    schemaPath: '#/properties/Combined/type',
                    keyword: 'type',
                    params: { type: 'boolean' },
                    message: 'must be boolean',
                    schema: schema11.properties.Combined.type,
                    parentSchema: schema11.properties.Combined,
                    data: data8,
                  },
                ];
                return false;
              }
              var valid0 = _errs17 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.onlyOwn !== undefined) {
                let data9 = data.onlyOwn;
                const _errs19 = errors;
                if (typeof data9 !== 'boolean') {
                  validate26.errors = [
                    {
                      instancePath: instancePath + '/onlyOwn',
                      schemaPath: '#/properties/onlyOwn/type',
                      keyword: 'type',
                      params: { type: 'boolean' },
                      message: 'must be boolean',
                      schema: schema11.properties.onlyOwn.type,
                      parentSchema: schema11.properties.onlyOwn,
                      data: data9,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs19 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate26.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema11.type,
          parentSchema: schema11,
          data,
        },
      ];
      return false;
    }
  }
  validate26.errors = vErrors;
  return errors === 0;
}
exports.validateScheduleResponse200 = validate27;
const schema12 = {
  type: 'array',
  items: {
    type: 'object',
    required: ['Device', 'Booked', 'Free'],
    properties: {
      Device: { type: 'string', description: 'ID of the device (or * if combined).' },
      Booked: {
        type: 'array',
        description: 'Array of booked times.',
        items: {
          title: 'Timeslot',
          description: 'A time slot represents a slice of time used for bookings.',
          type: 'object',
          required: ['Start', 'End'],
          properties: {
            Start: {
              type: 'string',
              description: 'Start time of the booking.',
              format: 'date-time',
            },
            End: {
              type: 'string',
              description: 'End time of the booking.',
              format: 'date-time',
            },
          },
        },
      },
      Free: {
        type: 'array',
        description: 'Array of free times.',
        items: {
          title: 'Timeslot',
          description: 'A time slot represents a slice of time used for bookings.',
          type: 'object',
          required: ['Start', 'End'],
          properties: {
            Start: {
              type: 'string',
              description: 'Start time of the booking.',
              format: 'date-time',
            },
            End: {
              type: 'string',
              description: 'End time of the booking.',
              format: 'date-time',
            },
          },
        },
      },
    },
  },
  'x-standalone': false,
  'x-name': 'scheduleResponse200',
  'x-location': '#/paths//schedule/post/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate27(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.Device === undefined && (missing0 = 'Device')) ||
              (data0.Booked === undefined && (missing0 = 'Booked')) ||
              (data0.Free === undefined && (missing0 = 'Free'))
            ) {
              validate27.errors = [
                {
                  instancePath: instancePath + '/' + i0,
                  schemaPath: '#/items/required',
                  keyword: 'required',
                  params: { missingProperty: missing0 },
                  message: "must have required property '" + missing0 + "'",
                  schema: schema12.items.required,
                  parentSchema: schema12.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.Device !== undefined) {
                let data1 = data0.Device;
                const _errs3 = errors;
                if (typeof data1 !== 'string') {
                  validate27.errors = [
                    {
                      instancePath: instancePath + '/' + i0 + '/Device',
                      schemaPath: '#/items/properties/Device/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema12.items.properties.Device.type,
                      parentSchema: schema12.items.properties.Device,
                      data: data1,
                    },
                  ];
                  return false;
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.Booked !== undefined) {
                  let data2 = data0.Booked;
                  const _errs5 = errors;
                  if (errors === _errs5) {
                    if (Array.isArray(data2)) {
                      var valid2 = true;
                      const len1 = data2.length;
                      for (let i1 = 0; i1 < len1; i1++) {
                        let data3 = data2[i1];
                        const _errs7 = errors;
                        if (errors === _errs7) {
                          if (
                            data3 &&
                            typeof data3 == 'object' &&
                            !Array.isArray(data3)
                          ) {
                            let missing1;
                            if (
                              (data3.Start === undefined && (missing1 = 'Start')) ||
                              (data3.End === undefined && (missing1 = 'End'))
                            ) {
                              validate27.errors = [
                                {
                                  instancePath: instancePath + '/' + i0 + '/Booked/' + i1,
                                  schemaPath: '#/items/properties/Booked/items/required',
                                  keyword: 'required',
                                  params: { missingProperty: missing1 },
                                  message:
                                    "must have required property '" + missing1 + "'",
                                  schema: schema12.items.properties.Booked.items.required,
                                  parentSchema: schema12.items.properties.Booked.items,
                                  data: data3,
                                },
                              ];
                              return false;
                            } else {
                              if (data3.Start !== undefined) {
                                let data4 = data3.Start;
                                const _errs9 = errors;
                                if (errors === _errs9) {
                                  if (errors === _errs9) {
                                    if (typeof data4 === 'string') {
                                      if (!formats2.validate(data4)) {
                                        validate27.errors = [
                                          {
                                            instancePath:
                                              instancePath +
                                              '/' +
                                              i0 +
                                              '/Booked/' +
                                              i1 +
                                              '/Start',
                                            schemaPath:
                                              '#/items/properties/Booked/items/properties/Start/format',
                                            keyword: 'format',
                                            params: { format: 'date-time' },
                                            message:
                                              'must match format "' + 'date-time' + '"',
                                            schema: 'date-time',
                                            parentSchema:
                                              schema12.items.properties.Booked.items
                                                .properties.Start,
                                            data: data4,
                                          },
                                        ];
                                        return false;
                                      }
                                    } else {
                                      validate27.errors = [
                                        {
                                          instancePath:
                                            instancePath +
                                            '/' +
                                            i0 +
                                            '/Booked/' +
                                            i1 +
                                            '/Start',
                                          schemaPath:
                                            '#/items/properties/Booked/items/properties/Start/type',
                                          keyword: 'type',
                                          params: { type: 'string' },
                                          message: 'must be string',
                                          schema:
                                            schema12.items.properties.Booked.items
                                              .properties.Start.type,
                                          parentSchema:
                                            schema12.items.properties.Booked.items
                                              .properties.Start,
                                          data: data4,
                                        },
                                      ];
                                      return false;
                                    }
                                  }
                                }
                                var valid3 = _errs9 === errors;
                              } else {
                                var valid3 = true;
                              }
                              if (valid3) {
                                if (data3.End !== undefined) {
                                  let data5 = data3.End;
                                  const _errs11 = errors;
                                  if (errors === _errs11) {
                                    if (errors === _errs11) {
                                      if (typeof data5 === 'string') {
                                        if (!formats2.validate(data5)) {
                                          validate27.errors = [
                                            {
                                              instancePath:
                                                instancePath +
                                                '/' +
                                                i0 +
                                                '/Booked/' +
                                                i1 +
                                                '/End',
                                              schemaPath:
                                                '#/items/properties/Booked/items/properties/End/format',
                                              keyword: 'format',
                                              params: { format: 'date-time' },
                                              message:
                                                'must match format "' + 'date-time' + '"',
                                              schema: 'date-time',
                                              parentSchema:
                                                schema12.items.properties.Booked.items
                                                  .properties.End,
                                              data: data5,
                                            },
                                          ];
                                          return false;
                                        }
                                      } else {
                                        validate27.errors = [
                                          {
                                            instancePath:
                                              instancePath +
                                              '/' +
                                              i0 +
                                              '/Booked/' +
                                              i1 +
                                              '/End',
                                            schemaPath:
                                              '#/items/properties/Booked/items/properties/End/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                            schema:
                                              schema12.items.properties.Booked.items
                                                .properties.End.type,
                                            parentSchema:
                                              schema12.items.properties.Booked.items
                                                .properties.End,
                                            data: data5,
                                          },
                                        ];
                                        return false;
                                      }
                                    }
                                  }
                                  var valid3 = _errs11 === errors;
                                } else {
                                  var valid3 = true;
                                }
                              }
                            }
                          } else {
                            validate27.errors = [
                              {
                                instancePath: instancePath + '/' + i0 + '/Booked/' + i1,
                                schemaPath: '#/items/properties/Booked/items/type',
                                keyword: 'type',
                                params: { type: 'object' },
                                message: 'must be object',
                                schema: schema12.items.properties.Booked.items.type,
                                parentSchema: schema12.items.properties.Booked.items,
                                data: data3,
                              },
                            ];
                            return false;
                          }
                        }
                        var valid2 = _errs7 === errors;
                        if (!valid2) {
                          break;
                        }
                      }
                    } else {
                      validate27.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/Booked',
                          schemaPath: '#/items/properties/Booked/type',
                          keyword: 'type',
                          params: { type: 'array' },
                          message: 'must be array',
                          schema: schema12.items.properties.Booked.type,
                          parentSchema: schema12.items.properties.Booked,
                          data: data2,
                        },
                      ];
                      return false;
                    }
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.Free !== undefined) {
                    let data6 = data0.Free;
                    const _errs13 = errors;
                    if (errors === _errs13) {
                      if (Array.isArray(data6)) {
                        var valid4 = true;
                        const len2 = data6.length;
                        for (let i2 = 0; i2 < len2; i2++) {
                          let data7 = data6[i2];
                          const _errs15 = errors;
                          if (errors === _errs15) {
                            if (
                              data7 &&
                              typeof data7 == 'object' &&
                              !Array.isArray(data7)
                            ) {
                              let missing2;
                              if (
                                (data7.Start === undefined && (missing2 = 'Start')) ||
                                (data7.End === undefined && (missing2 = 'End'))
                              ) {
                                validate27.errors = [
                                  {
                                    instancePath: instancePath + '/' + i0 + '/Free/' + i2,
                                    schemaPath: '#/items/properties/Free/items/required',
                                    keyword: 'required',
                                    params: { missingProperty: missing2 },
                                    message:
                                      "must have required property '" + missing2 + "'",
                                    schema: schema12.items.properties.Free.items.required,
                                    parentSchema: schema12.items.properties.Free.items,
                                    data: data7,
                                  },
                                ];
                                return false;
                              } else {
                                if (data7.Start !== undefined) {
                                  let data8 = data7.Start;
                                  const _errs17 = errors;
                                  if (errors === _errs17) {
                                    if (errors === _errs17) {
                                      if (typeof data8 === 'string') {
                                        if (!formats2.validate(data8)) {
                                          validate27.errors = [
                                            {
                                              instancePath:
                                                instancePath +
                                                '/' +
                                                i0 +
                                                '/Free/' +
                                                i2 +
                                                '/Start',
                                              schemaPath:
                                                '#/items/properties/Free/items/properties/Start/format',
                                              keyword: 'format',
                                              params: { format: 'date-time' },
                                              message:
                                                'must match format "' + 'date-time' + '"',
                                              schema: 'date-time',
                                              parentSchema:
                                                schema12.items.properties.Free.items
                                                  .properties.Start,
                                              data: data8,
                                            },
                                          ];
                                          return false;
                                        }
                                      } else {
                                        validate27.errors = [
                                          {
                                            instancePath:
                                              instancePath +
                                              '/' +
                                              i0 +
                                              '/Free/' +
                                              i2 +
                                              '/Start',
                                            schemaPath:
                                              '#/items/properties/Free/items/properties/Start/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                            schema:
                                              schema12.items.properties.Free.items
                                                .properties.Start.type,
                                            parentSchema:
                                              schema12.items.properties.Free.items
                                                .properties.Start,
                                            data: data8,
                                          },
                                        ];
                                        return false;
                                      }
                                    }
                                  }
                                  var valid5 = _errs17 === errors;
                                } else {
                                  var valid5 = true;
                                }
                                if (valid5) {
                                  if (data7.End !== undefined) {
                                    let data9 = data7.End;
                                    const _errs19 = errors;
                                    if (errors === _errs19) {
                                      if (errors === _errs19) {
                                        if (typeof data9 === 'string') {
                                          if (!formats2.validate(data9)) {
                                            validate27.errors = [
                                              {
                                                instancePath:
                                                  instancePath +
                                                  '/' +
                                                  i0 +
                                                  '/Free/' +
                                                  i2 +
                                                  '/End',
                                                schemaPath:
                                                  '#/items/properties/Free/items/properties/End/format',
                                                keyword: 'format',
                                                params: { format: 'date-time' },
                                                message:
                                                  'must match format "' +
                                                  'date-time' +
                                                  '"',
                                                schema: 'date-time',
                                                parentSchema:
                                                  schema12.items.properties.Free.items
                                                    .properties.End,
                                                data: data9,
                                              },
                                            ];
                                            return false;
                                          }
                                        } else {
                                          validate27.errors = [
                                            {
                                              instancePath:
                                                instancePath +
                                                '/' +
                                                i0 +
                                                '/Free/' +
                                                i2 +
                                                '/End',
                                              schemaPath:
                                                '#/items/properties/Free/items/properties/End/type',
                                              keyword: 'type',
                                              params: { type: 'string' },
                                              message: 'must be string',
                                              schema:
                                                schema12.items.properties.Free.items
                                                  .properties.End.type,
                                              parentSchema:
                                                schema12.items.properties.Free.items
                                                  .properties.End,
                                              data: data9,
                                            },
                                          ];
                                          return false;
                                        }
                                      }
                                    }
                                    var valid5 = _errs19 === errors;
                                  } else {
                                    var valid5 = true;
                                  }
                                }
                              }
                            } else {
                              validate27.errors = [
                                {
                                  instancePath: instancePath + '/' + i0 + '/Free/' + i2,
                                  schemaPath: '#/items/properties/Free/items/type',
                                  keyword: 'type',
                                  params: { type: 'object' },
                                  message: 'must be object',
                                  schema: schema12.items.properties.Free.items.type,
                                  parentSchema: schema12.items.properties.Free.items,
                                  data: data7,
                                },
                              ];
                              return false;
                            }
                          }
                          var valid4 = _errs15 === errors;
                          if (!valid4) {
                            break;
                          }
                        }
                      } else {
                        validate27.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/Free',
                            schemaPath: '#/items/properties/Free/type',
                            keyword: 'type',
                            params: { type: 'array' },
                            message: 'must be array',
                            schema: schema12.items.properties.Free.type,
                            parentSchema: schema12.items.properties.Free,
                            data: data6,
                          },
                        ];
                        return false;
                      }
                    }
                    var valid1 = _errs13 === errors;
                  } else {
                    var valid1 = true;
                  }
                }
              }
            }
          } else {
            validate27.errors = [
              {
                instancePath: instancePath + '/' + i0,
                schemaPath: '#/items/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema12.items.type,
                parentSchema: schema12.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate27.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
          schema: schema12.type,
          parentSchema: schema12,
          data,
        },
      ];
      return false;
    }
  }
  validate27.errors = vErrors;
  return errors === 0;
}
exports.validateScheduleResponse404 = validate28;
const schema13 = {
  type: 'string',
  description: 'First unknown device ID.',
  'x-standalone': false,
  'x-name': 'scheduleResponse404',
  'x-location': '#/paths//schedule/post/responses/404/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate28(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate28.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema13.type,
        parentSchema: schema13,
        data,
      },
    ];
    return false;
  }
  validate28.errors = vErrors;
  return errors === 0;
}
exports.validateScheduleResponse422 = validate29;
const schema14 = {
  type: 'string',
  description: 'First virtual device ID.',
  'x-standalone': false,
  'x-name': 'scheduleResponse422',
  'x-location': '#/paths//schedule/post/responses/422/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate29(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate29.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema14.type,
        parentSchema: schema14,
        data,
      },
    ];
    return false;
  }
  validate29.errors = vErrors;
  return errors === 0;
}
exports.validateScheduleResponse500 = validate30;
const schema15 = {
  type: 'string',
  description: 'Error description.',
  'x-standalone': false,
  'x-name': 'scheduleResponse500',
  'x-location': '#/paths//schedule/post/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate30(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate30.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema15.type,
        parentSchema: schema15,
        data,
      },
    ];
    return false;
  }
  validate30.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingBody = validate31;
const schema16 = {
  type: 'object',
  required: ['Devices', 'Time'],
  properties: {
    Devices: {
      type: 'array',
      description: 'List of devices which should be added.',
      items: {
        title: 'Device',
        description:
          'A device might either be a physical/virtual device or a group of device.',
        type: 'object',
        required: ['ID'],
        properties: {
          ID: {
            type: 'string',
            description:
              'Unique ID of the device. Contains the institution (by having an end point at that institution)',
            format: 'uri',
          },
        },
      },
    },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Type: {
      description:
        "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
      type: 'string',
      enum: ['normal'],
    },
  },
  'x-standalone': false,
  'x-name': 'newBookingBody',
  'x-location': '#/paths//booking/post/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate31(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Devices === undefined && (missing0 = 'Devices')) ||
        (data.Time === undefined && (missing0 = 'Time'))
      ) {
        validate31.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema16.required,
            parentSchema: schema16,
            data,
          },
        ];
        return false;
      } else {
        if (data.Devices !== undefined) {
          let data0 = data.Devices;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (Array.isArray(data0)) {
              var valid1 = true;
              const len0 = data0.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data1 = data0[i0];
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                    let missing1;
                    if (data1.ID === undefined && (missing1 = 'ID')) {
                      validate31.errors = [
                        {
                          instancePath: instancePath + '/Devices/' + i0,
                          schemaPath: '#/properties/Devices/items/required',
                          keyword: 'required',
                          params: { missingProperty: missing1 },
                          message: "must have required property '" + missing1 + "'",
                          schema: schema16.properties.Devices.items.required,
                          parentSchema: schema16.properties.Devices.items,
                          data: data1,
                        },
                      ];
                      return false;
                    } else {
                      if (data1.ID !== undefined) {
                        let data2 = data1.ID;
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (errors === _errs5) {
                            if (typeof data2 === 'string') {
                              if (!formats0(data2)) {
                                validate31.errors = [
                                  {
                                    instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                    schemaPath:
                                      '#/properties/Devices/items/properties/ID/format',
                                    keyword: 'format',
                                    params: { format: 'uri' },
                                    message: 'must match format "' + 'uri' + '"',
                                    schema: 'uri',
                                    parentSchema:
                                      schema16.properties.Devices.items.properties.ID,
                                    data: data2,
                                  },
                                ];
                                return false;
                              }
                            } else {
                              validate31.errors = [
                                {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/properties/Devices/items/properties/ID/type',
                                  keyword: 'type',
                                  params: { type: 'string' },
                                  message: 'must be string',
                                  schema:
                                    schema16.properties.Devices.items.properties.ID.type,
                                  parentSchema:
                                    schema16.properties.Devices.items.properties.ID,
                                  data: data2,
                                },
                              ];
                              return false;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate31.errors = [
                      {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/properties/Devices/items/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                        schema: schema16.properties.Devices.items.type,
                        parentSchema: schema16.properties.Devices.items,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                }
                var valid1 = _errs3 === errors;
                if (!valid1) {
                  break;
                }
              }
            } else {
              validate31.errors = [
                {
                  instancePath: instancePath + '/Devices',
                  schemaPath: '#/properties/Devices/type',
                  keyword: 'type',
                  params: { type: 'array' },
                  message: 'must be array',
                  schema: schema16.properties.Devices.type,
                  parentSchema: schema16.properties.Devices,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data3 = data.Time;
            const _errs7 = errors;
            if (errors === _errs7) {
              if (data3 && typeof data3 == 'object' && !Array.isArray(data3)) {
                let missing2;
                if (
                  (data3.Start === undefined && (missing2 = 'Start')) ||
                  (data3.End === undefined && (missing2 = 'End'))
                ) {
                  validate31.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing2 },
                      message: "must have required property '" + missing2 + "'",
                      schema: schema16.properties.Time.required,
                      parentSchema: schema16.properties.Time,
                      data: data3,
                    },
                  ];
                  return false;
                } else {
                  if (data3.Start !== undefined) {
                    let data4 = data3.Start;
                    const _errs9 = errors;
                    if (errors === _errs9) {
                      if (errors === _errs9) {
                        if (typeof data4 === 'string') {
                          if (!formats2.validate(data4)) {
                            validate31.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema16.properties.Time.properties.Start,
                                data: data4,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate31.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema16.properties.Time.properties.Start.type,
                              parentSchema: schema16.properties.Time.properties.Start,
                              data: data4,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid3 = _errs9 === errors;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data3.End !== undefined) {
                      let data5 = data3.End;
                      const _errs11 = errors;
                      if (errors === _errs11) {
                        if (errors === _errs11) {
                          if (typeof data5 === 'string') {
                            if (!formats2.validate(data5)) {
                              validate31.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema16.properties.Time.properties.End,
                                  data: data5,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate31.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema16.properties.Time.properties.End.type,
                                parentSchema: schema16.properties.Time.properties.End,
                                data: data5,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid3 = _errs11 === errors;
                    } else {
                      var valid3 = true;
                    }
                  }
                }
              } else {
                validate31.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema16.properties.Time.type,
                    parentSchema: schema16.properties.Time,
                    data: data3,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs7 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Type !== undefined) {
              let data6 = data.Type;
              const _errs13 = errors;
              if (typeof data6 !== 'string') {
                validate31.errors = [
                  {
                    instancePath: instancePath + '/Type',
                    schemaPath: '#/properties/Type/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema16.properties.Type.type,
                    parentSchema: schema16.properties.Type,
                    data: data6,
                  },
                ];
                return false;
              }
              if (!(data6 === 'normal')) {
                validate31.errors = [
                  {
                    instancePath: instancePath + '/Type',
                    schemaPath: '#/properties/Type/enum',
                    keyword: 'enum',
                    params: { allowedValues: schema16.properties.Type.enum },
                    message: 'must be equal to one of the allowed values',
                    schema: schema16.properties.Type.enum,
                    parentSchema: schema16.properties.Type,
                    data: data6,
                  },
                ];
                return false;
              }
              var valid0 = _errs13 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate31.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema16.type,
          parentSchema: schema16,
          data,
        },
      ];
      return false;
    }
  }
  validate31.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingResponse200 = validate32;
const schema17 = {
  type: 'object',
  required: ['BookingID'],
  properties: {
    BookingID: {
      type: 'string',
      format: 'uri',
      description: 'ID at which the booking can be managed.',
    },
  },
  'x-standalone': false,
  'x-name': 'newBookingResponse200',
  'x-location': '#/paths//booking/post/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate32(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.BookingID === undefined && (missing0 = 'BookingID')) {
        validate32.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema17.required,
            parentSchema: schema17,
            data,
          },
        ];
        return false;
      } else {
        if (data.BookingID !== undefined) {
          let data0 = data.BookingID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate32.errors = [
                    {
                      instancePath: instancePath + '/BookingID',
                      schemaPath: '#/properties/BookingID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema17.properties.BookingID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate32.errors = [
                  {
                    instancePath: instancePath + '/BookingID',
                    schemaPath: '#/properties/BookingID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema17.properties.BookingID.type,
                    parentSchema: schema17.properties.BookingID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate32.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema17.type,
          parentSchema: schema17,
          data,
        },
      ];
      return false;
    }
  }
  validate32.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingResponse500 = validate33;
const schema18 = {
  description: 'Error description',
  type: 'string',
  'x-standalone': false,
  'x-name': 'newBookingResponse500',
  'x-location': '#/paths//booking/post/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate33(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate33.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema18.type,
        parentSchema: schema18,
        data,
      },
    ];
    return false;
  }
  validate33.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingBody = validate34;
const schema19 = {
  anyOf: [
    {
      type: 'object',
      description: 'Use this request for adding devices.',
      properties: {
        Locked: {
          type: 'boolean',
          description:
            'Expresses whether the devices should be locked. Must match current status of booking. Is assumed to be false if not set.',
        },
        Devices: {
          type: 'array',
          description: 'List of devices which should be added.',
          items: {
            title: 'Device',
            description:
              'A device might either be a physical/virtual device or a group of device.',
            type: 'object',
            required: ['ID'],
            properties: {
              ID: {
                type: 'string',
                description:
                  'Unique ID of the device. Contains the institution (by having an end point at that institution)',
                format: 'uri',
              },
            },
          },
        },
      },
    },
    {
      type: 'object',
      description: 'Use this request for adding callbacks.',
      properties: {
        Callback: {
          type: 'string',
          format: 'uri',
          description: 'Callback which should be called at changes.',
        },
      },
    },
  ],
  'x-standalone': false,
  'x-name': 'updateBookingBody',
  'x-location': '#/paths//booking/{ID}/patch/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate34(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  let valid0 = false;
  const _errs1 = errors;
  if (errors === _errs1) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.Locked !== undefined) {
        let data0 = data.Locked;
        const _errs3 = errors;
        if (typeof data0 !== 'boolean') {
          const err0 = {
            instancePath: instancePath + '/Locked',
            schemaPath: '#/anyOf/0/properties/Locked/type',
            keyword: 'type',
            params: { type: 'boolean' },
            message: 'must be boolean',
            schema: schema19.anyOf[0].properties.Locked.type,
            parentSchema: schema19.anyOf[0].properties.Locked,
            data: data0,
          };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
        var valid1 = _errs3 === errors;
      } else {
        var valid1 = true;
      }
      if (valid1) {
        if (data.Devices !== undefined) {
          let data1 = data.Devices;
          const _errs5 = errors;
          if (errors === _errs5) {
            if (Array.isArray(data1)) {
              var valid2 = true;
              const len0 = data1.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data2 = data1[i0];
                const _errs7 = errors;
                if (errors === _errs7) {
                  if (data2 && typeof data2 == 'object' && !Array.isArray(data2)) {
                    let missing0;
                    if (data2.ID === undefined && (missing0 = 'ID')) {
                      const err1 = {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/anyOf/0/properties/Devices/items/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                        schema: schema19.anyOf[0].properties.Devices.items.required,
                        parentSchema: schema19.anyOf[0].properties.Devices.items,
                        data: data2,
                      };
                      if (vErrors === null) {
                        vErrors = [err1];
                      } else {
                        vErrors.push(err1);
                      }
                      errors++;
                    } else {
                      if (data2.ID !== undefined) {
                        let data3 = data2.ID;
                        const _errs9 = errors;
                        if (errors === _errs9) {
                          if (errors === _errs9) {
                            if (typeof data3 === 'string') {
                              if (!formats0(data3)) {
                                const err2 = {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/anyOf/0/properties/Devices/items/properties/ID/format',
                                  keyword: 'format',
                                  params: { format: 'uri' },
                                  message: 'must match format "' + 'uri' + '"',
                                  schema: 'uri',
                                  parentSchema:
                                    schema19.anyOf[0].properties.Devices.items.properties
                                      .ID,
                                  data: data3,
                                };
                                if (vErrors === null) {
                                  vErrors = [err2];
                                } else {
                                  vErrors.push(err2);
                                }
                                errors++;
                              }
                            } else {
                              const err3 = {
                                instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                schemaPath:
                                  '#/anyOf/0/properties/Devices/items/properties/ID/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema:
                                  schema19.anyOf[0].properties.Devices.items.properties.ID
                                    .type,
                                parentSchema:
                                  schema19.anyOf[0].properties.Devices.items.properties
                                    .ID,
                                data: data3,
                              };
                              if (vErrors === null) {
                                vErrors = [err3];
                              } else {
                                vErrors.push(err3);
                              }
                              errors++;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    const err4 = {
                      instancePath: instancePath + '/Devices/' + i0,
                      schemaPath: '#/anyOf/0/properties/Devices/items/type',
                      keyword: 'type',
                      params: { type: 'object' },
                      message: 'must be object',
                      schema: schema19.anyOf[0].properties.Devices.items.type,
                      parentSchema: schema19.anyOf[0].properties.Devices.items,
                      data: data2,
                    };
                    if (vErrors === null) {
                      vErrors = [err4];
                    } else {
                      vErrors.push(err4);
                    }
                    errors++;
                  }
                }
                var valid2 = _errs7 === errors;
                if (!valid2) {
                  break;
                }
              }
            } else {
              const err5 = {
                instancePath: instancePath + '/Devices',
                schemaPath: '#/anyOf/0/properties/Devices/type',
                keyword: 'type',
                params: { type: 'array' },
                message: 'must be array',
                schema: schema19.anyOf[0].properties.Devices.type,
                parentSchema: schema19.anyOf[0].properties.Devices,
                data: data1,
              };
              if (vErrors === null) {
                vErrors = [err5];
              } else {
                vErrors.push(err5);
              }
              errors++;
            }
          }
          var valid1 = _errs5 === errors;
        } else {
          var valid1 = true;
        }
      }
    } else {
      const err6 = {
        instancePath,
        schemaPath: '#/anyOf/0/type',
        keyword: 'type',
        params: { type: 'object' },
        message: 'must be object',
        schema: schema19.anyOf[0].type,
        parentSchema: schema19.anyOf[0],
        data,
      };
      if (vErrors === null) {
        vErrors = [err6];
      } else {
        vErrors.push(err6);
      }
      errors++;
    }
  }
  var _valid0 = _errs1 === errors;
  valid0 = valid0 || _valid0;
  if (!valid0) {
    const _errs11 = errors;
    if (errors === _errs11) {
      if (data && typeof data == 'object' && !Array.isArray(data)) {
        if (data.Callback !== undefined) {
          let data4 = data.Callback;
          const _errs13 = errors;
          if (errors === _errs13) {
            if (errors === _errs13) {
              if (typeof data4 === 'string') {
                if (!formats0(data4)) {
                  const err7 = {
                    instancePath: instancePath + '/Callback',
                    schemaPath: '#/anyOf/1/properties/Callback/format',
                    keyword: 'format',
                    params: { format: 'uri' },
                    message: 'must match format "' + 'uri' + '"',
                    schema: 'uri',
                    parentSchema: schema19.anyOf[1].properties.Callback,
                    data: data4,
                  };
                  if (vErrors === null) {
                    vErrors = [err7];
                  } else {
                    vErrors.push(err7);
                  }
                  errors++;
                }
              } else {
                const err8 = {
                  instancePath: instancePath + '/Callback',
                  schemaPath: '#/anyOf/1/properties/Callback/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema19.anyOf[1].properties.Callback.type,
                  parentSchema: schema19.anyOf[1].properties.Callback,
                  data: data4,
                };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors++;
              }
            }
          }
        }
      } else {
        const err9 = {
          instancePath,
          schemaPath: '#/anyOf/1/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema19.anyOf[1].type,
          parentSchema: schema19.anyOf[1],
          data,
        };
        if (vErrors === null) {
          vErrors = [err9];
        } else {
          vErrors.push(err9);
        }
        errors++;
      }
    }
    var _valid0 = _errs11 === errors;
    valid0 = valid0 || _valid0;
  }
  if (!valid0) {
    const err10 = {
      instancePath,
      schemaPath: '#/anyOf',
      keyword: 'anyOf',
      params: {},
      message: 'must match a schema in anyOf',
      schema: schema19.anyOf,
      parentSchema: schema19,
      data,
    };
    if (vErrors === null) {
      vErrors = [err10];
    } else {
      vErrors.push(err10);
    }
    errors++;
    validate34.errors = vErrors;
    return false;
  } else {
    errors = _errs0;
    if (vErrors !== null) {
      if (_errs0) {
        vErrors.length = _errs0;
      } else {
        vErrors = null;
      }
    }
  }
  validate34.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse200 = validate35;
const schema20 = {
  type: 'object',
  required: ['BookingID'],
  properties: { BookingID: { type: 'string', format: 'uri' } },
  'x-standalone': false,
  'x-name': 'updateBookingResponse200',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate35(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.BookingID === undefined && (missing0 = 'BookingID')) {
        validate35.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema20.required,
            parentSchema: schema20,
            data,
          },
        ];
        return false;
      } else {
        if (data.BookingID !== undefined) {
          let data0 = data.BookingID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate35.errors = [
                    {
                      instancePath: instancePath + '/BookingID',
                      schemaPath: '#/properties/BookingID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema20.properties.BookingID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate35.errors = [
                  {
                    instancePath: instancePath + '/BookingID',
                    schemaPath: '#/properties/BookingID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema20.properties.BookingID.type,
                    parentSchema: schema20.properties.BookingID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate35.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema20.type,
          parentSchema: schema20,
          data,
        },
      ];
      return false;
    }
  }
  validate35.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse400 = validate36;
const schema21 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'updateBookingResponse400',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/400/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate36(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate36.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema21.type,
        parentSchema: schema21,
        data,
      },
    ];
    return false;
  }
  validate36.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse500 = validate37;
const schema22 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'updateBookingResponse500',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate37(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate37.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema22.type,
        parentSchema: schema22,
        data,
      },
    ];
    return false;
  }
  validate37.errors = vErrors;
  return errors === 0;
}
exports.validateDeleteBookingResponse500 = validate38;
const schema23 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'deleteBookingResponse500',
  'x-location':
    '#/paths//booking/{ID}/delete/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate38(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate38.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema23.type,
        parentSchema: schema23,
        data,
      },
    ];
    return false;
  }
  validate38.errors = vErrors;
  return errors === 0;
}
exports.validateGetBookingResponse200 = validate39;
const schema24 = {
  type: 'object',
  required: ['Booking', 'Locked'],
  properties: {
    Booking: {
      title: 'Booking',
      description: 'A booking in the booking system.',
      type: 'object',
      required: ['ID', 'Time', 'Devices', 'Status', 'You', 'External'],
      properties: {
        ID: { type: 'string', format: 'uri', description: 'Unique ID of the booking.' },
        Time: {
          title: 'Timeslot',
          description: 'A time slot represents a slice of time used for bookings.',
          type: 'object',
          required: ['Start', 'End'],
          properties: {
            Start: {
              type: 'string',
              description: 'Start time of the booking.',
              format: 'date-time',
            },
            End: {
              type: 'string',
              description: 'End time of the booking.',
              format: 'date-time',
            },
          },
        },
        Devices: { type: 'array', items: { type: 'string', format: 'uri' } },
        Type: {
          description:
            "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
          type: 'string',
          enum: ['normal'],
        },
        Status: {
          description:
            "Current status of the booking. While the booking is pending, it can not be used. Will change automatically and can not be set by user. 'rejected' is set when the initial booking failed, 'cancelled' when the booking was deleted / cancelled after it was once active. The 'active-*' will be used when a device was added after the booking was locked.",
          type: 'string',
          enum: [
            'pending',
            'booked',
            'rejected',
            'cancelled',
            'active',
            'active-pending',
            'active-rejected',
          ],
        },
        You: { type: 'boolean', description: 'If true, this booking was done by you.' },
        External: {
          type: 'boolean',
          description: 'Shows whether the booking was done by an external institution.',
        },
        Message: {
          type: 'string',
          description:
            'User readable notes about the status of the booking (e.g. if devices are unknown).',
        },
      },
    },
    Locked: {
      type: 'boolean',
      description: 'Shows if the booking is in a locked status.',
    },
  },
  'x-standalone': false,
  'x-name': 'getBookingResponse200',
  'x-location': '#/paths//booking/{ID}/get/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate39(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Booking === undefined && (missing0 = 'Booking')) ||
        (data.Locked === undefined && (missing0 = 'Locked'))
      ) {
        validate39.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema24.required,
            parentSchema: schema24,
            data,
          },
        ];
        return false;
      } else {
        if (data.Booking !== undefined) {
          let data0 = data.Booking;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
              let missing1;
              if (
                (data0.ID === undefined && (missing1 = 'ID')) ||
                (data0.Time === undefined && (missing1 = 'Time')) ||
                (data0.Devices === undefined && (missing1 = 'Devices')) ||
                (data0.Status === undefined && (missing1 = 'Status')) ||
                (data0.You === undefined && (missing1 = 'You')) ||
                (data0.External === undefined && (missing1 = 'External'))
              ) {
                validate39.errors = [
                  {
                    instancePath: instancePath + '/Booking',
                    schemaPath: '#/properties/Booking/required',
                    keyword: 'required',
                    params: { missingProperty: missing1 },
                    message: "must have required property '" + missing1 + "'",
                    schema: schema24.properties.Booking.required,
                    parentSchema: schema24.properties.Booking,
                    data: data0,
                  },
                ];
                return false;
              } else {
                if (data0.ID !== undefined) {
                  let data1 = data0.ID;
                  const _errs3 = errors;
                  if (errors === _errs3) {
                    if (errors === _errs3) {
                      if (typeof data1 === 'string') {
                        if (!formats0(data1)) {
                          validate39.errors = [
                            {
                              instancePath: instancePath + '/Booking/ID',
                              schemaPath: '#/properties/Booking/properties/ID/format',
                              keyword: 'format',
                              params: { format: 'uri' },
                              message: 'must match format "' + 'uri' + '"',
                              schema: 'uri',
                              parentSchema: schema24.properties.Booking.properties.ID,
                              data: data1,
                            },
                          ];
                          return false;
                        }
                      } else {
                        validate39.errors = [
                          {
                            instancePath: instancePath + '/Booking/ID',
                            schemaPath: '#/properties/Booking/properties/ID/type',
                            keyword: 'type',
                            params: { type: 'string' },
                            message: 'must be string',
                            schema: schema24.properties.Booking.properties.ID.type,
                            parentSchema: schema24.properties.Booking.properties.ID,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    }
                  }
                  var valid1 = _errs3 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.Time !== undefined) {
                    let data2 = data0.Time;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (data2 && typeof data2 == 'object' && !Array.isArray(data2)) {
                        let missing2;
                        if (
                          (data2.Start === undefined && (missing2 = 'Start')) ||
                          (data2.End === undefined && (missing2 = 'End'))
                        ) {
                          validate39.errors = [
                            {
                              instancePath: instancePath + '/Booking/Time',
                              schemaPath: '#/properties/Booking/properties/Time/required',
                              keyword: 'required',
                              params: { missingProperty: missing2 },
                              message: "must have required property '" + missing2 + "'",
                              schema:
                                schema24.properties.Booking.properties.Time.required,
                              parentSchema: schema24.properties.Booking.properties.Time,
                              data: data2,
                            },
                          ];
                          return false;
                        } else {
                          if (data2.Start !== undefined) {
                            let data3 = data2.Start;
                            const _errs7 = errors;
                            if (errors === _errs7) {
                              if (errors === _errs7) {
                                if (typeof data3 === 'string') {
                                  if (!formats2.validate(data3)) {
                                    validate39.errors = [
                                      {
                                        instancePath:
                                          instancePath + '/Booking/Time/Start',
                                        schemaPath:
                                          '#/properties/Booking/properties/Time/properties/Start/format',
                                        keyword: 'format',
                                        params: { format: 'date-time' },
                                        message:
                                          'must match format "' + 'date-time' + '"',
                                        schema: 'date-time',
                                        parentSchema:
                                          schema24.properties.Booking.properties.Time
                                            .properties.Start,
                                        data: data3,
                                      },
                                    ];
                                    return false;
                                  }
                                } else {
                                  validate39.errors = [
                                    {
                                      instancePath: instancePath + '/Booking/Time/Start',
                                      schemaPath:
                                        '#/properties/Booking/properties/Time/properties/Start/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema24.properties.Booking.properties.Time
                                          .properties.Start.type,
                                      parentSchema:
                                        schema24.properties.Booking.properties.Time
                                          .properties.Start,
                                      data: data3,
                                    },
                                  ];
                                  return false;
                                }
                              }
                            }
                            var valid2 = _errs7 === errors;
                          } else {
                            var valid2 = true;
                          }
                          if (valid2) {
                            if (data2.End !== undefined) {
                              let data4 = data2.End;
                              const _errs9 = errors;
                              if (errors === _errs9) {
                                if (errors === _errs9) {
                                  if (typeof data4 === 'string') {
                                    if (!formats2.validate(data4)) {
                                      validate39.errors = [
                                        {
                                          instancePath:
                                            instancePath + '/Booking/Time/End',
                                          schemaPath:
                                            '#/properties/Booking/properties/Time/properties/End/format',
                                          keyword: 'format',
                                          params: { format: 'date-time' },
                                          message:
                                            'must match format "' + 'date-time' + '"',
                                          schema: 'date-time',
                                          parentSchema:
                                            schema24.properties.Booking.properties.Time
                                              .properties.End,
                                          data: data4,
                                        },
                                      ];
                                      return false;
                                    }
                                  } else {
                                    validate39.errors = [
                                      {
                                        instancePath: instancePath + '/Booking/Time/End',
                                        schemaPath:
                                          '#/properties/Booking/properties/Time/properties/End/type',
                                        keyword: 'type',
                                        params: { type: 'string' },
                                        message: 'must be string',
                                        schema:
                                          schema24.properties.Booking.properties.Time
                                            .properties.End.type,
                                        parentSchema:
                                          schema24.properties.Booking.properties.Time
                                            .properties.End,
                                        data: data4,
                                      },
                                    ];
                                    return false;
                                  }
                                }
                              }
                              var valid2 = _errs9 === errors;
                            } else {
                              var valid2 = true;
                            }
                          }
                        }
                      } else {
                        validate39.errors = [
                          {
                            instancePath: instancePath + '/Booking/Time',
                            schemaPath: '#/properties/Booking/properties/Time/type',
                            keyword: 'type',
                            params: { type: 'object' },
                            message: 'must be object',
                            schema: schema24.properties.Booking.properties.Time.type,
                            parentSchema: schema24.properties.Booking.properties.Time,
                            data: data2,
                          },
                        ];
                        return false;
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data0.Devices !== undefined) {
                      let data5 = data0.Devices;
                      const _errs11 = errors;
                      if (errors === _errs11) {
                        if (Array.isArray(data5)) {
                          var valid3 = true;
                          const len0 = data5.length;
                          for (let i0 = 0; i0 < len0; i0++) {
                            let data6 = data5[i0];
                            const _errs13 = errors;
                            if (errors === _errs13) {
                              if (errors === _errs13) {
                                if (typeof data6 === 'string') {
                                  if (!formats0(data6)) {
                                    validate39.errors = [
                                      {
                                        instancePath:
                                          instancePath + '/Booking/Devices/' + i0,
                                        schemaPath:
                                          '#/properties/Booking/properties/Devices/items/format',
                                        keyword: 'format',
                                        params: { format: 'uri' },
                                        message: 'must match format "' + 'uri' + '"',
                                        schema: 'uri',
                                        parentSchema:
                                          schema24.properties.Booking.properties.Devices
                                            .items,
                                        data: data6,
                                      },
                                    ];
                                    return false;
                                  }
                                } else {
                                  validate39.errors = [
                                    {
                                      instancePath:
                                        instancePath + '/Booking/Devices/' + i0,
                                      schemaPath:
                                        '#/properties/Booking/properties/Devices/items/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema24.properties.Booking.properties.Devices
                                          .items.type,
                                      parentSchema:
                                        schema24.properties.Booking.properties.Devices
                                          .items,
                                      data: data6,
                                    },
                                  ];
                                  return false;
                                }
                              }
                            }
                            var valid3 = _errs13 === errors;
                            if (!valid3) {
                              break;
                            }
                          }
                        } else {
                          validate39.errors = [
                            {
                              instancePath: instancePath + '/Booking/Devices',
                              schemaPath: '#/properties/Booking/properties/Devices/type',
                              keyword: 'type',
                              params: { type: 'array' },
                              message: 'must be array',
                              schema: schema24.properties.Booking.properties.Devices.type,
                              parentSchema:
                                schema24.properties.Booking.properties.Devices,
                              data: data5,
                            },
                          ];
                          return false;
                        }
                      }
                      var valid1 = _errs11 === errors;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data0.Type !== undefined) {
                        let data7 = data0.Type;
                        const _errs15 = errors;
                        if (typeof data7 !== 'string') {
                          validate39.errors = [
                            {
                              instancePath: instancePath + '/Booking/Type',
                              schemaPath: '#/properties/Booking/properties/Type/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema24.properties.Booking.properties.Type.type,
                              parentSchema: schema24.properties.Booking.properties.Type,
                              data: data7,
                            },
                          ];
                          return false;
                        }
                        if (!(data7 === 'normal')) {
                          validate39.errors = [
                            {
                              instancePath: instancePath + '/Booking/Type',
                              schemaPath: '#/properties/Booking/properties/Type/enum',
                              keyword: 'enum',
                              params: {
                                allowedValues:
                                  schema24.properties.Booking.properties.Type.enum,
                              },
                              message: 'must be equal to one of the allowed values',
                              schema: schema24.properties.Booking.properties.Type.enum,
                              parentSchema: schema24.properties.Booking.properties.Type,
                              data: data7,
                            },
                          ];
                          return false;
                        }
                        var valid1 = _errs15 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data0.Status !== undefined) {
                          let data8 = data0.Status;
                          const _errs17 = errors;
                          if (typeof data8 !== 'string') {
                            validate39.errors = [
                              {
                                instancePath: instancePath + '/Booking/Status',
                                schemaPath: '#/properties/Booking/properties/Status/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema:
                                  schema24.properties.Booking.properties.Status.type,
                                parentSchema:
                                  schema24.properties.Booking.properties.Status,
                                data: data8,
                              },
                            ];
                            return false;
                          }
                          if (
                            !(
                              data8 === 'pending' ||
                              data8 === 'booked' ||
                              data8 === 'rejected' ||
                              data8 === 'cancelled' ||
                              data8 === 'active' ||
                              data8 === 'active-pending' ||
                              data8 === 'active-rejected'
                            )
                          ) {
                            validate39.errors = [
                              {
                                instancePath: instancePath + '/Booking/Status',
                                schemaPath: '#/properties/Booking/properties/Status/enum',
                                keyword: 'enum',
                                params: {
                                  allowedValues:
                                    schema24.properties.Booking.properties.Status.enum,
                                },
                                message: 'must be equal to one of the allowed values',
                                schema:
                                  schema24.properties.Booking.properties.Status.enum,
                                parentSchema:
                                  schema24.properties.Booking.properties.Status,
                                data: data8,
                              },
                            ];
                            return false;
                          }
                          var valid1 = _errs17 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data0.You !== undefined) {
                            let data9 = data0.You;
                            const _errs19 = errors;
                            if (typeof data9 !== 'boolean') {
                              validate39.errors = [
                                {
                                  instancePath: instancePath + '/Booking/You',
                                  schemaPath: '#/properties/Booking/properties/You/type',
                                  keyword: 'type',
                                  params: { type: 'boolean' },
                                  message: 'must be boolean',
                                  schema: schema24.properties.Booking.properties.You.type,
                                  parentSchema:
                                    schema24.properties.Booking.properties.You,
                                  data: data9,
                                },
                              ];
                              return false;
                            }
                            var valid1 = _errs19 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data0.External !== undefined) {
                              let data10 = data0.External;
                              const _errs21 = errors;
                              if (typeof data10 !== 'boolean') {
                                validate39.errors = [
                                  {
                                    instancePath: instancePath + '/Booking/External',
                                    schemaPath:
                                      '#/properties/Booking/properties/External/type',
                                    keyword: 'type',
                                    params: { type: 'boolean' },
                                    message: 'must be boolean',
                                    schema:
                                      schema24.properties.Booking.properties.External
                                        .type,
                                    parentSchema:
                                      schema24.properties.Booking.properties.External,
                                    data: data10,
                                  },
                                ];
                                return false;
                              }
                              var valid1 = _errs21 === errors;
                            } else {
                              var valid1 = true;
                            }
                            if (valid1) {
                              if (data0.Message !== undefined) {
                                let data11 = data0.Message;
                                const _errs23 = errors;
                                if (typeof data11 !== 'string') {
                                  validate39.errors = [
                                    {
                                      instancePath: instancePath + '/Booking/Message',
                                      schemaPath:
                                        '#/properties/Booking/properties/Message/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema24.properties.Booking.properties.Message
                                          .type,
                                      parentSchema:
                                        schema24.properties.Booking.properties.Message,
                                      data: data11,
                                    },
                                  ];
                                  return false;
                                }
                                var valid1 = _errs23 === errors;
                              } else {
                                var valid1 = true;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              validate39.errors = [
                {
                  instancePath: instancePath + '/Booking',
                  schemaPath: '#/properties/Booking/type',
                  keyword: 'type',
                  params: { type: 'object' },
                  message: 'must be object',
                  schema: schema24.properties.Booking.type,
                  parentSchema: schema24.properties.Booking,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Locked !== undefined) {
            let data12 = data.Locked;
            const _errs25 = errors;
            if (typeof data12 !== 'boolean') {
              validate39.errors = [
                {
                  instancePath: instancePath + '/Locked',
                  schemaPath: '#/properties/Locked/type',
                  keyword: 'type',
                  params: { type: 'boolean' },
                  message: 'must be boolean',
                  schema: schema24.properties.Locked.type,
                  parentSchema: schema24.properties.Locked,
                  data: data12,
                },
              ];
              return false;
            }
            var valid0 = _errs25 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate39.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema24.type,
          parentSchema: schema24,
          data,
        },
      ];
      return false;
    }
  }
  validate39.errors = vErrors;
  return errors === 0;
}
exports.validateGetBookingResponse500 = validate40;
const schema25 = {
  type: 'string',
  description: 'Error code',
  'x-standalone': false,
  'x-name': 'getBookingResponse500',
  'x-location': '#/paths//booking/{ID}/get/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate40(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate40.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema25.type,
        parentSchema: schema25,
        data,
      },
    ];
    return false;
  }
  validate40.errors = vErrors;
  return errors === 0;
}
exports.validateDestroyBookingResponse500 = validate41;
const schema26 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'destroyBookingResponse500',
  'x-location':
    '#/paths//booking/{ID}/destroy/delete/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate41(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate41.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema26.type,
        parentSchema: schema26,
        data,
      },
    ];
    return false;
  }
  validate41.errors = vErrors;
  return errors === 0;
}
exports.validateLockBookingResponse200 = validate42;
const schema27 = {
  type: 'array',
  description:
    'The list of booked devices and selected real devices. Order is guaranteed to be the same as in the booking.',
  items: {
    type: 'object',
    required: ['Requested', 'Selected'],
    properties: {
      Requested: { type: 'string', format: 'uri' },
      Selected: { type: 'string', format: 'uri' },
    },
  },
  'x-standalone': false,
  'x-name': 'lockBookingResponse200',
  'x-location':
    '#/paths//booking/{ID}/lock/put/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate42(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.Requested === undefined && (missing0 = 'Requested')) ||
              (data0.Selected === undefined && (missing0 = 'Selected'))
            ) {
              validate42.errors = [
                {
                  instancePath: instancePath + '/' + i0,
                  schemaPath: '#/items/required',
                  keyword: 'required',
                  params: { missingProperty: missing0 },
                  message: "must have required property '" + missing0 + "'",
                  schema: schema27.items.required,
                  parentSchema: schema27.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.Requested !== undefined) {
                let data1 = data0.Requested;
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (errors === _errs3) {
                    if (typeof data1 === 'string') {
                      if (!formats0(data1)) {
                        validate42.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/Requested',
                            schemaPath: '#/items/properties/Requested/format',
                            keyword: 'format',
                            params: { format: 'uri' },
                            message: 'must match format "' + 'uri' + '"',
                            schema: 'uri',
                            parentSchema: schema27.items.properties.Requested,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    } else {
                      validate42.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/Requested',
                          schemaPath: '#/items/properties/Requested/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema27.items.properties.Requested.type,
                          parentSchema: schema27.items.properties.Requested,
                          data: data1,
                        },
                      ];
                      return false;
                    }
                  }
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.Selected !== undefined) {
                  let data2 = data0.Selected;
                  const _errs5 = errors;
                  if (errors === _errs5) {
                    if (errors === _errs5) {
                      if (typeof data2 === 'string') {
                        if (!formats0(data2)) {
                          validate42.errors = [
                            {
                              instancePath: instancePath + '/' + i0 + '/Selected',
                              schemaPath: '#/items/properties/Selected/format',
                              keyword: 'format',
                              params: { format: 'uri' },
                              message: 'must match format "' + 'uri' + '"',
                              schema: 'uri',
                              parentSchema: schema27.items.properties.Selected,
                              data: data2,
                            },
                          ];
                          return false;
                        }
                      } else {
                        validate42.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/Selected',
                            schemaPath: '#/items/properties/Selected/type',
                            keyword: 'type',
                            params: { type: 'string' },
                            message: 'must be string',
                            schema: schema27.items.properties.Selected.type,
                            parentSchema: schema27.items.properties.Selected,
                            data: data2,
                          },
                        ];
                        return false;
                      }
                    }
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
              }
            }
          } else {
            validate42.errors = [
              {
                instancePath: instancePath + '/' + i0,
                schemaPath: '#/items/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema27.items.type,
                parentSchema: schema27.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate42.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
          schema: schema27.type,
          parentSchema: schema27,
          data,
        },
      ];
      return false;
    }
  }
  validate42.errors = vErrors;
  return errors === 0;
}
exports.validateLockBookingResponse500 = validate43;
const schema28 = {
  type: 'string',
  description: 'Error string',
  'x-standalone': false,
  'x-name': 'lockBookingResponse500',
  'x-location':
    '#/paths//booking/{ID}/lock/put/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate43(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate43.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema28.type,
        parentSchema: schema28,
        data,
      },
    ];
    return false;
  }
  validate43.errors = vErrors;
  return errors === 0;
}
exports.validateUnlockBookingResponse500 = validate44;
const schema29 = {
  type: 'string',
  description: 'Error description.',
  'x-standalone': false,
  'x-name': 'unlockBookingResponse500',
  'x-location':
    '#/paths//booking/{ID}/lock/delete/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate44(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate44.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema29.type,
        parentSchema: schema29,
        data,
      },
    ];
    return false;
  }
  validate44.errors = vErrors;
  return errors === 0;
}
exports.validateBookingCallbackResponse500 = validate45;
const schema30 = {
  type: 'string',
  description: 'Error description.',
  'x-standalone': false,
  'x-name': 'bookingCallbackResponse500',
  'x-location':
    '#/paths//booking_callback/{ID}/post/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate45(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate45.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema30.type,
        parentSchema: schema30,
        data,
      },
    ];
    return false;
  }
  validate45.errors = vErrors;
  return errors === 0;
}
exports.validateBookingRequest = validate46;
const schema31 = {
  title: 'Booking',
  description: 'A booking in the booking system.',
  type: 'object',
  required: ['ID', 'Time', 'Devices', 'Status', 'You', 'External'],
  properties: {
    ID: { type: 'string', format: 'uri', description: 'Unique ID of the booking.' },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Devices: { type: 'array', items: { type: 'string', format: 'uri' } },
    Type: {
      description:
        "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
      type: 'string',
      enum: ['normal'],
    },
    Status: {
      description:
        "Current status of the booking. While the booking is pending, it can not be used. Will change automatically and can not be set by user. 'rejected' is set when the initial booking failed, 'cancelled' when the booking was deleted / cancelled after it was once active. The 'active-*' will be used when a device was added after the booking was locked.",
      type: 'string',
      enum: [
        'pending',
        'booked',
        'rejected',
        'cancelled',
        'active',
        'active-pending',
        'active-rejected',
      ],
    },
    You: { type: 'boolean', description: 'If true, this booking was done by you.' },
    External: {
      type: 'boolean',
      description: 'Shows whether the booking was done by an external institution.',
    },
    Message: {
      type: 'string',
      description:
        'User readable notes about the status of the booking (e.g. if devices are unknown).',
    },
  },
  'x-standalone': true,
  'x-name': 'BookingRequest',
  'x-location': '#/components/schemas/Booking_request',
  'x-schema-type': 'request',
};
function validate46(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.ID === undefined && (missing0 = 'ID')) ||
        (data.Time === undefined && (missing0 = 'Time')) ||
        (data.Devices === undefined && (missing0 = 'Devices')) ||
        (data.Status === undefined && (missing0 = 'Status')) ||
        (data.You === undefined && (missing0 = 'You')) ||
        (data.External === undefined && (missing0 = 'External'))
      ) {
        validate46.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema31.required,
            parentSchema: schema31,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate46.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema31.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate46.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema31.properties.ID.type,
                    parentSchema: schema31.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data1 = data.Time;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                let missing1;
                if (
                  (data1.Start === undefined && (missing1 = 'Start')) ||
                  (data1.End === undefined && (missing1 = 'End'))
                ) {
                  validate46.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing1 },
                      message: "must have required property '" + missing1 + "'",
                      schema: schema31.properties.Time.required,
                      parentSchema: schema31.properties.Time,
                      data: data1,
                    },
                  ];
                  return false;
                } else {
                  if (data1.Start !== undefined) {
                    let data2 = data1.Start;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (errors === _errs5) {
                        if (typeof data2 === 'string') {
                          if (!formats2.validate(data2)) {
                            validate46.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema31.properties.Time.properties.Start,
                                data: data2,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate46.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema31.properties.Time.properties.Start.type,
                              parentSchema: schema31.properties.Time.properties.Start,
                              data: data2,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data1.End !== undefined) {
                      let data3 = data1.End;
                      const _errs7 = errors;
                      if (errors === _errs7) {
                        if (errors === _errs7) {
                          if (typeof data3 === 'string') {
                            if (!formats2.validate(data3)) {
                              validate46.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema31.properties.Time.properties.End,
                                  data: data3,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate46.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema31.properties.Time.properties.End.type,
                                parentSchema: schema31.properties.Time.properties.End,
                                data: data3,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid1 = _errs7 === errors;
                    } else {
                      var valid1 = true;
                    }
                  }
                }
              } else {
                validate46.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema31.properties.Time.type,
                    parentSchema: schema31.properties.Time,
                    data: data1,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Devices !== undefined) {
              let data4 = data.Devices;
              const _errs9 = errors;
              if (errors === _errs9) {
                if (Array.isArray(data4)) {
                  var valid2 = true;
                  const len0 = data4.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data5 = data4[i0];
                    const _errs11 = errors;
                    if (errors === _errs11) {
                      if (errors === _errs11) {
                        if (typeof data5 === 'string') {
                          if (!formats0(data5)) {
                            validate46.errors = [
                              {
                                instancePath: instancePath + '/Devices/' + i0,
                                schemaPath: '#/properties/Devices/items/format',
                                keyword: 'format',
                                params: { format: 'uri' },
                                message: 'must match format "' + 'uri' + '"',
                                schema: 'uri',
                                parentSchema: schema31.properties.Devices.items,
                                data: data5,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate46.errors = [
                            {
                              instancePath: instancePath + '/Devices/' + i0,
                              schemaPath: '#/properties/Devices/items/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema31.properties.Devices.items.type,
                              parentSchema: schema31.properties.Devices.items,
                              data: data5,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid2 = _errs11 === errors;
                    if (!valid2) {
                      break;
                    }
                  }
                } else {
                  validate46.errors = [
                    {
                      instancePath: instancePath + '/Devices',
                      schemaPath: '#/properties/Devices/type',
                      keyword: 'type',
                      params: { type: 'array' },
                      message: 'must be array',
                      schema: schema31.properties.Devices.type,
                      parentSchema: schema31.properties.Devices,
                      data: data4,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs9 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.Type !== undefined) {
                let data6 = data.Type;
                const _errs13 = errors;
                if (typeof data6 !== 'string') {
                  validate46.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema31.properties.Type.type,
                      parentSchema: schema31.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                if (!(data6 === 'normal')) {
                  validate46.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/enum',
                      keyword: 'enum',
                      params: { allowedValues: schema31.properties.Type.enum },
                      message: 'must be equal to one of the allowed values',
                      schema: schema31.properties.Type.enum,
                      parentSchema: schema31.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs13 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.Status !== undefined) {
                  let data7 = data.Status;
                  const _errs15 = errors;
                  if (typeof data7 !== 'string') {
                    validate46.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/type',
                        keyword: 'type',
                        params: { type: 'string' },
                        message: 'must be string',
                        schema: schema31.properties.Status.type,
                        parentSchema: schema31.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  if (
                    !(
                      data7 === 'pending' ||
                      data7 === 'booked' ||
                      data7 === 'rejected' ||
                      data7 === 'cancelled' ||
                      data7 === 'active' ||
                      data7 === 'active-pending' ||
                      data7 === 'active-rejected'
                    )
                  ) {
                    validate46.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/enum',
                        keyword: 'enum',
                        params: { allowedValues: schema31.properties.Status.enum },
                        message: 'must be equal to one of the allowed values',
                        schema: schema31.properties.Status.enum,
                        parentSchema: schema31.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  var valid0 = _errs15 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.You !== undefined) {
                    let data8 = data.You;
                    const _errs17 = errors;
                    if (typeof data8 !== 'boolean') {
                      validate46.errors = [
                        {
                          instancePath: instancePath + '/You',
                          schemaPath: '#/properties/You/type',
                          keyword: 'type',
                          params: { type: 'boolean' },
                          message: 'must be boolean',
                          schema: schema31.properties.You.type,
                          parentSchema: schema31.properties.You,
                          data: data8,
                        },
                      ];
                      return false;
                    }
                    var valid0 = _errs17 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.External !== undefined) {
                      let data9 = data.External;
                      const _errs19 = errors;
                      if (typeof data9 !== 'boolean') {
                        validate46.errors = [
                          {
                            instancePath: instancePath + '/External',
                            schemaPath: '#/properties/External/type',
                            keyword: 'type',
                            params: { type: 'boolean' },
                            message: 'must be boolean',
                            schema: schema31.properties.External.type,
                            parentSchema: schema31.properties.External,
                            data: data9,
                          },
                        ];
                        return false;
                      }
                      var valid0 = _errs19 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.Message !== undefined) {
                        let data10 = data.Message;
                        const _errs21 = errors;
                        if (typeof data10 !== 'string') {
                          validate46.errors = [
                            {
                              instancePath: instancePath + '/Message',
                              schemaPath: '#/properties/Message/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema31.properties.Message.type,
                              parentSchema: schema31.properties.Message,
                              data: data10,
                            },
                          ];
                          return false;
                        }
                        var valid0 = _errs21 === errors;
                      } else {
                        var valid0 = true;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate46.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema31.type,
          parentSchema: schema31,
          data,
        },
      ];
      return false;
    }
  }
  validate46.errors = vErrors;
  return errors === 0;
}
exports.validateBookingResponse = validate47;
const schema32 = {
  title: 'Booking',
  description: 'A booking in the booking system.',
  type: 'object',
  required: ['ID', 'Time', 'Devices', 'Status', 'You', 'External'],
  properties: {
    ID: { type: 'string', format: 'uri', description: 'Unique ID of the booking.' },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Devices: { type: 'array', items: { type: 'string', format: 'uri' } },
    Type: {
      description:
        "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
      type: 'string',
      enum: ['normal'],
    },
    Status: {
      description:
        "Current status of the booking. While the booking is pending, it can not be used. Will change automatically and can not be set by user. 'rejected' is set when the initial booking failed, 'cancelled' when the booking was deleted / cancelled after it was once active. The 'active-*' will be used when a device was added after the booking was locked.",
      type: 'string',
      enum: [
        'pending',
        'booked',
        'rejected',
        'cancelled',
        'active',
        'active-pending',
        'active-rejected',
      ],
    },
    You: { type: 'boolean', description: 'If true, this booking was done by you.' },
    External: {
      type: 'boolean',
      description: 'Shows whether the booking was done by an external institution.',
    },
    Message: {
      type: 'string',
      description:
        'User readable notes about the status of the booking (e.g. if devices are unknown).',
    },
  },
  'x-standalone': true,
  'x-name': 'BookingResponse',
  'x-location': '#/components/schemas/Booking_response',
  'x-schema-type': 'response',
};
function validate47(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.ID === undefined && (missing0 = 'ID')) ||
        (data.Time === undefined && (missing0 = 'Time')) ||
        (data.Devices === undefined && (missing0 = 'Devices')) ||
        (data.Status === undefined && (missing0 = 'Status')) ||
        (data.You === undefined && (missing0 = 'You')) ||
        (data.External === undefined && (missing0 = 'External'))
      ) {
        validate47.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema32.required,
            parentSchema: schema32,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate47.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema32.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate47.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema32.properties.ID.type,
                    parentSchema: schema32.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data1 = data.Time;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                let missing1;
                if (
                  (data1.Start === undefined && (missing1 = 'Start')) ||
                  (data1.End === undefined && (missing1 = 'End'))
                ) {
                  validate47.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing1 },
                      message: "must have required property '" + missing1 + "'",
                      schema: schema32.properties.Time.required,
                      parentSchema: schema32.properties.Time,
                      data: data1,
                    },
                  ];
                  return false;
                } else {
                  if (data1.Start !== undefined) {
                    let data2 = data1.Start;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (errors === _errs5) {
                        if (typeof data2 === 'string') {
                          if (!formats2.validate(data2)) {
                            validate47.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema32.properties.Time.properties.Start,
                                data: data2,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate47.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema32.properties.Time.properties.Start.type,
                              parentSchema: schema32.properties.Time.properties.Start,
                              data: data2,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data1.End !== undefined) {
                      let data3 = data1.End;
                      const _errs7 = errors;
                      if (errors === _errs7) {
                        if (errors === _errs7) {
                          if (typeof data3 === 'string') {
                            if (!formats2.validate(data3)) {
                              validate47.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema32.properties.Time.properties.End,
                                  data: data3,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate47.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema32.properties.Time.properties.End.type,
                                parentSchema: schema32.properties.Time.properties.End,
                                data: data3,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid1 = _errs7 === errors;
                    } else {
                      var valid1 = true;
                    }
                  }
                }
              } else {
                validate47.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema32.properties.Time.type,
                    parentSchema: schema32.properties.Time,
                    data: data1,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Devices !== undefined) {
              let data4 = data.Devices;
              const _errs9 = errors;
              if (errors === _errs9) {
                if (Array.isArray(data4)) {
                  var valid2 = true;
                  const len0 = data4.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data5 = data4[i0];
                    const _errs11 = errors;
                    if (errors === _errs11) {
                      if (errors === _errs11) {
                        if (typeof data5 === 'string') {
                          if (!formats0(data5)) {
                            validate47.errors = [
                              {
                                instancePath: instancePath + '/Devices/' + i0,
                                schemaPath: '#/properties/Devices/items/format',
                                keyword: 'format',
                                params: { format: 'uri' },
                                message: 'must match format "' + 'uri' + '"',
                                schema: 'uri',
                                parentSchema: schema32.properties.Devices.items,
                                data: data5,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate47.errors = [
                            {
                              instancePath: instancePath + '/Devices/' + i0,
                              schemaPath: '#/properties/Devices/items/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema32.properties.Devices.items.type,
                              parentSchema: schema32.properties.Devices.items,
                              data: data5,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid2 = _errs11 === errors;
                    if (!valid2) {
                      break;
                    }
                  }
                } else {
                  validate47.errors = [
                    {
                      instancePath: instancePath + '/Devices',
                      schemaPath: '#/properties/Devices/type',
                      keyword: 'type',
                      params: { type: 'array' },
                      message: 'must be array',
                      schema: schema32.properties.Devices.type,
                      parentSchema: schema32.properties.Devices,
                      data: data4,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs9 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.Type !== undefined) {
                let data6 = data.Type;
                const _errs13 = errors;
                if (typeof data6 !== 'string') {
                  validate47.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema32.properties.Type.type,
                      parentSchema: schema32.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                if (!(data6 === 'normal')) {
                  validate47.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/enum',
                      keyword: 'enum',
                      params: { allowedValues: schema32.properties.Type.enum },
                      message: 'must be equal to one of the allowed values',
                      schema: schema32.properties.Type.enum,
                      parentSchema: schema32.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs13 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.Status !== undefined) {
                  let data7 = data.Status;
                  const _errs15 = errors;
                  if (typeof data7 !== 'string') {
                    validate47.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/type',
                        keyword: 'type',
                        params: { type: 'string' },
                        message: 'must be string',
                        schema: schema32.properties.Status.type,
                        parentSchema: schema32.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  if (
                    !(
                      data7 === 'pending' ||
                      data7 === 'booked' ||
                      data7 === 'rejected' ||
                      data7 === 'cancelled' ||
                      data7 === 'active' ||
                      data7 === 'active-pending' ||
                      data7 === 'active-rejected'
                    )
                  ) {
                    validate47.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/enum',
                        keyword: 'enum',
                        params: { allowedValues: schema32.properties.Status.enum },
                        message: 'must be equal to one of the allowed values',
                        schema: schema32.properties.Status.enum,
                        parentSchema: schema32.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  var valid0 = _errs15 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.You !== undefined) {
                    let data8 = data.You;
                    const _errs17 = errors;
                    if (typeof data8 !== 'boolean') {
                      validate47.errors = [
                        {
                          instancePath: instancePath + '/You',
                          schemaPath: '#/properties/You/type',
                          keyword: 'type',
                          params: { type: 'boolean' },
                          message: 'must be boolean',
                          schema: schema32.properties.You.type,
                          parentSchema: schema32.properties.You,
                          data: data8,
                        },
                      ];
                      return false;
                    }
                    var valid0 = _errs17 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.External !== undefined) {
                      let data9 = data.External;
                      const _errs19 = errors;
                      if (typeof data9 !== 'boolean') {
                        validate47.errors = [
                          {
                            instancePath: instancePath + '/External',
                            schemaPath: '#/properties/External/type',
                            keyword: 'type',
                            params: { type: 'boolean' },
                            message: 'must be boolean',
                            schema: schema32.properties.External.type,
                            parentSchema: schema32.properties.External,
                            data: data9,
                          },
                        ];
                        return false;
                      }
                      var valid0 = _errs19 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.Message !== undefined) {
                        let data10 = data.Message;
                        const _errs21 = errors;
                        if (typeof data10 !== 'string') {
                          validate47.errors = [
                            {
                              instancePath: instancePath + '/Message',
                              schemaPath: '#/properties/Message/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema32.properties.Message.type,
                              parentSchema: schema32.properties.Message,
                              data: data10,
                            },
                          ];
                          return false;
                        }
                        var valid0 = _errs21 === errors;
                      } else {
                        var valid0 = true;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate47.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema32.type,
          parentSchema: schema32,
          data,
        },
      ];
      return false;
    }
  }
  validate47.errors = vErrors;
  return errors === 0;
}
exports.validateDeviceRequest = validate48;
const schema33 = {
  title: 'Device',
  description: 'A device might either be a physical/virtual device or a group of device.',
  type: 'object',
  required: ['ID'],
  properties: {
    ID: {
      type: 'string',
      description:
        'Unique ID of the device. Contains the institution (by having an end point at that institution)',
      format: 'uri',
    },
  },
  'x-standalone': true,
  'x-name': 'DeviceRequest',
  'x-location': '#/components/schemas/Device_request',
  'x-schema-type': 'request',
};
function validate48(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.ID === undefined && (missing0 = 'ID')) {
        validate48.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema33.required,
            parentSchema: schema33,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate48.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema33.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate48.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema33.properties.ID.type,
                    parentSchema: schema33.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate48.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema33.type,
          parentSchema: schema33,
          data,
        },
      ];
      return false;
    }
  }
  validate48.errors = vErrors;
  return errors === 0;
}
exports.validateDeviceResponse = validate49;
const schema34 = {
  title: 'Device',
  description: 'A device might either be a physical/virtual device or a group of device.',
  type: 'object',
  required: ['ID'],
  properties: {
    ID: {
      type: 'string',
      description:
        'Unique ID of the device. Contains the institution (by having an end point at that institution)',
      format: 'uri',
    },
  },
  'x-standalone': true,
  'x-name': 'DeviceResponse',
  'x-location': '#/components/schemas/Device_response',
  'x-schema-type': 'response',
};
function validate49(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.ID === undefined && (missing0 = 'ID')) {
        validate49.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema34.required,
            parentSchema: schema34,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate49.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema34.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate49.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema34.properties.ID.type,
                    parentSchema: schema34.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate49.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema34.type,
          parentSchema: schema34,
          data,
        },
      ];
      return false;
    }
  }
  validate49.errors = vErrors;
  return errors === 0;
}
exports.validateExperimentRequest = validate50;
const schema35 = {
  title: 'Experiment',
  description:
    'An experiment describes a set of devices and how they should be connected (potentially among other metadata).',
  type: 'object',
  required: ['Devices'],
  properties: {
    Devices: {
      type: 'array',
      description: 'List of devices used in experiment.',
      items: {
        title: 'Device',
        description:
          'A device might either be a physical/virtual device or a group of device.',
        type: 'object',
        required: ['ID'],
        properties: {
          ID: {
            type: 'string',
            description:
              'Unique ID of the device. Contains the institution (by having an end point at that institution)',
            format: 'uri',
          },
        },
      },
    },
    Description: {
      type: 'string',
      description:
        'User provided description, for example might be a reason for the booking (e.g. maintenance) or a link to the experiment. Might be empty or missing.',
    },
  },
  'x-standalone': true,
  'x-name': 'ExperimentRequest',
  'x-location': '#/components/schemas/Experiment_request',
  'x-schema-type': 'request',
};
function validate50(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.Devices === undefined && (missing0 = 'Devices')) {
        validate50.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema35.required,
            parentSchema: schema35,
            data,
          },
        ];
        return false;
      } else {
        if (data.Devices !== undefined) {
          let data0 = data.Devices;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (Array.isArray(data0)) {
              var valid1 = true;
              const len0 = data0.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data1 = data0[i0];
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                    let missing1;
                    if (data1.ID === undefined && (missing1 = 'ID')) {
                      validate50.errors = [
                        {
                          instancePath: instancePath + '/Devices/' + i0,
                          schemaPath: '#/properties/Devices/items/required',
                          keyword: 'required',
                          params: { missingProperty: missing1 },
                          message: "must have required property '" + missing1 + "'",
                          schema: schema35.properties.Devices.items.required,
                          parentSchema: schema35.properties.Devices.items,
                          data: data1,
                        },
                      ];
                      return false;
                    } else {
                      if (data1.ID !== undefined) {
                        let data2 = data1.ID;
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (errors === _errs5) {
                            if (typeof data2 === 'string') {
                              if (!formats0(data2)) {
                                validate50.errors = [
                                  {
                                    instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                    schemaPath:
                                      '#/properties/Devices/items/properties/ID/format',
                                    keyword: 'format',
                                    params: { format: 'uri' },
                                    message: 'must match format "' + 'uri' + '"',
                                    schema: 'uri',
                                    parentSchema:
                                      schema35.properties.Devices.items.properties.ID,
                                    data: data2,
                                  },
                                ];
                                return false;
                              }
                            } else {
                              validate50.errors = [
                                {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/properties/Devices/items/properties/ID/type',
                                  keyword: 'type',
                                  params: { type: 'string' },
                                  message: 'must be string',
                                  schema:
                                    schema35.properties.Devices.items.properties.ID.type,
                                  parentSchema:
                                    schema35.properties.Devices.items.properties.ID,
                                  data: data2,
                                },
                              ];
                              return false;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate50.errors = [
                      {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/properties/Devices/items/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                        schema: schema35.properties.Devices.items.type,
                        parentSchema: schema35.properties.Devices.items,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                }
                var valid1 = _errs3 === errors;
                if (!valid1) {
                  break;
                }
              }
            } else {
              validate50.errors = [
                {
                  instancePath: instancePath + '/Devices',
                  schemaPath: '#/properties/Devices/type',
                  keyword: 'type',
                  params: { type: 'array' },
                  message: 'must be array',
                  schema: schema35.properties.Devices.type,
                  parentSchema: schema35.properties.Devices,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Description !== undefined) {
            let data3 = data.Description;
            const _errs7 = errors;
            if (typeof data3 !== 'string') {
              validate50.errors = [
                {
                  instancePath: instancePath + '/Description',
                  schemaPath: '#/properties/Description/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema35.properties.Description.type,
                  parentSchema: schema35.properties.Description,
                  data: data3,
                },
              ];
              return false;
            }
            var valid0 = _errs7 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate50.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema35.type,
          parentSchema: schema35,
          data,
        },
      ];
      return false;
    }
  }
  validate50.errors = vErrors;
  return errors === 0;
}
exports.validateExperimentResponse = validate51;
const schema36 = {
  title: 'Experiment',
  description:
    'An experiment describes a set of devices and how they should be connected (potentially among other metadata).',
  type: 'object',
  required: ['Devices'],
  properties: {
    Devices: {
      type: 'array',
      description: 'List of devices used in experiment.',
      items: {
        title: 'Device',
        description:
          'A device might either be a physical/virtual device or a group of device.',
        type: 'object',
        required: ['ID'],
        properties: {
          ID: {
            type: 'string',
            description:
              'Unique ID of the device. Contains the institution (by having an end point at that institution)',
            format: 'uri',
          },
        },
      },
    },
    Description: {
      type: 'string',
      description:
        'User provided description, for example might be a reason for the booking (e.g. maintenance) or a link to the experiment. Might be empty or missing.',
    },
  },
  'x-standalone': true,
  'x-name': 'ExperimentResponse',
  'x-location': '#/components/schemas/Experiment_response',
  'x-schema-type': 'response',
};
function validate51(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.Devices === undefined && (missing0 = 'Devices')) {
        validate51.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema36.required,
            parentSchema: schema36,
            data,
          },
        ];
        return false;
      } else {
        if (data.Devices !== undefined) {
          let data0 = data.Devices;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (Array.isArray(data0)) {
              var valid1 = true;
              const len0 = data0.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data1 = data0[i0];
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                    let missing1;
                    if (data1.ID === undefined && (missing1 = 'ID')) {
                      validate51.errors = [
                        {
                          instancePath: instancePath + '/Devices/' + i0,
                          schemaPath: '#/properties/Devices/items/required',
                          keyword: 'required',
                          params: { missingProperty: missing1 },
                          message: "must have required property '" + missing1 + "'",
                          schema: schema36.properties.Devices.items.required,
                          parentSchema: schema36.properties.Devices.items,
                          data: data1,
                        },
                      ];
                      return false;
                    } else {
                      if (data1.ID !== undefined) {
                        let data2 = data1.ID;
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (errors === _errs5) {
                            if (typeof data2 === 'string') {
                              if (!formats0(data2)) {
                                validate51.errors = [
                                  {
                                    instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                    schemaPath:
                                      '#/properties/Devices/items/properties/ID/format',
                                    keyword: 'format',
                                    params: { format: 'uri' },
                                    message: 'must match format "' + 'uri' + '"',
                                    schema: 'uri',
                                    parentSchema:
                                      schema36.properties.Devices.items.properties.ID,
                                    data: data2,
                                  },
                                ];
                                return false;
                              }
                            } else {
                              validate51.errors = [
                                {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/properties/Devices/items/properties/ID/type',
                                  keyword: 'type',
                                  params: { type: 'string' },
                                  message: 'must be string',
                                  schema:
                                    schema36.properties.Devices.items.properties.ID.type,
                                  parentSchema:
                                    schema36.properties.Devices.items.properties.ID,
                                  data: data2,
                                },
                              ];
                              return false;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate51.errors = [
                      {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/properties/Devices/items/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                        schema: schema36.properties.Devices.items.type,
                        parentSchema: schema36.properties.Devices.items,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                }
                var valid1 = _errs3 === errors;
                if (!valid1) {
                  break;
                }
              }
            } else {
              validate51.errors = [
                {
                  instancePath: instancePath + '/Devices',
                  schemaPath: '#/properties/Devices/type',
                  keyword: 'type',
                  params: { type: 'array' },
                  message: 'must be array',
                  schema: schema36.properties.Devices.type,
                  parentSchema: schema36.properties.Devices,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Description !== undefined) {
            let data3 = data.Description;
            const _errs7 = errors;
            if (typeof data3 !== 'string') {
              validate51.errors = [
                {
                  instancePath: instancePath + '/Description',
                  schemaPath: '#/properties/Description/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema36.properties.Description.type,
                  parentSchema: schema36.properties.Description,
                  data: data3,
                },
              ];
              return false;
            }
            var valid0 = _errs7 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate51.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema36.type,
          parentSchema: schema36,
          data,
        },
      ];
      return false;
    }
  }
  validate51.errors = vErrors;
  return errors === 0;
}
exports.validateTimeslotRequest = validate52;
const schema37 = {
  title: 'Timeslot',
  description: 'A time slot represents a slice of time used for bookings.',
  type: 'object',
  required: ['Start', 'End'],
  properties: {
    Start: {
      type: 'string',
      description: 'Start time of the booking.',
      format: 'date-time',
    },
    End: { type: 'string', description: 'End time of the booking.', format: 'date-time' },
  },
  'x-standalone': true,
  'x-name': 'TimeslotRequest',
  'x-location': '#/components/schemas/Timeslot_request',
  'x-schema-type': 'request',
};
function validate52(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Start === undefined && (missing0 = 'Start')) ||
        (data.End === undefined && (missing0 = 'End'))
      ) {
        validate52.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema37.required,
            parentSchema: schema37,
            data,
          },
        ];
        return false;
      } else {
        if (data.Start !== undefined) {
          let data0 = data.Start;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats2.validate(data0)) {
                  validate52.errors = [
                    {
                      instancePath: instancePath + '/Start',
                      schemaPath: '#/properties/Start/format',
                      keyword: 'format',
                      params: { format: 'date-time' },
                      message: 'must match format "' + 'date-time' + '"',
                      schema: 'date-time',
                      parentSchema: schema37.properties.Start,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate52.errors = [
                  {
                    instancePath: instancePath + '/Start',
                    schemaPath: '#/properties/Start/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema37.properties.Start.type,
                    parentSchema: schema37.properties.Start,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.End !== undefined) {
            let data1 = data.End;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (errors === _errs3) {
                if (typeof data1 === 'string') {
                  if (!formats2.validate(data1)) {
                    validate52.errors = [
                      {
                        instancePath: instancePath + '/End',
                        schemaPath: '#/properties/End/format',
                        keyword: 'format',
                        params: { format: 'date-time' },
                        message: 'must match format "' + 'date-time' + '"',
                        schema: 'date-time',
                        parentSchema: schema37.properties.End,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                } else {
                  validate52.errors = [
                    {
                      instancePath: instancePath + '/End',
                      schemaPath: '#/properties/End/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema37.properties.End.type,
                      parentSchema: schema37.properties.End,
                      data: data1,
                    },
                  ];
                  return false;
                }
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate52.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema37.type,
          parentSchema: schema37,
          data,
        },
      ];
      return false;
    }
  }
  validate52.errors = vErrors;
  return errors === 0;
}
exports.validateTimeslotResponse = validate53;
const schema38 = {
  title: 'Timeslot',
  description: 'A time slot represents a slice of time used for bookings.',
  type: 'object',
  required: ['Start', 'End'],
  properties: {
    Start: {
      type: 'string',
      description: 'Start time of the booking.',
      format: 'date-time',
    },
    End: { type: 'string', description: 'End time of the booking.', format: 'date-time' },
  },
  'x-standalone': true,
  'x-name': 'TimeslotResponse',
  'x-location': '#/components/schemas/Timeslot_response',
  'x-schema-type': 'response',
};
function validate53(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Start === undefined && (missing0 = 'Start')) ||
        (data.End === undefined && (missing0 = 'End'))
      ) {
        validate53.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema38.required,
            parentSchema: schema38,
            data,
          },
        ];
        return false;
      } else {
        if (data.Start !== undefined) {
          let data0 = data.Start;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats2.validate(data0)) {
                  validate53.errors = [
                    {
                      instancePath: instancePath + '/Start',
                      schemaPath: '#/properties/Start/format',
                      keyword: 'format',
                      params: { format: 'date-time' },
                      message: 'must match format "' + 'date-time' + '"',
                      schema: 'date-time',
                      parentSchema: schema38.properties.Start,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate53.errors = [
                  {
                    instancePath: instancePath + '/Start',
                    schemaPath: '#/properties/Start/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema38.properties.Start.type,
                    parentSchema: schema38.properties.Start,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.End !== undefined) {
            let data1 = data.End;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (errors === _errs3) {
                if (typeof data1 === 'string') {
                  if (!formats2.validate(data1)) {
                    validate53.errors = [
                      {
                        instancePath: instancePath + '/End',
                        schemaPath: '#/properties/End/format',
                        keyword: 'format',
                        params: { format: 'date-time' },
                        message: 'must match format "' + 'date-time' + '"',
                        schema: 'date-time',
                        parentSchema: schema38.properties.End,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                } else {
                  validate53.errors = [
                    {
                      instancePath: instancePath + '/End',
                      schemaPath: '#/properties/End/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema38.properties.End.type,
                      parentSchema: schema38.properties.End,
                      data: data1,
                    },
                  ];
                  return false;
                }
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate53.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema38.type,
          parentSchema: schema38,
          data,
        },
      ];
      return false;
    }
  }
  validate53.errors = vErrors;
  return errors === 0;
}
exports.validateIDRequest = validate54;
const schema39 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'IDRequest',
  'x-location': '#/components/parameters/ID/schema_request',
  'x-schema-type': 'request',
};
function validate54(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate54.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema39.type,
        parentSchema: schema39,
        data,
      },
    ];
    return false;
  }
  validate54.errors = vErrors;
  return errors === 0;
}
exports.validateIDResponse = validate55;
const schema40 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'IDResponse',
  'x-location': '#/components/parameters/ID/schema_response',
  'x-schema-type': 'response',
};
function validate55(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate55.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema40.type,
        parentSchema: schema40,
        data,
      },
    ];
    return false;
  }
  validate55.errors = vErrors;
  return errors === 0;
}
exports.validateScheduleBodyRequest = validate56;
const schema41 = {
  type: 'object',
  required: ['Experiment', 'Time'],
  properties: {
    Experiment: {
      title: 'Experiment',
      description:
        'An experiment describes a set of devices and how they should be connected (potentially among other metadata).',
      type: 'object',
      required: ['Devices'],
      properties: {
        Devices: {
          type: 'array',
          description: 'List of devices used in experiment.',
          items: {
            title: 'Device',
            description:
              'A device might either be a physical/virtual device or a group of device.',
            type: 'object',
            required: ['ID'],
            properties: {
              ID: {
                type: 'string',
                description:
                  'Unique ID of the device. Contains the institution (by having an end point at that institution)',
                format: 'uri',
              },
            },
          },
        },
        Description: {
          type: 'string',
          description:
            'User provided description, for example might be a reason for the booking (e.g. maintenance) or a link to the experiment. Might be empty or missing.',
        },
      },
    },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Combined: {
      type: 'boolean',
      description:
        'If true, show only one timetable per device instead of one for all available physical devices.',
    },
    onlyOwn: {
      type: 'boolean',
      description:
        '(private) Show only devices of this institution. Give an error if a device of an other institution is requested.',
    },
  },
  'x-standalone': false,
  'x-name': 'scheduleBodyRequest',
  'x-location':
    '#/paths//schedule/post/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate56(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Experiment === undefined && (missing0 = 'Experiment')) ||
        (data.Time === undefined && (missing0 = 'Time'))
      ) {
        validate56.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema41.required,
            parentSchema: schema41,
            data,
          },
        ];
        return false;
      } else {
        if (data.Experiment !== undefined) {
          let data0 = data.Experiment;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
              let missing1;
              if (data0.Devices === undefined && (missing1 = 'Devices')) {
                validate56.errors = [
                  {
                    instancePath: instancePath + '/Experiment',
                    schemaPath: '#/properties/Experiment/required',
                    keyword: 'required',
                    params: { missingProperty: missing1 },
                    message: "must have required property '" + missing1 + "'",
                    schema: schema41.properties.Experiment.required,
                    parentSchema: schema41.properties.Experiment,
                    data: data0,
                  },
                ];
                return false;
              } else {
                if (data0.Devices !== undefined) {
                  let data1 = data0.Devices;
                  const _errs3 = errors;
                  if (errors === _errs3) {
                    if (Array.isArray(data1)) {
                      var valid2 = true;
                      const len0 = data1.length;
                      for (let i0 = 0; i0 < len0; i0++) {
                        let data2 = data1[i0];
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (
                            data2 &&
                            typeof data2 == 'object' &&
                            !Array.isArray(data2)
                          ) {
                            let missing2;
                            if (data2.ID === undefined && (missing2 = 'ID')) {
                              validate56.errors = [
                                {
                                  instancePath:
                                    instancePath + '/Experiment/Devices/' + i0,
                                  schemaPath:
                                    '#/properties/Experiment/properties/Devices/items/required',
                                  keyword: 'required',
                                  params: { missingProperty: missing2 },
                                  message:
                                    "must have required property '" + missing2 + "'",
                                  schema:
                                    schema41.properties.Experiment.properties.Devices
                                      .items.required,
                                  parentSchema:
                                    schema41.properties.Experiment.properties.Devices
                                      .items,
                                  data: data2,
                                },
                              ];
                              return false;
                            } else {
                              if (data2.ID !== undefined) {
                                let data3 = data2.ID;
                                const _errs7 = errors;
                                if (errors === _errs7) {
                                  if (errors === _errs7) {
                                    if (typeof data3 === 'string') {
                                      if (!formats0(data3)) {
                                        validate56.errors = [
                                          {
                                            instancePath:
                                              instancePath +
                                              '/Experiment/Devices/' +
                                              i0 +
                                              '/ID',
                                            schemaPath:
                                              '#/properties/Experiment/properties/Devices/items/properties/ID/format',
                                            keyword: 'format',
                                            params: { format: 'uri' },
                                            message: 'must match format "' + 'uri' + '"',
                                            schema: 'uri',
                                            parentSchema:
                                              schema41.properties.Experiment.properties
                                                .Devices.items.properties.ID,
                                            data: data3,
                                          },
                                        ];
                                        return false;
                                      }
                                    } else {
                                      validate56.errors = [
                                        {
                                          instancePath:
                                            instancePath +
                                            '/Experiment/Devices/' +
                                            i0 +
                                            '/ID',
                                          schemaPath:
                                            '#/properties/Experiment/properties/Devices/items/properties/ID/type',
                                          keyword: 'type',
                                          params: { type: 'string' },
                                          message: 'must be string',
                                          schema:
                                            schema41.properties.Experiment.properties
                                              .Devices.items.properties.ID.type,
                                          parentSchema:
                                            schema41.properties.Experiment.properties
                                              .Devices.items.properties.ID,
                                          data: data3,
                                        },
                                      ];
                                      return false;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            validate56.errors = [
                              {
                                instancePath: instancePath + '/Experiment/Devices/' + i0,
                                schemaPath:
                                  '#/properties/Experiment/properties/Devices/items/type',
                                keyword: 'type',
                                params: { type: 'object' },
                                message: 'must be object',
                                schema:
                                  schema41.properties.Experiment.properties.Devices.items
                                    .type,
                                parentSchema:
                                  schema41.properties.Experiment.properties.Devices.items,
                                data: data2,
                              },
                            ];
                            return false;
                          }
                        }
                        var valid2 = _errs5 === errors;
                        if (!valid2) {
                          break;
                        }
                      }
                    } else {
                      validate56.errors = [
                        {
                          instancePath: instancePath + '/Experiment/Devices',
                          schemaPath: '#/properties/Experiment/properties/Devices/type',
                          keyword: 'type',
                          params: { type: 'array' },
                          message: 'must be array',
                          schema: schema41.properties.Experiment.properties.Devices.type,
                          parentSchema: schema41.properties.Experiment.properties.Devices,
                          data: data1,
                        },
                      ];
                      return false;
                    }
                  }
                  var valid1 = _errs3 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.Description !== undefined) {
                    let data4 = data0.Description;
                    const _errs9 = errors;
                    if (typeof data4 !== 'string') {
                      validate56.errors = [
                        {
                          instancePath: instancePath + '/Experiment/Description',
                          schemaPath:
                            '#/properties/Experiment/properties/Description/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema:
                            schema41.properties.Experiment.properties.Description.type,
                          parentSchema:
                            schema41.properties.Experiment.properties.Description,
                          data: data4,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs9 === errors;
                  } else {
                    var valid1 = true;
                  }
                }
              }
            } else {
              validate56.errors = [
                {
                  instancePath: instancePath + '/Experiment',
                  schemaPath: '#/properties/Experiment/type',
                  keyword: 'type',
                  params: { type: 'object' },
                  message: 'must be object',
                  schema: schema41.properties.Experiment.type,
                  parentSchema: schema41.properties.Experiment,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data5 = data.Time;
            const _errs11 = errors;
            if (errors === _errs11) {
              if (data5 && typeof data5 == 'object' && !Array.isArray(data5)) {
                let missing3;
                if (
                  (data5.Start === undefined && (missing3 = 'Start')) ||
                  (data5.End === undefined && (missing3 = 'End'))
                ) {
                  validate56.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing3 },
                      message: "must have required property '" + missing3 + "'",
                      schema: schema41.properties.Time.required,
                      parentSchema: schema41.properties.Time,
                      data: data5,
                    },
                  ];
                  return false;
                } else {
                  if (data5.Start !== undefined) {
                    let data6 = data5.Start;
                    const _errs13 = errors;
                    if (errors === _errs13) {
                      if (errors === _errs13) {
                        if (typeof data6 === 'string') {
                          if (!formats2.validate(data6)) {
                            validate56.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema41.properties.Time.properties.Start,
                                data: data6,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate56.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema41.properties.Time.properties.Start.type,
                              parentSchema: schema41.properties.Time.properties.Start,
                              data: data6,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid4 = _errs13 === errors;
                  } else {
                    var valid4 = true;
                  }
                  if (valid4) {
                    if (data5.End !== undefined) {
                      let data7 = data5.End;
                      const _errs15 = errors;
                      if (errors === _errs15) {
                        if (errors === _errs15) {
                          if (typeof data7 === 'string') {
                            if (!formats2.validate(data7)) {
                              validate56.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema41.properties.Time.properties.End,
                                  data: data7,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate56.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema41.properties.Time.properties.End.type,
                                parentSchema: schema41.properties.Time.properties.End,
                                data: data7,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid4 = _errs15 === errors;
                    } else {
                      var valid4 = true;
                    }
                  }
                }
              } else {
                validate56.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema41.properties.Time.type,
                    parentSchema: schema41.properties.Time,
                    data: data5,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs11 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Combined !== undefined) {
              let data8 = data.Combined;
              const _errs17 = errors;
              if (typeof data8 !== 'boolean') {
                validate56.errors = [
                  {
                    instancePath: instancePath + '/Combined',
                    schemaPath: '#/properties/Combined/type',
                    keyword: 'type',
                    params: { type: 'boolean' },
                    message: 'must be boolean',
                    schema: schema41.properties.Combined.type,
                    parentSchema: schema41.properties.Combined,
                    data: data8,
                  },
                ];
                return false;
              }
              var valid0 = _errs17 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.onlyOwn !== undefined) {
                let data9 = data.onlyOwn;
                const _errs19 = errors;
                if (typeof data9 !== 'boolean') {
                  validate56.errors = [
                    {
                      instancePath: instancePath + '/onlyOwn',
                      schemaPath: '#/properties/onlyOwn/type',
                      keyword: 'type',
                      params: { type: 'boolean' },
                      message: 'must be boolean',
                      schema: schema41.properties.onlyOwn.type,
                      parentSchema: schema41.properties.onlyOwn,
                      data: data9,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs19 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate56.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema41.type,
          parentSchema: schema41,
          data,
        },
      ];
      return false;
    }
  }
  validate56.errors = vErrors;
  return errors === 0;
}
exports.validateScheduleBodyResponse = validate57;
const schema42 = {
  type: 'object',
  required: ['Experiment', 'Time'],
  properties: {
    Experiment: {
      title: 'Experiment',
      description:
        'An experiment describes a set of devices and how they should be connected (potentially among other metadata).',
      type: 'object',
      required: ['Devices'],
      properties: {
        Devices: {
          type: 'array',
          description: 'List of devices used in experiment.',
          items: {
            title: 'Device',
            description:
              'A device might either be a physical/virtual device or a group of device.',
            type: 'object',
            required: ['ID'],
            properties: {
              ID: {
                type: 'string',
                description:
                  'Unique ID of the device. Contains the institution (by having an end point at that institution)',
                format: 'uri',
              },
            },
          },
        },
        Description: {
          type: 'string',
          description:
            'User provided description, for example might be a reason for the booking (e.g. maintenance) or a link to the experiment. Might be empty or missing.',
        },
      },
    },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Combined: {
      type: 'boolean',
      description:
        'If true, show only one timetable per device instead of one for all available physical devices.',
    },
    onlyOwn: {
      type: 'boolean',
      description:
        '(private) Show only devices of this institution. Give an error if a device of an other institution is requested.',
    },
  },
  'x-standalone': false,
  'x-name': 'scheduleBodyResponse',
  'x-location':
    '#/paths//schedule/post/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate57(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Experiment === undefined && (missing0 = 'Experiment')) ||
        (data.Time === undefined && (missing0 = 'Time'))
      ) {
        validate57.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema42.required,
            parentSchema: schema42,
            data,
          },
        ];
        return false;
      } else {
        if (data.Experiment !== undefined) {
          let data0 = data.Experiment;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
              let missing1;
              if (data0.Devices === undefined && (missing1 = 'Devices')) {
                validate57.errors = [
                  {
                    instancePath: instancePath + '/Experiment',
                    schemaPath: '#/properties/Experiment/required',
                    keyword: 'required',
                    params: { missingProperty: missing1 },
                    message: "must have required property '" + missing1 + "'",
                    schema: schema42.properties.Experiment.required,
                    parentSchema: schema42.properties.Experiment,
                    data: data0,
                  },
                ];
                return false;
              } else {
                if (data0.Devices !== undefined) {
                  let data1 = data0.Devices;
                  const _errs3 = errors;
                  if (errors === _errs3) {
                    if (Array.isArray(data1)) {
                      var valid2 = true;
                      const len0 = data1.length;
                      for (let i0 = 0; i0 < len0; i0++) {
                        let data2 = data1[i0];
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (
                            data2 &&
                            typeof data2 == 'object' &&
                            !Array.isArray(data2)
                          ) {
                            let missing2;
                            if (data2.ID === undefined && (missing2 = 'ID')) {
                              validate57.errors = [
                                {
                                  instancePath:
                                    instancePath + '/Experiment/Devices/' + i0,
                                  schemaPath:
                                    '#/properties/Experiment/properties/Devices/items/required',
                                  keyword: 'required',
                                  params: { missingProperty: missing2 },
                                  message:
                                    "must have required property '" + missing2 + "'",
                                  schema:
                                    schema42.properties.Experiment.properties.Devices
                                      .items.required,
                                  parentSchema:
                                    schema42.properties.Experiment.properties.Devices
                                      .items,
                                  data: data2,
                                },
                              ];
                              return false;
                            } else {
                              if (data2.ID !== undefined) {
                                let data3 = data2.ID;
                                const _errs7 = errors;
                                if (errors === _errs7) {
                                  if (errors === _errs7) {
                                    if (typeof data3 === 'string') {
                                      if (!formats0(data3)) {
                                        validate57.errors = [
                                          {
                                            instancePath:
                                              instancePath +
                                              '/Experiment/Devices/' +
                                              i0 +
                                              '/ID',
                                            schemaPath:
                                              '#/properties/Experiment/properties/Devices/items/properties/ID/format',
                                            keyword: 'format',
                                            params: { format: 'uri' },
                                            message: 'must match format "' + 'uri' + '"',
                                            schema: 'uri',
                                            parentSchema:
                                              schema42.properties.Experiment.properties
                                                .Devices.items.properties.ID,
                                            data: data3,
                                          },
                                        ];
                                        return false;
                                      }
                                    } else {
                                      validate57.errors = [
                                        {
                                          instancePath:
                                            instancePath +
                                            '/Experiment/Devices/' +
                                            i0 +
                                            '/ID',
                                          schemaPath:
                                            '#/properties/Experiment/properties/Devices/items/properties/ID/type',
                                          keyword: 'type',
                                          params: { type: 'string' },
                                          message: 'must be string',
                                          schema:
                                            schema42.properties.Experiment.properties
                                              .Devices.items.properties.ID.type,
                                          parentSchema:
                                            schema42.properties.Experiment.properties
                                              .Devices.items.properties.ID,
                                          data: data3,
                                        },
                                      ];
                                      return false;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            validate57.errors = [
                              {
                                instancePath: instancePath + '/Experiment/Devices/' + i0,
                                schemaPath:
                                  '#/properties/Experiment/properties/Devices/items/type',
                                keyword: 'type',
                                params: { type: 'object' },
                                message: 'must be object',
                                schema:
                                  schema42.properties.Experiment.properties.Devices.items
                                    .type,
                                parentSchema:
                                  schema42.properties.Experiment.properties.Devices.items,
                                data: data2,
                              },
                            ];
                            return false;
                          }
                        }
                        var valid2 = _errs5 === errors;
                        if (!valid2) {
                          break;
                        }
                      }
                    } else {
                      validate57.errors = [
                        {
                          instancePath: instancePath + '/Experiment/Devices',
                          schemaPath: '#/properties/Experiment/properties/Devices/type',
                          keyword: 'type',
                          params: { type: 'array' },
                          message: 'must be array',
                          schema: schema42.properties.Experiment.properties.Devices.type,
                          parentSchema: schema42.properties.Experiment.properties.Devices,
                          data: data1,
                        },
                      ];
                      return false;
                    }
                  }
                  var valid1 = _errs3 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.Description !== undefined) {
                    let data4 = data0.Description;
                    const _errs9 = errors;
                    if (typeof data4 !== 'string') {
                      validate57.errors = [
                        {
                          instancePath: instancePath + '/Experiment/Description',
                          schemaPath:
                            '#/properties/Experiment/properties/Description/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema:
                            schema42.properties.Experiment.properties.Description.type,
                          parentSchema:
                            schema42.properties.Experiment.properties.Description,
                          data: data4,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs9 === errors;
                  } else {
                    var valid1 = true;
                  }
                }
              }
            } else {
              validate57.errors = [
                {
                  instancePath: instancePath + '/Experiment',
                  schemaPath: '#/properties/Experiment/type',
                  keyword: 'type',
                  params: { type: 'object' },
                  message: 'must be object',
                  schema: schema42.properties.Experiment.type,
                  parentSchema: schema42.properties.Experiment,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data5 = data.Time;
            const _errs11 = errors;
            if (errors === _errs11) {
              if (data5 && typeof data5 == 'object' && !Array.isArray(data5)) {
                let missing3;
                if (
                  (data5.Start === undefined && (missing3 = 'Start')) ||
                  (data5.End === undefined && (missing3 = 'End'))
                ) {
                  validate57.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing3 },
                      message: "must have required property '" + missing3 + "'",
                      schema: schema42.properties.Time.required,
                      parentSchema: schema42.properties.Time,
                      data: data5,
                    },
                  ];
                  return false;
                } else {
                  if (data5.Start !== undefined) {
                    let data6 = data5.Start;
                    const _errs13 = errors;
                    if (errors === _errs13) {
                      if (errors === _errs13) {
                        if (typeof data6 === 'string') {
                          if (!formats2.validate(data6)) {
                            validate57.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema42.properties.Time.properties.Start,
                                data: data6,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate57.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema42.properties.Time.properties.Start.type,
                              parentSchema: schema42.properties.Time.properties.Start,
                              data: data6,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid4 = _errs13 === errors;
                  } else {
                    var valid4 = true;
                  }
                  if (valid4) {
                    if (data5.End !== undefined) {
                      let data7 = data5.End;
                      const _errs15 = errors;
                      if (errors === _errs15) {
                        if (errors === _errs15) {
                          if (typeof data7 === 'string') {
                            if (!formats2.validate(data7)) {
                              validate57.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema42.properties.Time.properties.End,
                                  data: data7,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate57.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema42.properties.Time.properties.End.type,
                                parentSchema: schema42.properties.Time.properties.End,
                                data: data7,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid4 = _errs15 === errors;
                    } else {
                      var valid4 = true;
                    }
                  }
                }
              } else {
                validate57.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema42.properties.Time.type,
                    parentSchema: schema42.properties.Time,
                    data: data5,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs11 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Combined !== undefined) {
              let data8 = data.Combined;
              const _errs17 = errors;
              if (typeof data8 !== 'boolean') {
                validate57.errors = [
                  {
                    instancePath: instancePath + '/Combined',
                    schemaPath: '#/properties/Combined/type',
                    keyword: 'type',
                    params: { type: 'boolean' },
                    message: 'must be boolean',
                    schema: schema42.properties.Combined.type,
                    parentSchema: schema42.properties.Combined,
                    data: data8,
                  },
                ];
                return false;
              }
              var valid0 = _errs17 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.onlyOwn !== undefined) {
                let data9 = data.onlyOwn;
                const _errs19 = errors;
                if (typeof data9 !== 'boolean') {
                  validate57.errors = [
                    {
                      instancePath: instancePath + '/onlyOwn',
                      schemaPath: '#/properties/onlyOwn/type',
                      keyword: 'type',
                      params: { type: 'boolean' },
                      message: 'must be boolean',
                      schema: schema42.properties.onlyOwn.type,
                      parentSchema: schema42.properties.onlyOwn,
                      data: data9,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs19 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate57.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema42.type,
          parentSchema: schema42,
          data,
        },
      ];
      return false;
    }
  }
  validate57.errors = vErrors;
  return errors === 0;
}
exports.validateScheduleResponse200Request = validate58;
const schema43 = {
  type: 'array',
  items: {
    type: 'object',
    required: ['Device', 'Booked', 'Free'],
    properties: {
      Device: { type: 'string', description: 'ID of the device (or * if combined).' },
      Booked: {
        type: 'array',
        description: 'Array of booked times.',
        items: {
          title: 'Timeslot',
          description: 'A time slot represents a slice of time used for bookings.',
          type: 'object',
          required: ['Start', 'End'],
          properties: {
            Start: {
              type: 'string',
              description: 'Start time of the booking.',
              format: 'date-time',
            },
            End: {
              type: 'string',
              description: 'End time of the booking.',
              format: 'date-time',
            },
          },
        },
      },
      Free: {
        type: 'array',
        description: 'Array of free times.',
        items: {
          title: 'Timeslot',
          description: 'A time slot represents a slice of time used for bookings.',
          type: 'object',
          required: ['Start', 'End'],
          properties: {
            Start: {
              type: 'string',
              description: 'Start time of the booking.',
              format: 'date-time',
            },
            End: {
              type: 'string',
              description: 'End time of the booking.',
              format: 'date-time',
            },
          },
        },
      },
    },
  },
  'x-standalone': false,
  'x-name': 'scheduleResponse200Request',
  'x-location':
    '#/paths//schedule/post/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate58(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.Device === undefined && (missing0 = 'Device')) ||
              (data0.Booked === undefined && (missing0 = 'Booked')) ||
              (data0.Free === undefined && (missing0 = 'Free'))
            ) {
              validate58.errors = [
                {
                  instancePath: instancePath + '/' + i0,
                  schemaPath: '#/items/required',
                  keyword: 'required',
                  params: { missingProperty: missing0 },
                  message: "must have required property '" + missing0 + "'",
                  schema: schema43.items.required,
                  parentSchema: schema43.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.Device !== undefined) {
                let data1 = data0.Device;
                const _errs3 = errors;
                if (typeof data1 !== 'string') {
                  validate58.errors = [
                    {
                      instancePath: instancePath + '/' + i0 + '/Device',
                      schemaPath: '#/items/properties/Device/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema43.items.properties.Device.type,
                      parentSchema: schema43.items.properties.Device,
                      data: data1,
                    },
                  ];
                  return false;
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.Booked !== undefined) {
                  let data2 = data0.Booked;
                  const _errs5 = errors;
                  if (errors === _errs5) {
                    if (Array.isArray(data2)) {
                      var valid2 = true;
                      const len1 = data2.length;
                      for (let i1 = 0; i1 < len1; i1++) {
                        let data3 = data2[i1];
                        const _errs7 = errors;
                        if (errors === _errs7) {
                          if (
                            data3 &&
                            typeof data3 == 'object' &&
                            !Array.isArray(data3)
                          ) {
                            let missing1;
                            if (
                              (data3.Start === undefined && (missing1 = 'Start')) ||
                              (data3.End === undefined && (missing1 = 'End'))
                            ) {
                              validate58.errors = [
                                {
                                  instancePath: instancePath + '/' + i0 + '/Booked/' + i1,
                                  schemaPath: '#/items/properties/Booked/items/required',
                                  keyword: 'required',
                                  params: { missingProperty: missing1 },
                                  message:
                                    "must have required property '" + missing1 + "'",
                                  schema: schema43.items.properties.Booked.items.required,
                                  parentSchema: schema43.items.properties.Booked.items,
                                  data: data3,
                                },
                              ];
                              return false;
                            } else {
                              if (data3.Start !== undefined) {
                                let data4 = data3.Start;
                                const _errs9 = errors;
                                if (errors === _errs9) {
                                  if (errors === _errs9) {
                                    if (typeof data4 === 'string') {
                                      if (!formats2.validate(data4)) {
                                        validate58.errors = [
                                          {
                                            instancePath:
                                              instancePath +
                                              '/' +
                                              i0 +
                                              '/Booked/' +
                                              i1 +
                                              '/Start',
                                            schemaPath:
                                              '#/items/properties/Booked/items/properties/Start/format',
                                            keyword: 'format',
                                            params: { format: 'date-time' },
                                            message:
                                              'must match format "' + 'date-time' + '"',
                                            schema: 'date-time',
                                            parentSchema:
                                              schema43.items.properties.Booked.items
                                                .properties.Start,
                                            data: data4,
                                          },
                                        ];
                                        return false;
                                      }
                                    } else {
                                      validate58.errors = [
                                        {
                                          instancePath:
                                            instancePath +
                                            '/' +
                                            i0 +
                                            '/Booked/' +
                                            i1 +
                                            '/Start',
                                          schemaPath:
                                            '#/items/properties/Booked/items/properties/Start/type',
                                          keyword: 'type',
                                          params: { type: 'string' },
                                          message: 'must be string',
                                          schema:
                                            schema43.items.properties.Booked.items
                                              .properties.Start.type,
                                          parentSchema:
                                            schema43.items.properties.Booked.items
                                              .properties.Start,
                                          data: data4,
                                        },
                                      ];
                                      return false;
                                    }
                                  }
                                }
                                var valid3 = _errs9 === errors;
                              } else {
                                var valid3 = true;
                              }
                              if (valid3) {
                                if (data3.End !== undefined) {
                                  let data5 = data3.End;
                                  const _errs11 = errors;
                                  if (errors === _errs11) {
                                    if (errors === _errs11) {
                                      if (typeof data5 === 'string') {
                                        if (!formats2.validate(data5)) {
                                          validate58.errors = [
                                            {
                                              instancePath:
                                                instancePath +
                                                '/' +
                                                i0 +
                                                '/Booked/' +
                                                i1 +
                                                '/End',
                                              schemaPath:
                                                '#/items/properties/Booked/items/properties/End/format',
                                              keyword: 'format',
                                              params: { format: 'date-time' },
                                              message:
                                                'must match format "' + 'date-time' + '"',
                                              schema: 'date-time',
                                              parentSchema:
                                                schema43.items.properties.Booked.items
                                                  .properties.End,
                                              data: data5,
                                            },
                                          ];
                                          return false;
                                        }
                                      } else {
                                        validate58.errors = [
                                          {
                                            instancePath:
                                              instancePath +
                                              '/' +
                                              i0 +
                                              '/Booked/' +
                                              i1 +
                                              '/End',
                                            schemaPath:
                                              '#/items/properties/Booked/items/properties/End/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                            schema:
                                              schema43.items.properties.Booked.items
                                                .properties.End.type,
                                            parentSchema:
                                              schema43.items.properties.Booked.items
                                                .properties.End,
                                            data: data5,
                                          },
                                        ];
                                        return false;
                                      }
                                    }
                                  }
                                  var valid3 = _errs11 === errors;
                                } else {
                                  var valid3 = true;
                                }
                              }
                            }
                          } else {
                            validate58.errors = [
                              {
                                instancePath: instancePath + '/' + i0 + '/Booked/' + i1,
                                schemaPath: '#/items/properties/Booked/items/type',
                                keyword: 'type',
                                params: { type: 'object' },
                                message: 'must be object',
                                schema: schema43.items.properties.Booked.items.type,
                                parentSchema: schema43.items.properties.Booked.items,
                                data: data3,
                              },
                            ];
                            return false;
                          }
                        }
                        var valid2 = _errs7 === errors;
                        if (!valid2) {
                          break;
                        }
                      }
                    } else {
                      validate58.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/Booked',
                          schemaPath: '#/items/properties/Booked/type',
                          keyword: 'type',
                          params: { type: 'array' },
                          message: 'must be array',
                          schema: schema43.items.properties.Booked.type,
                          parentSchema: schema43.items.properties.Booked,
                          data: data2,
                        },
                      ];
                      return false;
                    }
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.Free !== undefined) {
                    let data6 = data0.Free;
                    const _errs13 = errors;
                    if (errors === _errs13) {
                      if (Array.isArray(data6)) {
                        var valid4 = true;
                        const len2 = data6.length;
                        for (let i2 = 0; i2 < len2; i2++) {
                          let data7 = data6[i2];
                          const _errs15 = errors;
                          if (errors === _errs15) {
                            if (
                              data7 &&
                              typeof data7 == 'object' &&
                              !Array.isArray(data7)
                            ) {
                              let missing2;
                              if (
                                (data7.Start === undefined && (missing2 = 'Start')) ||
                                (data7.End === undefined && (missing2 = 'End'))
                              ) {
                                validate58.errors = [
                                  {
                                    instancePath: instancePath + '/' + i0 + '/Free/' + i2,
                                    schemaPath: '#/items/properties/Free/items/required',
                                    keyword: 'required',
                                    params: { missingProperty: missing2 },
                                    message:
                                      "must have required property '" + missing2 + "'",
                                    schema: schema43.items.properties.Free.items.required,
                                    parentSchema: schema43.items.properties.Free.items,
                                    data: data7,
                                  },
                                ];
                                return false;
                              } else {
                                if (data7.Start !== undefined) {
                                  let data8 = data7.Start;
                                  const _errs17 = errors;
                                  if (errors === _errs17) {
                                    if (errors === _errs17) {
                                      if (typeof data8 === 'string') {
                                        if (!formats2.validate(data8)) {
                                          validate58.errors = [
                                            {
                                              instancePath:
                                                instancePath +
                                                '/' +
                                                i0 +
                                                '/Free/' +
                                                i2 +
                                                '/Start',
                                              schemaPath:
                                                '#/items/properties/Free/items/properties/Start/format',
                                              keyword: 'format',
                                              params: { format: 'date-time' },
                                              message:
                                                'must match format "' + 'date-time' + '"',
                                              schema: 'date-time',
                                              parentSchema:
                                                schema43.items.properties.Free.items
                                                  .properties.Start,
                                              data: data8,
                                            },
                                          ];
                                          return false;
                                        }
                                      } else {
                                        validate58.errors = [
                                          {
                                            instancePath:
                                              instancePath +
                                              '/' +
                                              i0 +
                                              '/Free/' +
                                              i2 +
                                              '/Start',
                                            schemaPath:
                                              '#/items/properties/Free/items/properties/Start/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                            schema:
                                              schema43.items.properties.Free.items
                                                .properties.Start.type,
                                            parentSchema:
                                              schema43.items.properties.Free.items
                                                .properties.Start,
                                            data: data8,
                                          },
                                        ];
                                        return false;
                                      }
                                    }
                                  }
                                  var valid5 = _errs17 === errors;
                                } else {
                                  var valid5 = true;
                                }
                                if (valid5) {
                                  if (data7.End !== undefined) {
                                    let data9 = data7.End;
                                    const _errs19 = errors;
                                    if (errors === _errs19) {
                                      if (errors === _errs19) {
                                        if (typeof data9 === 'string') {
                                          if (!formats2.validate(data9)) {
                                            validate58.errors = [
                                              {
                                                instancePath:
                                                  instancePath +
                                                  '/' +
                                                  i0 +
                                                  '/Free/' +
                                                  i2 +
                                                  '/End',
                                                schemaPath:
                                                  '#/items/properties/Free/items/properties/End/format',
                                                keyword: 'format',
                                                params: { format: 'date-time' },
                                                message:
                                                  'must match format "' +
                                                  'date-time' +
                                                  '"',
                                                schema: 'date-time',
                                                parentSchema:
                                                  schema43.items.properties.Free.items
                                                    .properties.End,
                                                data: data9,
                                              },
                                            ];
                                            return false;
                                          }
                                        } else {
                                          validate58.errors = [
                                            {
                                              instancePath:
                                                instancePath +
                                                '/' +
                                                i0 +
                                                '/Free/' +
                                                i2 +
                                                '/End',
                                              schemaPath:
                                                '#/items/properties/Free/items/properties/End/type',
                                              keyword: 'type',
                                              params: { type: 'string' },
                                              message: 'must be string',
                                              schema:
                                                schema43.items.properties.Free.items
                                                  .properties.End.type,
                                              parentSchema:
                                                schema43.items.properties.Free.items
                                                  .properties.End,
                                              data: data9,
                                            },
                                          ];
                                          return false;
                                        }
                                      }
                                    }
                                    var valid5 = _errs19 === errors;
                                  } else {
                                    var valid5 = true;
                                  }
                                }
                              }
                            } else {
                              validate58.errors = [
                                {
                                  instancePath: instancePath + '/' + i0 + '/Free/' + i2,
                                  schemaPath: '#/items/properties/Free/items/type',
                                  keyword: 'type',
                                  params: { type: 'object' },
                                  message: 'must be object',
                                  schema: schema43.items.properties.Free.items.type,
                                  parentSchema: schema43.items.properties.Free.items,
                                  data: data7,
                                },
                              ];
                              return false;
                            }
                          }
                          var valid4 = _errs15 === errors;
                          if (!valid4) {
                            break;
                          }
                        }
                      } else {
                        validate58.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/Free',
                            schemaPath: '#/items/properties/Free/type',
                            keyword: 'type',
                            params: { type: 'array' },
                            message: 'must be array',
                            schema: schema43.items.properties.Free.type,
                            parentSchema: schema43.items.properties.Free,
                            data: data6,
                          },
                        ];
                        return false;
                      }
                    }
                    var valid1 = _errs13 === errors;
                  } else {
                    var valid1 = true;
                  }
                }
              }
            }
          } else {
            validate58.errors = [
              {
                instancePath: instancePath + '/' + i0,
                schemaPath: '#/items/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema43.items.type,
                parentSchema: schema43.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate58.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
          schema: schema43.type,
          parentSchema: schema43,
          data,
        },
      ];
      return false;
    }
  }
  validate58.errors = vErrors;
  return errors === 0;
}
exports.validateScheduleResponse200Response = validate59;
const schema44 = {
  type: 'array',
  items: {
    type: 'object',
    required: ['Device', 'Booked', 'Free'],
    properties: {
      Device: { type: 'string', description: 'ID of the device (or * if combined).' },
      Booked: {
        type: 'array',
        description: 'Array of booked times.',
        items: {
          title: 'Timeslot',
          description: 'A time slot represents a slice of time used for bookings.',
          type: 'object',
          required: ['Start', 'End'],
          properties: {
            Start: {
              type: 'string',
              description: 'Start time of the booking.',
              format: 'date-time',
            },
            End: {
              type: 'string',
              description: 'End time of the booking.',
              format: 'date-time',
            },
          },
        },
      },
      Free: {
        type: 'array',
        description: 'Array of free times.',
        items: {
          title: 'Timeslot',
          description: 'A time slot represents a slice of time used for bookings.',
          type: 'object',
          required: ['Start', 'End'],
          properties: {
            Start: {
              type: 'string',
              description: 'Start time of the booking.',
              format: 'date-time',
            },
            End: {
              type: 'string',
              description: 'End time of the booking.',
              format: 'date-time',
            },
          },
        },
      },
    },
  },
  'x-standalone': false,
  'x-name': 'scheduleResponse200Response',
  'x-location':
    '#/paths//schedule/post/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate59(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.Device === undefined && (missing0 = 'Device')) ||
              (data0.Booked === undefined && (missing0 = 'Booked')) ||
              (data0.Free === undefined && (missing0 = 'Free'))
            ) {
              validate59.errors = [
                {
                  instancePath: instancePath + '/' + i0,
                  schemaPath: '#/items/required',
                  keyword: 'required',
                  params: { missingProperty: missing0 },
                  message: "must have required property '" + missing0 + "'",
                  schema: schema44.items.required,
                  parentSchema: schema44.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.Device !== undefined) {
                let data1 = data0.Device;
                const _errs3 = errors;
                if (typeof data1 !== 'string') {
                  validate59.errors = [
                    {
                      instancePath: instancePath + '/' + i0 + '/Device',
                      schemaPath: '#/items/properties/Device/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema44.items.properties.Device.type,
                      parentSchema: schema44.items.properties.Device,
                      data: data1,
                    },
                  ];
                  return false;
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.Booked !== undefined) {
                  let data2 = data0.Booked;
                  const _errs5 = errors;
                  if (errors === _errs5) {
                    if (Array.isArray(data2)) {
                      var valid2 = true;
                      const len1 = data2.length;
                      for (let i1 = 0; i1 < len1; i1++) {
                        let data3 = data2[i1];
                        const _errs7 = errors;
                        if (errors === _errs7) {
                          if (
                            data3 &&
                            typeof data3 == 'object' &&
                            !Array.isArray(data3)
                          ) {
                            let missing1;
                            if (
                              (data3.Start === undefined && (missing1 = 'Start')) ||
                              (data3.End === undefined && (missing1 = 'End'))
                            ) {
                              validate59.errors = [
                                {
                                  instancePath: instancePath + '/' + i0 + '/Booked/' + i1,
                                  schemaPath: '#/items/properties/Booked/items/required',
                                  keyword: 'required',
                                  params: { missingProperty: missing1 },
                                  message:
                                    "must have required property '" + missing1 + "'",
                                  schema: schema44.items.properties.Booked.items.required,
                                  parentSchema: schema44.items.properties.Booked.items,
                                  data: data3,
                                },
                              ];
                              return false;
                            } else {
                              if (data3.Start !== undefined) {
                                let data4 = data3.Start;
                                const _errs9 = errors;
                                if (errors === _errs9) {
                                  if (errors === _errs9) {
                                    if (typeof data4 === 'string') {
                                      if (!formats2.validate(data4)) {
                                        validate59.errors = [
                                          {
                                            instancePath:
                                              instancePath +
                                              '/' +
                                              i0 +
                                              '/Booked/' +
                                              i1 +
                                              '/Start',
                                            schemaPath:
                                              '#/items/properties/Booked/items/properties/Start/format',
                                            keyword: 'format',
                                            params: { format: 'date-time' },
                                            message:
                                              'must match format "' + 'date-time' + '"',
                                            schema: 'date-time',
                                            parentSchema:
                                              schema44.items.properties.Booked.items
                                                .properties.Start,
                                            data: data4,
                                          },
                                        ];
                                        return false;
                                      }
                                    } else {
                                      validate59.errors = [
                                        {
                                          instancePath:
                                            instancePath +
                                            '/' +
                                            i0 +
                                            '/Booked/' +
                                            i1 +
                                            '/Start',
                                          schemaPath:
                                            '#/items/properties/Booked/items/properties/Start/type',
                                          keyword: 'type',
                                          params: { type: 'string' },
                                          message: 'must be string',
                                          schema:
                                            schema44.items.properties.Booked.items
                                              .properties.Start.type,
                                          parentSchema:
                                            schema44.items.properties.Booked.items
                                              .properties.Start,
                                          data: data4,
                                        },
                                      ];
                                      return false;
                                    }
                                  }
                                }
                                var valid3 = _errs9 === errors;
                              } else {
                                var valid3 = true;
                              }
                              if (valid3) {
                                if (data3.End !== undefined) {
                                  let data5 = data3.End;
                                  const _errs11 = errors;
                                  if (errors === _errs11) {
                                    if (errors === _errs11) {
                                      if (typeof data5 === 'string') {
                                        if (!formats2.validate(data5)) {
                                          validate59.errors = [
                                            {
                                              instancePath:
                                                instancePath +
                                                '/' +
                                                i0 +
                                                '/Booked/' +
                                                i1 +
                                                '/End',
                                              schemaPath:
                                                '#/items/properties/Booked/items/properties/End/format',
                                              keyword: 'format',
                                              params: { format: 'date-time' },
                                              message:
                                                'must match format "' + 'date-time' + '"',
                                              schema: 'date-time',
                                              parentSchema:
                                                schema44.items.properties.Booked.items
                                                  .properties.End,
                                              data: data5,
                                            },
                                          ];
                                          return false;
                                        }
                                      } else {
                                        validate59.errors = [
                                          {
                                            instancePath:
                                              instancePath +
                                              '/' +
                                              i0 +
                                              '/Booked/' +
                                              i1 +
                                              '/End',
                                            schemaPath:
                                              '#/items/properties/Booked/items/properties/End/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                            schema:
                                              schema44.items.properties.Booked.items
                                                .properties.End.type,
                                            parentSchema:
                                              schema44.items.properties.Booked.items
                                                .properties.End,
                                            data: data5,
                                          },
                                        ];
                                        return false;
                                      }
                                    }
                                  }
                                  var valid3 = _errs11 === errors;
                                } else {
                                  var valid3 = true;
                                }
                              }
                            }
                          } else {
                            validate59.errors = [
                              {
                                instancePath: instancePath + '/' + i0 + '/Booked/' + i1,
                                schemaPath: '#/items/properties/Booked/items/type',
                                keyword: 'type',
                                params: { type: 'object' },
                                message: 'must be object',
                                schema: schema44.items.properties.Booked.items.type,
                                parentSchema: schema44.items.properties.Booked.items,
                                data: data3,
                              },
                            ];
                            return false;
                          }
                        }
                        var valid2 = _errs7 === errors;
                        if (!valid2) {
                          break;
                        }
                      }
                    } else {
                      validate59.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/Booked',
                          schemaPath: '#/items/properties/Booked/type',
                          keyword: 'type',
                          params: { type: 'array' },
                          message: 'must be array',
                          schema: schema44.items.properties.Booked.type,
                          parentSchema: schema44.items.properties.Booked,
                          data: data2,
                        },
                      ];
                      return false;
                    }
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.Free !== undefined) {
                    let data6 = data0.Free;
                    const _errs13 = errors;
                    if (errors === _errs13) {
                      if (Array.isArray(data6)) {
                        var valid4 = true;
                        const len2 = data6.length;
                        for (let i2 = 0; i2 < len2; i2++) {
                          let data7 = data6[i2];
                          const _errs15 = errors;
                          if (errors === _errs15) {
                            if (
                              data7 &&
                              typeof data7 == 'object' &&
                              !Array.isArray(data7)
                            ) {
                              let missing2;
                              if (
                                (data7.Start === undefined && (missing2 = 'Start')) ||
                                (data7.End === undefined && (missing2 = 'End'))
                              ) {
                                validate59.errors = [
                                  {
                                    instancePath: instancePath + '/' + i0 + '/Free/' + i2,
                                    schemaPath: '#/items/properties/Free/items/required',
                                    keyword: 'required',
                                    params: { missingProperty: missing2 },
                                    message:
                                      "must have required property '" + missing2 + "'",
                                    schema: schema44.items.properties.Free.items.required,
                                    parentSchema: schema44.items.properties.Free.items,
                                    data: data7,
                                  },
                                ];
                                return false;
                              } else {
                                if (data7.Start !== undefined) {
                                  let data8 = data7.Start;
                                  const _errs17 = errors;
                                  if (errors === _errs17) {
                                    if (errors === _errs17) {
                                      if (typeof data8 === 'string') {
                                        if (!formats2.validate(data8)) {
                                          validate59.errors = [
                                            {
                                              instancePath:
                                                instancePath +
                                                '/' +
                                                i0 +
                                                '/Free/' +
                                                i2 +
                                                '/Start',
                                              schemaPath:
                                                '#/items/properties/Free/items/properties/Start/format',
                                              keyword: 'format',
                                              params: { format: 'date-time' },
                                              message:
                                                'must match format "' + 'date-time' + '"',
                                              schema: 'date-time',
                                              parentSchema:
                                                schema44.items.properties.Free.items
                                                  .properties.Start,
                                              data: data8,
                                            },
                                          ];
                                          return false;
                                        }
                                      } else {
                                        validate59.errors = [
                                          {
                                            instancePath:
                                              instancePath +
                                              '/' +
                                              i0 +
                                              '/Free/' +
                                              i2 +
                                              '/Start',
                                            schemaPath:
                                              '#/items/properties/Free/items/properties/Start/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                            schema:
                                              schema44.items.properties.Free.items
                                                .properties.Start.type,
                                            parentSchema:
                                              schema44.items.properties.Free.items
                                                .properties.Start,
                                            data: data8,
                                          },
                                        ];
                                        return false;
                                      }
                                    }
                                  }
                                  var valid5 = _errs17 === errors;
                                } else {
                                  var valid5 = true;
                                }
                                if (valid5) {
                                  if (data7.End !== undefined) {
                                    let data9 = data7.End;
                                    const _errs19 = errors;
                                    if (errors === _errs19) {
                                      if (errors === _errs19) {
                                        if (typeof data9 === 'string') {
                                          if (!formats2.validate(data9)) {
                                            validate59.errors = [
                                              {
                                                instancePath:
                                                  instancePath +
                                                  '/' +
                                                  i0 +
                                                  '/Free/' +
                                                  i2 +
                                                  '/End',
                                                schemaPath:
                                                  '#/items/properties/Free/items/properties/End/format',
                                                keyword: 'format',
                                                params: { format: 'date-time' },
                                                message:
                                                  'must match format "' +
                                                  'date-time' +
                                                  '"',
                                                schema: 'date-time',
                                                parentSchema:
                                                  schema44.items.properties.Free.items
                                                    .properties.End,
                                                data: data9,
                                              },
                                            ];
                                            return false;
                                          }
                                        } else {
                                          validate59.errors = [
                                            {
                                              instancePath:
                                                instancePath +
                                                '/' +
                                                i0 +
                                                '/Free/' +
                                                i2 +
                                                '/End',
                                              schemaPath:
                                                '#/items/properties/Free/items/properties/End/type',
                                              keyword: 'type',
                                              params: { type: 'string' },
                                              message: 'must be string',
                                              schema:
                                                schema44.items.properties.Free.items
                                                  .properties.End.type,
                                              parentSchema:
                                                schema44.items.properties.Free.items
                                                  .properties.End,
                                              data: data9,
                                            },
                                          ];
                                          return false;
                                        }
                                      }
                                    }
                                    var valid5 = _errs19 === errors;
                                  } else {
                                    var valid5 = true;
                                  }
                                }
                              }
                            } else {
                              validate59.errors = [
                                {
                                  instancePath: instancePath + '/' + i0 + '/Free/' + i2,
                                  schemaPath: '#/items/properties/Free/items/type',
                                  keyword: 'type',
                                  params: { type: 'object' },
                                  message: 'must be object',
                                  schema: schema44.items.properties.Free.items.type,
                                  parentSchema: schema44.items.properties.Free.items,
                                  data: data7,
                                },
                              ];
                              return false;
                            }
                          }
                          var valid4 = _errs15 === errors;
                          if (!valid4) {
                            break;
                          }
                        }
                      } else {
                        validate59.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/Free',
                            schemaPath: '#/items/properties/Free/type',
                            keyword: 'type',
                            params: { type: 'array' },
                            message: 'must be array',
                            schema: schema44.items.properties.Free.type,
                            parentSchema: schema44.items.properties.Free,
                            data: data6,
                          },
                        ];
                        return false;
                      }
                    }
                    var valid1 = _errs13 === errors;
                  } else {
                    var valid1 = true;
                  }
                }
              }
            }
          } else {
            validate59.errors = [
              {
                instancePath: instancePath + '/' + i0,
                schemaPath: '#/items/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema44.items.type,
                parentSchema: schema44.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate59.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
          schema: schema44.type,
          parentSchema: schema44,
          data,
        },
      ];
      return false;
    }
  }
  validate59.errors = vErrors;
  return errors === 0;
}
exports.validateScheduleResponse404Request = validate60;
const schema45 = {
  type: 'string',
  description: 'First unknown device ID.',
  'x-standalone': false,
  'x-name': 'scheduleResponse404Request',
  'x-location':
    '#/paths//schedule/post/responses/404/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate60(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate60.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema45.type,
        parentSchema: schema45,
        data,
      },
    ];
    return false;
  }
  validate60.errors = vErrors;
  return errors === 0;
}
exports.validateScheduleResponse404Response = validate61;
const schema46 = {
  type: 'string',
  description: 'First unknown device ID.',
  'x-standalone': false,
  'x-name': 'scheduleResponse404Response',
  'x-location':
    '#/paths//schedule/post/responses/404/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate61(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate61.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema46.type,
        parentSchema: schema46,
        data,
      },
    ];
    return false;
  }
  validate61.errors = vErrors;
  return errors === 0;
}
exports.validateScheduleResponse422Request = validate62;
const schema47 = {
  type: 'string',
  description: 'First virtual device ID.',
  'x-standalone': false,
  'x-name': 'scheduleResponse422Request',
  'x-location':
    '#/paths//schedule/post/responses/422/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate62(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate62.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema47.type,
        parentSchema: schema47,
        data,
      },
    ];
    return false;
  }
  validate62.errors = vErrors;
  return errors === 0;
}
exports.validateScheduleResponse422Response = validate63;
const schema48 = {
  type: 'string',
  description: 'First virtual device ID.',
  'x-standalone': false,
  'x-name': 'scheduleResponse422Response',
  'x-location':
    '#/paths//schedule/post/responses/422/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate63(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate63.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema48.type,
        parentSchema: schema48,
        data,
      },
    ];
    return false;
  }
  validate63.errors = vErrors;
  return errors === 0;
}
exports.validateScheduleResponse500Request = validate64;
const schema49 = {
  type: 'string',
  description: 'Error description.',
  'x-standalone': false,
  'x-name': 'scheduleResponse500Request',
  'x-location':
    '#/paths//schedule/post/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate64(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate64.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema49.type,
        parentSchema: schema49,
        data,
      },
    ];
    return false;
  }
  validate64.errors = vErrors;
  return errors === 0;
}
exports.validateScheduleResponse500Response = validate65;
const schema50 = {
  type: 'string',
  description: 'Error description.',
  'x-standalone': false,
  'x-name': 'scheduleResponse500Response',
  'x-location':
    '#/paths//schedule/post/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate65(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate65.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema50.type,
        parentSchema: schema50,
        data,
      },
    ];
    return false;
  }
  validate65.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingBodyRequest = validate66;
const schema51 = {
  type: 'object',
  required: ['Devices', 'Time'],
  properties: {
    Devices: {
      type: 'array',
      description: 'List of devices which should be added.',
      items: {
        title: 'Device',
        description:
          'A device might either be a physical/virtual device or a group of device.',
        type: 'object',
        required: ['ID'],
        properties: {
          ID: {
            type: 'string',
            description:
              'Unique ID of the device. Contains the institution (by having an end point at that institution)',
            format: 'uri',
          },
        },
      },
    },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Type: {
      description:
        "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
      type: 'string',
      enum: ['normal'],
    },
  },
  'x-standalone': false,
  'x-name': 'newBookingBodyRequest',
  'x-location':
    '#/paths//booking/post/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate66(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Devices === undefined && (missing0 = 'Devices')) ||
        (data.Time === undefined && (missing0 = 'Time'))
      ) {
        validate66.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema51.required,
            parentSchema: schema51,
            data,
          },
        ];
        return false;
      } else {
        if (data.Devices !== undefined) {
          let data0 = data.Devices;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (Array.isArray(data0)) {
              var valid1 = true;
              const len0 = data0.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data1 = data0[i0];
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                    let missing1;
                    if (data1.ID === undefined && (missing1 = 'ID')) {
                      validate66.errors = [
                        {
                          instancePath: instancePath + '/Devices/' + i0,
                          schemaPath: '#/properties/Devices/items/required',
                          keyword: 'required',
                          params: { missingProperty: missing1 },
                          message: "must have required property '" + missing1 + "'",
                          schema: schema51.properties.Devices.items.required,
                          parentSchema: schema51.properties.Devices.items,
                          data: data1,
                        },
                      ];
                      return false;
                    } else {
                      if (data1.ID !== undefined) {
                        let data2 = data1.ID;
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (errors === _errs5) {
                            if (typeof data2 === 'string') {
                              if (!formats0(data2)) {
                                validate66.errors = [
                                  {
                                    instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                    schemaPath:
                                      '#/properties/Devices/items/properties/ID/format',
                                    keyword: 'format',
                                    params: { format: 'uri' },
                                    message: 'must match format "' + 'uri' + '"',
                                    schema: 'uri',
                                    parentSchema:
                                      schema51.properties.Devices.items.properties.ID,
                                    data: data2,
                                  },
                                ];
                                return false;
                              }
                            } else {
                              validate66.errors = [
                                {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/properties/Devices/items/properties/ID/type',
                                  keyword: 'type',
                                  params: { type: 'string' },
                                  message: 'must be string',
                                  schema:
                                    schema51.properties.Devices.items.properties.ID.type,
                                  parentSchema:
                                    schema51.properties.Devices.items.properties.ID,
                                  data: data2,
                                },
                              ];
                              return false;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate66.errors = [
                      {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/properties/Devices/items/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                        schema: schema51.properties.Devices.items.type,
                        parentSchema: schema51.properties.Devices.items,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                }
                var valid1 = _errs3 === errors;
                if (!valid1) {
                  break;
                }
              }
            } else {
              validate66.errors = [
                {
                  instancePath: instancePath + '/Devices',
                  schemaPath: '#/properties/Devices/type',
                  keyword: 'type',
                  params: { type: 'array' },
                  message: 'must be array',
                  schema: schema51.properties.Devices.type,
                  parentSchema: schema51.properties.Devices,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data3 = data.Time;
            const _errs7 = errors;
            if (errors === _errs7) {
              if (data3 && typeof data3 == 'object' && !Array.isArray(data3)) {
                let missing2;
                if (
                  (data3.Start === undefined && (missing2 = 'Start')) ||
                  (data3.End === undefined && (missing2 = 'End'))
                ) {
                  validate66.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing2 },
                      message: "must have required property '" + missing2 + "'",
                      schema: schema51.properties.Time.required,
                      parentSchema: schema51.properties.Time,
                      data: data3,
                    },
                  ];
                  return false;
                } else {
                  if (data3.Start !== undefined) {
                    let data4 = data3.Start;
                    const _errs9 = errors;
                    if (errors === _errs9) {
                      if (errors === _errs9) {
                        if (typeof data4 === 'string') {
                          if (!formats2.validate(data4)) {
                            validate66.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema51.properties.Time.properties.Start,
                                data: data4,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate66.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema51.properties.Time.properties.Start.type,
                              parentSchema: schema51.properties.Time.properties.Start,
                              data: data4,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid3 = _errs9 === errors;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data3.End !== undefined) {
                      let data5 = data3.End;
                      const _errs11 = errors;
                      if (errors === _errs11) {
                        if (errors === _errs11) {
                          if (typeof data5 === 'string') {
                            if (!formats2.validate(data5)) {
                              validate66.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema51.properties.Time.properties.End,
                                  data: data5,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate66.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema51.properties.Time.properties.End.type,
                                parentSchema: schema51.properties.Time.properties.End,
                                data: data5,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid3 = _errs11 === errors;
                    } else {
                      var valid3 = true;
                    }
                  }
                }
              } else {
                validate66.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema51.properties.Time.type,
                    parentSchema: schema51.properties.Time,
                    data: data3,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs7 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Type !== undefined) {
              let data6 = data.Type;
              const _errs13 = errors;
              if (typeof data6 !== 'string') {
                validate66.errors = [
                  {
                    instancePath: instancePath + '/Type',
                    schemaPath: '#/properties/Type/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema51.properties.Type.type,
                    parentSchema: schema51.properties.Type,
                    data: data6,
                  },
                ];
                return false;
              }
              if (!(data6 === 'normal')) {
                validate66.errors = [
                  {
                    instancePath: instancePath + '/Type',
                    schemaPath: '#/properties/Type/enum',
                    keyword: 'enum',
                    params: { allowedValues: schema51.properties.Type.enum },
                    message: 'must be equal to one of the allowed values',
                    schema: schema51.properties.Type.enum,
                    parentSchema: schema51.properties.Type,
                    data: data6,
                  },
                ];
                return false;
              }
              var valid0 = _errs13 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate66.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema51.type,
          parentSchema: schema51,
          data,
        },
      ];
      return false;
    }
  }
  validate66.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingBodyResponse = validate67;
const schema52 = {
  type: 'object',
  required: ['Devices', 'Time'],
  properties: {
    Devices: {
      type: 'array',
      description: 'List of devices which should be added.',
      items: {
        title: 'Device',
        description:
          'A device might either be a physical/virtual device or a group of device.',
        type: 'object',
        required: ['ID'],
        properties: {
          ID: {
            type: 'string',
            description:
              'Unique ID of the device. Contains the institution (by having an end point at that institution)',
            format: 'uri',
          },
        },
      },
    },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Type: {
      description:
        "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
      type: 'string',
      enum: ['normal'],
    },
  },
  'x-standalone': false,
  'x-name': 'newBookingBodyResponse',
  'x-location':
    '#/paths//booking/post/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate67(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Devices === undefined && (missing0 = 'Devices')) ||
        (data.Time === undefined && (missing0 = 'Time'))
      ) {
        validate67.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema52.required,
            parentSchema: schema52,
            data,
          },
        ];
        return false;
      } else {
        if (data.Devices !== undefined) {
          let data0 = data.Devices;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (Array.isArray(data0)) {
              var valid1 = true;
              const len0 = data0.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data1 = data0[i0];
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                    let missing1;
                    if (data1.ID === undefined && (missing1 = 'ID')) {
                      validate67.errors = [
                        {
                          instancePath: instancePath + '/Devices/' + i0,
                          schemaPath: '#/properties/Devices/items/required',
                          keyword: 'required',
                          params: { missingProperty: missing1 },
                          message: "must have required property '" + missing1 + "'",
                          schema: schema52.properties.Devices.items.required,
                          parentSchema: schema52.properties.Devices.items,
                          data: data1,
                        },
                      ];
                      return false;
                    } else {
                      if (data1.ID !== undefined) {
                        let data2 = data1.ID;
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (errors === _errs5) {
                            if (typeof data2 === 'string') {
                              if (!formats0(data2)) {
                                validate67.errors = [
                                  {
                                    instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                    schemaPath:
                                      '#/properties/Devices/items/properties/ID/format',
                                    keyword: 'format',
                                    params: { format: 'uri' },
                                    message: 'must match format "' + 'uri' + '"',
                                    schema: 'uri',
                                    parentSchema:
                                      schema52.properties.Devices.items.properties.ID,
                                    data: data2,
                                  },
                                ];
                                return false;
                              }
                            } else {
                              validate67.errors = [
                                {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/properties/Devices/items/properties/ID/type',
                                  keyword: 'type',
                                  params: { type: 'string' },
                                  message: 'must be string',
                                  schema:
                                    schema52.properties.Devices.items.properties.ID.type,
                                  parentSchema:
                                    schema52.properties.Devices.items.properties.ID,
                                  data: data2,
                                },
                              ];
                              return false;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate67.errors = [
                      {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/properties/Devices/items/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                        schema: schema52.properties.Devices.items.type,
                        parentSchema: schema52.properties.Devices.items,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                }
                var valid1 = _errs3 === errors;
                if (!valid1) {
                  break;
                }
              }
            } else {
              validate67.errors = [
                {
                  instancePath: instancePath + '/Devices',
                  schemaPath: '#/properties/Devices/type',
                  keyword: 'type',
                  params: { type: 'array' },
                  message: 'must be array',
                  schema: schema52.properties.Devices.type,
                  parentSchema: schema52.properties.Devices,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data3 = data.Time;
            const _errs7 = errors;
            if (errors === _errs7) {
              if (data3 && typeof data3 == 'object' && !Array.isArray(data3)) {
                let missing2;
                if (
                  (data3.Start === undefined && (missing2 = 'Start')) ||
                  (data3.End === undefined && (missing2 = 'End'))
                ) {
                  validate67.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing2 },
                      message: "must have required property '" + missing2 + "'",
                      schema: schema52.properties.Time.required,
                      parentSchema: schema52.properties.Time,
                      data: data3,
                    },
                  ];
                  return false;
                } else {
                  if (data3.Start !== undefined) {
                    let data4 = data3.Start;
                    const _errs9 = errors;
                    if (errors === _errs9) {
                      if (errors === _errs9) {
                        if (typeof data4 === 'string') {
                          if (!formats2.validate(data4)) {
                            validate67.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema52.properties.Time.properties.Start,
                                data: data4,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate67.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema52.properties.Time.properties.Start.type,
                              parentSchema: schema52.properties.Time.properties.Start,
                              data: data4,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid3 = _errs9 === errors;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data3.End !== undefined) {
                      let data5 = data3.End;
                      const _errs11 = errors;
                      if (errors === _errs11) {
                        if (errors === _errs11) {
                          if (typeof data5 === 'string') {
                            if (!formats2.validate(data5)) {
                              validate67.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema52.properties.Time.properties.End,
                                  data: data5,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate67.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema52.properties.Time.properties.End.type,
                                parentSchema: schema52.properties.Time.properties.End,
                                data: data5,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid3 = _errs11 === errors;
                    } else {
                      var valid3 = true;
                    }
                  }
                }
              } else {
                validate67.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema52.properties.Time.type,
                    parentSchema: schema52.properties.Time,
                    data: data3,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs7 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Type !== undefined) {
              let data6 = data.Type;
              const _errs13 = errors;
              if (typeof data6 !== 'string') {
                validate67.errors = [
                  {
                    instancePath: instancePath + '/Type',
                    schemaPath: '#/properties/Type/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema52.properties.Type.type,
                    parentSchema: schema52.properties.Type,
                    data: data6,
                  },
                ];
                return false;
              }
              if (!(data6 === 'normal')) {
                validate67.errors = [
                  {
                    instancePath: instancePath + '/Type',
                    schemaPath: '#/properties/Type/enum',
                    keyword: 'enum',
                    params: { allowedValues: schema52.properties.Type.enum },
                    message: 'must be equal to one of the allowed values',
                    schema: schema52.properties.Type.enum,
                    parentSchema: schema52.properties.Type,
                    data: data6,
                  },
                ];
                return false;
              }
              var valid0 = _errs13 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate67.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema52.type,
          parentSchema: schema52,
          data,
        },
      ];
      return false;
    }
  }
  validate67.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingResponse200Request = validate68;
const schema53 = {
  type: 'object',
  required: ['BookingID'],
  properties: {
    BookingID: {
      type: 'string',
      format: 'uri',
      description: 'ID at which the booking can be managed.',
    },
  },
  'x-standalone': false,
  'x-name': 'newBookingResponse200Request',
  'x-location':
    '#/paths//booking/post/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate68(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.BookingID === undefined && (missing0 = 'BookingID')) {
        validate68.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema53.required,
            parentSchema: schema53,
            data,
          },
        ];
        return false;
      } else {
        if (data.BookingID !== undefined) {
          let data0 = data.BookingID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate68.errors = [
                    {
                      instancePath: instancePath + '/BookingID',
                      schemaPath: '#/properties/BookingID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema53.properties.BookingID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate68.errors = [
                  {
                    instancePath: instancePath + '/BookingID',
                    schemaPath: '#/properties/BookingID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema53.properties.BookingID.type,
                    parentSchema: schema53.properties.BookingID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate68.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema53.type,
          parentSchema: schema53,
          data,
        },
      ];
      return false;
    }
  }
  validate68.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingResponse200Response = validate69;
const schema54 = {
  type: 'object',
  required: ['BookingID'],
  properties: {
    BookingID: {
      type: 'string',
      format: 'uri',
      description: 'ID at which the booking can be managed.',
    },
  },
  'x-standalone': false,
  'x-name': 'newBookingResponse200Response',
  'x-location':
    '#/paths//booking/post/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate69(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.BookingID === undefined && (missing0 = 'BookingID')) {
        validate69.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema54.required,
            parentSchema: schema54,
            data,
          },
        ];
        return false;
      } else {
        if (data.BookingID !== undefined) {
          let data0 = data.BookingID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate69.errors = [
                    {
                      instancePath: instancePath + '/BookingID',
                      schemaPath: '#/properties/BookingID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema54.properties.BookingID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate69.errors = [
                  {
                    instancePath: instancePath + '/BookingID',
                    schemaPath: '#/properties/BookingID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema54.properties.BookingID.type,
                    parentSchema: schema54.properties.BookingID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate69.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema54.type,
          parentSchema: schema54,
          data,
        },
      ];
      return false;
    }
  }
  validate69.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingResponse500Request = validate70;
const schema55 = {
  description: 'Error description',
  type: 'string',
  'x-standalone': false,
  'x-name': 'newBookingResponse500Request',
  'x-location':
    '#/paths//booking/post/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate70(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate70.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema55.type,
        parentSchema: schema55,
        data,
      },
    ];
    return false;
  }
  validate70.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingResponse500Response = validate71;
const schema56 = {
  description: 'Error description',
  type: 'string',
  'x-standalone': false,
  'x-name': 'newBookingResponse500Response',
  'x-location':
    '#/paths//booking/post/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate71(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate71.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema56.type,
        parentSchema: schema56,
        data,
      },
    ];
    return false;
  }
  validate71.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingBodyRequest = validate72;
const schema57 = {
  anyOf: [
    {
      type: 'object',
      description: 'Use this request for adding devices.',
      properties: {
        Locked: {
          type: 'boolean',
          description:
            'Expresses whether the devices should be locked. Must match current status of booking. Is assumed to be false if not set.',
        },
        Devices: {
          type: 'array',
          description: 'List of devices which should be added.',
          items: {
            title: 'Device',
            description:
              'A device might either be a physical/virtual device or a group of device.',
            type: 'object',
            required: ['ID'],
            properties: {
              ID: {
                type: 'string',
                description:
                  'Unique ID of the device. Contains the institution (by having an end point at that institution)',
                format: 'uri',
              },
            },
          },
        },
      },
    },
    {
      type: 'object',
      description: 'Use this request for adding callbacks.',
      properties: {
        Callback: {
          type: 'string',
          format: 'uri',
          description: 'Callback which should be called at changes.',
        },
      },
    },
  ],
  'x-standalone': false,
  'x-name': 'updateBookingBodyRequest',
  'x-location':
    '#/paths//booking/{ID}/patch/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate72(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  let valid0 = false;
  const _errs1 = errors;
  if (errors === _errs1) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.Locked !== undefined) {
        let data0 = data.Locked;
        const _errs3 = errors;
        if (typeof data0 !== 'boolean') {
          const err0 = {
            instancePath: instancePath + '/Locked',
            schemaPath: '#/anyOf/0/properties/Locked/type',
            keyword: 'type',
            params: { type: 'boolean' },
            message: 'must be boolean',
            schema: schema57.anyOf[0].properties.Locked.type,
            parentSchema: schema57.anyOf[0].properties.Locked,
            data: data0,
          };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
        var valid1 = _errs3 === errors;
      } else {
        var valid1 = true;
      }
      if (valid1) {
        if (data.Devices !== undefined) {
          let data1 = data.Devices;
          const _errs5 = errors;
          if (errors === _errs5) {
            if (Array.isArray(data1)) {
              var valid2 = true;
              const len0 = data1.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data2 = data1[i0];
                const _errs7 = errors;
                if (errors === _errs7) {
                  if (data2 && typeof data2 == 'object' && !Array.isArray(data2)) {
                    let missing0;
                    if (data2.ID === undefined && (missing0 = 'ID')) {
                      const err1 = {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/anyOf/0/properties/Devices/items/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                        schema: schema57.anyOf[0].properties.Devices.items.required,
                        parentSchema: schema57.anyOf[0].properties.Devices.items,
                        data: data2,
                      };
                      if (vErrors === null) {
                        vErrors = [err1];
                      } else {
                        vErrors.push(err1);
                      }
                      errors++;
                    } else {
                      if (data2.ID !== undefined) {
                        let data3 = data2.ID;
                        const _errs9 = errors;
                        if (errors === _errs9) {
                          if (errors === _errs9) {
                            if (typeof data3 === 'string') {
                              if (!formats0(data3)) {
                                const err2 = {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/anyOf/0/properties/Devices/items/properties/ID/format',
                                  keyword: 'format',
                                  params: { format: 'uri' },
                                  message: 'must match format "' + 'uri' + '"',
                                  schema: 'uri',
                                  parentSchema:
                                    schema57.anyOf[0].properties.Devices.items.properties
                                      .ID,
                                  data: data3,
                                };
                                if (vErrors === null) {
                                  vErrors = [err2];
                                } else {
                                  vErrors.push(err2);
                                }
                                errors++;
                              }
                            } else {
                              const err3 = {
                                instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                schemaPath:
                                  '#/anyOf/0/properties/Devices/items/properties/ID/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema:
                                  schema57.anyOf[0].properties.Devices.items.properties.ID
                                    .type,
                                parentSchema:
                                  schema57.anyOf[0].properties.Devices.items.properties
                                    .ID,
                                data: data3,
                              };
                              if (vErrors === null) {
                                vErrors = [err3];
                              } else {
                                vErrors.push(err3);
                              }
                              errors++;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    const err4 = {
                      instancePath: instancePath + '/Devices/' + i0,
                      schemaPath: '#/anyOf/0/properties/Devices/items/type',
                      keyword: 'type',
                      params: { type: 'object' },
                      message: 'must be object',
                      schema: schema57.anyOf[0].properties.Devices.items.type,
                      parentSchema: schema57.anyOf[0].properties.Devices.items,
                      data: data2,
                    };
                    if (vErrors === null) {
                      vErrors = [err4];
                    } else {
                      vErrors.push(err4);
                    }
                    errors++;
                  }
                }
                var valid2 = _errs7 === errors;
                if (!valid2) {
                  break;
                }
              }
            } else {
              const err5 = {
                instancePath: instancePath + '/Devices',
                schemaPath: '#/anyOf/0/properties/Devices/type',
                keyword: 'type',
                params: { type: 'array' },
                message: 'must be array',
                schema: schema57.anyOf[0].properties.Devices.type,
                parentSchema: schema57.anyOf[0].properties.Devices,
                data: data1,
              };
              if (vErrors === null) {
                vErrors = [err5];
              } else {
                vErrors.push(err5);
              }
              errors++;
            }
          }
          var valid1 = _errs5 === errors;
        } else {
          var valid1 = true;
        }
      }
    } else {
      const err6 = {
        instancePath,
        schemaPath: '#/anyOf/0/type',
        keyword: 'type',
        params: { type: 'object' },
        message: 'must be object',
        schema: schema57.anyOf[0].type,
        parentSchema: schema57.anyOf[0],
        data,
      };
      if (vErrors === null) {
        vErrors = [err6];
      } else {
        vErrors.push(err6);
      }
      errors++;
    }
  }
  var _valid0 = _errs1 === errors;
  valid0 = valid0 || _valid0;
  if (!valid0) {
    const _errs11 = errors;
    if (errors === _errs11) {
      if (data && typeof data == 'object' && !Array.isArray(data)) {
        if (data.Callback !== undefined) {
          let data4 = data.Callback;
          const _errs13 = errors;
          if (errors === _errs13) {
            if (errors === _errs13) {
              if (typeof data4 === 'string') {
                if (!formats0(data4)) {
                  const err7 = {
                    instancePath: instancePath + '/Callback',
                    schemaPath: '#/anyOf/1/properties/Callback/format',
                    keyword: 'format',
                    params: { format: 'uri' },
                    message: 'must match format "' + 'uri' + '"',
                    schema: 'uri',
                    parentSchema: schema57.anyOf[1].properties.Callback,
                    data: data4,
                  };
                  if (vErrors === null) {
                    vErrors = [err7];
                  } else {
                    vErrors.push(err7);
                  }
                  errors++;
                }
              } else {
                const err8 = {
                  instancePath: instancePath + '/Callback',
                  schemaPath: '#/anyOf/1/properties/Callback/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema57.anyOf[1].properties.Callback.type,
                  parentSchema: schema57.anyOf[1].properties.Callback,
                  data: data4,
                };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors++;
              }
            }
          }
        }
      } else {
        const err9 = {
          instancePath,
          schemaPath: '#/anyOf/1/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema57.anyOf[1].type,
          parentSchema: schema57.anyOf[1],
          data,
        };
        if (vErrors === null) {
          vErrors = [err9];
        } else {
          vErrors.push(err9);
        }
        errors++;
      }
    }
    var _valid0 = _errs11 === errors;
    valid0 = valid0 || _valid0;
  }
  if (!valid0) {
    const err10 = {
      instancePath,
      schemaPath: '#/anyOf',
      keyword: 'anyOf',
      params: {},
      message: 'must match a schema in anyOf',
      schema: schema57.anyOf,
      parentSchema: schema57,
      data,
    };
    if (vErrors === null) {
      vErrors = [err10];
    } else {
      vErrors.push(err10);
    }
    errors++;
    validate72.errors = vErrors;
    return false;
  } else {
    errors = _errs0;
    if (vErrors !== null) {
      if (_errs0) {
        vErrors.length = _errs0;
      } else {
        vErrors = null;
      }
    }
  }
  validate72.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingBodyResponse = validate73;
const schema58 = {
  anyOf: [
    {
      type: 'object',
      description: 'Use this request for adding devices.',
      properties: {
        Locked: {
          type: 'boolean',
          description:
            'Expresses whether the devices should be locked. Must match current status of booking. Is assumed to be false if not set.',
        },
        Devices: {
          type: 'array',
          description: 'List of devices which should be added.',
          items: {
            title: 'Device',
            description:
              'A device might either be a physical/virtual device or a group of device.',
            type: 'object',
            required: ['ID'],
            properties: {
              ID: {
                type: 'string',
                description:
                  'Unique ID of the device. Contains the institution (by having an end point at that institution)',
                format: 'uri',
              },
            },
          },
        },
      },
    },
    {
      type: 'object',
      description: 'Use this request for adding callbacks.',
      properties: {
        Callback: {
          type: 'string',
          format: 'uri',
          description: 'Callback which should be called at changes.',
        },
      },
    },
  ],
  'x-standalone': false,
  'x-name': 'updateBookingBodyResponse',
  'x-location':
    '#/paths//booking/{ID}/patch/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate73(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  let valid0 = false;
  const _errs1 = errors;
  if (errors === _errs1) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.Locked !== undefined) {
        let data0 = data.Locked;
        const _errs3 = errors;
        if (typeof data0 !== 'boolean') {
          const err0 = {
            instancePath: instancePath + '/Locked',
            schemaPath: '#/anyOf/0/properties/Locked/type',
            keyword: 'type',
            params: { type: 'boolean' },
            message: 'must be boolean',
            schema: schema58.anyOf[0].properties.Locked.type,
            parentSchema: schema58.anyOf[0].properties.Locked,
            data: data0,
          };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
        var valid1 = _errs3 === errors;
      } else {
        var valid1 = true;
      }
      if (valid1) {
        if (data.Devices !== undefined) {
          let data1 = data.Devices;
          const _errs5 = errors;
          if (errors === _errs5) {
            if (Array.isArray(data1)) {
              var valid2 = true;
              const len0 = data1.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data2 = data1[i0];
                const _errs7 = errors;
                if (errors === _errs7) {
                  if (data2 && typeof data2 == 'object' && !Array.isArray(data2)) {
                    let missing0;
                    if (data2.ID === undefined && (missing0 = 'ID')) {
                      const err1 = {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/anyOf/0/properties/Devices/items/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                        schema: schema58.anyOf[0].properties.Devices.items.required,
                        parentSchema: schema58.anyOf[0].properties.Devices.items,
                        data: data2,
                      };
                      if (vErrors === null) {
                        vErrors = [err1];
                      } else {
                        vErrors.push(err1);
                      }
                      errors++;
                    } else {
                      if (data2.ID !== undefined) {
                        let data3 = data2.ID;
                        const _errs9 = errors;
                        if (errors === _errs9) {
                          if (errors === _errs9) {
                            if (typeof data3 === 'string') {
                              if (!formats0(data3)) {
                                const err2 = {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/anyOf/0/properties/Devices/items/properties/ID/format',
                                  keyword: 'format',
                                  params: { format: 'uri' },
                                  message: 'must match format "' + 'uri' + '"',
                                  schema: 'uri',
                                  parentSchema:
                                    schema58.anyOf[0].properties.Devices.items.properties
                                      .ID,
                                  data: data3,
                                };
                                if (vErrors === null) {
                                  vErrors = [err2];
                                } else {
                                  vErrors.push(err2);
                                }
                                errors++;
                              }
                            } else {
                              const err3 = {
                                instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                schemaPath:
                                  '#/anyOf/0/properties/Devices/items/properties/ID/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema:
                                  schema58.anyOf[0].properties.Devices.items.properties.ID
                                    .type,
                                parentSchema:
                                  schema58.anyOf[0].properties.Devices.items.properties
                                    .ID,
                                data: data3,
                              };
                              if (vErrors === null) {
                                vErrors = [err3];
                              } else {
                                vErrors.push(err3);
                              }
                              errors++;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    const err4 = {
                      instancePath: instancePath + '/Devices/' + i0,
                      schemaPath: '#/anyOf/0/properties/Devices/items/type',
                      keyword: 'type',
                      params: { type: 'object' },
                      message: 'must be object',
                      schema: schema58.anyOf[0].properties.Devices.items.type,
                      parentSchema: schema58.anyOf[0].properties.Devices.items,
                      data: data2,
                    };
                    if (vErrors === null) {
                      vErrors = [err4];
                    } else {
                      vErrors.push(err4);
                    }
                    errors++;
                  }
                }
                var valid2 = _errs7 === errors;
                if (!valid2) {
                  break;
                }
              }
            } else {
              const err5 = {
                instancePath: instancePath + '/Devices',
                schemaPath: '#/anyOf/0/properties/Devices/type',
                keyword: 'type',
                params: { type: 'array' },
                message: 'must be array',
                schema: schema58.anyOf[0].properties.Devices.type,
                parentSchema: schema58.anyOf[0].properties.Devices,
                data: data1,
              };
              if (vErrors === null) {
                vErrors = [err5];
              } else {
                vErrors.push(err5);
              }
              errors++;
            }
          }
          var valid1 = _errs5 === errors;
        } else {
          var valid1 = true;
        }
      }
    } else {
      const err6 = {
        instancePath,
        schemaPath: '#/anyOf/0/type',
        keyword: 'type',
        params: { type: 'object' },
        message: 'must be object',
        schema: schema58.anyOf[0].type,
        parentSchema: schema58.anyOf[0],
        data,
      };
      if (vErrors === null) {
        vErrors = [err6];
      } else {
        vErrors.push(err6);
      }
      errors++;
    }
  }
  var _valid0 = _errs1 === errors;
  valid0 = valid0 || _valid0;
  if (!valid0) {
    const _errs11 = errors;
    if (errors === _errs11) {
      if (data && typeof data == 'object' && !Array.isArray(data)) {
        if (data.Callback !== undefined) {
          let data4 = data.Callback;
          const _errs13 = errors;
          if (errors === _errs13) {
            if (errors === _errs13) {
              if (typeof data4 === 'string') {
                if (!formats0(data4)) {
                  const err7 = {
                    instancePath: instancePath + '/Callback',
                    schemaPath: '#/anyOf/1/properties/Callback/format',
                    keyword: 'format',
                    params: { format: 'uri' },
                    message: 'must match format "' + 'uri' + '"',
                    schema: 'uri',
                    parentSchema: schema58.anyOf[1].properties.Callback,
                    data: data4,
                  };
                  if (vErrors === null) {
                    vErrors = [err7];
                  } else {
                    vErrors.push(err7);
                  }
                  errors++;
                }
              } else {
                const err8 = {
                  instancePath: instancePath + '/Callback',
                  schemaPath: '#/anyOf/1/properties/Callback/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema58.anyOf[1].properties.Callback.type,
                  parentSchema: schema58.anyOf[1].properties.Callback,
                  data: data4,
                };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors++;
              }
            }
          }
        }
      } else {
        const err9 = {
          instancePath,
          schemaPath: '#/anyOf/1/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema58.anyOf[1].type,
          parentSchema: schema58.anyOf[1],
          data,
        };
        if (vErrors === null) {
          vErrors = [err9];
        } else {
          vErrors.push(err9);
        }
        errors++;
      }
    }
    var _valid0 = _errs11 === errors;
    valid0 = valid0 || _valid0;
  }
  if (!valid0) {
    const err10 = {
      instancePath,
      schemaPath: '#/anyOf',
      keyword: 'anyOf',
      params: {},
      message: 'must match a schema in anyOf',
      schema: schema58.anyOf,
      parentSchema: schema58,
      data,
    };
    if (vErrors === null) {
      vErrors = [err10];
    } else {
      vErrors.push(err10);
    }
    errors++;
    validate73.errors = vErrors;
    return false;
  } else {
    errors = _errs0;
    if (vErrors !== null) {
      if (_errs0) {
        vErrors.length = _errs0;
      } else {
        vErrors = null;
      }
    }
  }
  validate73.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse200Request = validate74;
const schema59 = {
  type: 'object',
  required: ['BookingID'],
  properties: { BookingID: { type: 'string', format: 'uri' } },
  'x-standalone': false,
  'x-name': 'updateBookingResponse200Request',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate74(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.BookingID === undefined && (missing0 = 'BookingID')) {
        validate74.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema59.required,
            parentSchema: schema59,
            data,
          },
        ];
        return false;
      } else {
        if (data.BookingID !== undefined) {
          let data0 = data.BookingID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate74.errors = [
                    {
                      instancePath: instancePath + '/BookingID',
                      schemaPath: '#/properties/BookingID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema59.properties.BookingID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate74.errors = [
                  {
                    instancePath: instancePath + '/BookingID',
                    schemaPath: '#/properties/BookingID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema59.properties.BookingID.type,
                    parentSchema: schema59.properties.BookingID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate74.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema59.type,
          parentSchema: schema59,
          data,
        },
      ];
      return false;
    }
  }
  validate74.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse200Response = validate75;
const schema60 = {
  type: 'object',
  required: ['BookingID'],
  properties: { BookingID: { type: 'string', format: 'uri' } },
  'x-standalone': false,
  'x-name': 'updateBookingResponse200Response',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate75(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.BookingID === undefined && (missing0 = 'BookingID')) {
        validate75.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema60.required,
            parentSchema: schema60,
            data,
          },
        ];
        return false;
      } else {
        if (data.BookingID !== undefined) {
          let data0 = data.BookingID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate75.errors = [
                    {
                      instancePath: instancePath + '/BookingID',
                      schemaPath: '#/properties/BookingID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema60.properties.BookingID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate75.errors = [
                  {
                    instancePath: instancePath + '/BookingID',
                    schemaPath: '#/properties/BookingID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema60.properties.BookingID.type,
                    parentSchema: schema60.properties.BookingID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate75.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema60.type,
          parentSchema: schema60,
          data,
        },
      ];
      return false;
    }
  }
  validate75.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse400Request = validate76;
const schema61 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'updateBookingResponse400Request',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/400/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate76(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate76.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema61.type,
        parentSchema: schema61,
        data,
      },
    ];
    return false;
  }
  validate76.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse400Response = validate77;
const schema62 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'updateBookingResponse400Response',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/400/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate77(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate77.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema62.type,
        parentSchema: schema62,
        data,
      },
    ];
    return false;
  }
  validate77.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse500Request = validate78;
const schema63 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'updateBookingResponse500Request',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate78(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate78.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema63.type,
        parentSchema: schema63,
        data,
      },
    ];
    return false;
  }
  validate78.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse500Response = validate79;
const schema64 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'updateBookingResponse500Response',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate79(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate79.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema64.type,
        parentSchema: schema64,
        data,
      },
    ];
    return false;
  }
  validate79.errors = vErrors;
  return errors === 0;
}
exports.validateDeleteBookingResponse500Request = validate80;
const schema65 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'deleteBookingResponse500Request',
  'x-location':
    '#/paths//booking/{ID}/delete/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate80(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate80.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema65.type,
        parentSchema: schema65,
        data,
      },
    ];
    return false;
  }
  validate80.errors = vErrors;
  return errors === 0;
}
exports.validateDeleteBookingResponse500Response = validate81;
const schema66 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'deleteBookingResponse500Response',
  'x-location':
    '#/paths//booking/{ID}/delete/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate81(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate81.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema66.type,
        parentSchema: schema66,
        data,
      },
    ];
    return false;
  }
  validate81.errors = vErrors;
  return errors === 0;
}
exports.validateGetBookingResponse200Request = validate82;
const schema67 = {
  type: 'object',
  required: ['Booking', 'Locked'],
  properties: {
    Booking: {
      title: 'Booking',
      description: 'A booking in the booking system.',
      type: 'object',
      required: ['ID', 'Time', 'Devices', 'Status', 'You', 'External'],
      properties: {
        ID: { type: 'string', format: 'uri', description: 'Unique ID of the booking.' },
        Time: {
          title: 'Timeslot',
          description: 'A time slot represents a slice of time used for bookings.',
          type: 'object',
          required: ['Start', 'End'],
          properties: {
            Start: {
              type: 'string',
              description: 'Start time of the booking.',
              format: 'date-time',
            },
            End: {
              type: 'string',
              description: 'End time of the booking.',
              format: 'date-time',
            },
          },
        },
        Devices: { type: 'array', items: { type: 'string', format: 'uri' } },
        Type: {
          description:
            "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
          type: 'string',
          enum: ['normal'],
        },
        Status: {
          description:
            "Current status of the booking. While the booking is pending, it can not be used. Will change automatically and can not be set by user. 'rejected' is set when the initial booking failed, 'cancelled' when the booking was deleted / cancelled after it was once active. The 'active-*' will be used when a device was added after the booking was locked.",
          type: 'string',
          enum: [
            'pending',
            'booked',
            'rejected',
            'cancelled',
            'active',
            'active-pending',
            'active-rejected',
          ],
        },
        You: { type: 'boolean', description: 'If true, this booking was done by you.' },
        External: {
          type: 'boolean',
          description: 'Shows whether the booking was done by an external institution.',
        },
        Message: {
          type: 'string',
          description:
            'User readable notes about the status of the booking (e.g. if devices are unknown).',
        },
      },
    },
    Locked: {
      type: 'boolean',
      description: 'Shows if the booking is in a locked status.',
    },
  },
  'x-standalone': false,
  'x-name': 'getBookingResponse200Request',
  'x-location':
    '#/paths//booking/{ID}/get/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate82(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Booking === undefined && (missing0 = 'Booking')) ||
        (data.Locked === undefined && (missing0 = 'Locked'))
      ) {
        validate82.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema67.required,
            parentSchema: schema67,
            data,
          },
        ];
        return false;
      } else {
        if (data.Booking !== undefined) {
          let data0 = data.Booking;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
              let missing1;
              if (
                (data0.ID === undefined && (missing1 = 'ID')) ||
                (data0.Time === undefined && (missing1 = 'Time')) ||
                (data0.Devices === undefined && (missing1 = 'Devices')) ||
                (data0.Status === undefined && (missing1 = 'Status')) ||
                (data0.You === undefined && (missing1 = 'You')) ||
                (data0.External === undefined && (missing1 = 'External'))
              ) {
                validate82.errors = [
                  {
                    instancePath: instancePath + '/Booking',
                    schemaPath: '#/properties/Booking/required',
                    keyword: 'required',
                    params: { missingProperty: missing1 },
                    message: "must have required property '" + missing1 + "'",
                    schema: schema67.properties.Booking.required,
                    parentSchema: schema67.properties.Booking,
                    data: data0,
                  },
                ];
                return false;
              } else {
                if (data0.ID !== undefined) {
                  let data1 = data0.ID;
                  const _errs3 = errors;
                  if (errors === _errs3) {
                    if (errors === _errs3) {
                      if (typeof data1 === 'string') {
                        if (!formats0(data1)) {
                          validate82.errors = [
                            {
                              instancePath: instancePath + '/Booking/ID',
                              schemaPath: '#/properties/Booking/properties/ID/format',
                              keyword: 'format',
                              params: { format: 'uri' },
                              message: 'must match format "' + 'uri' + '"',
                              schema: 'uri',
                              parentSchema: schema67.properties.Booking.properties.ID,
                              data: data1,
                            },
                          ];
                          return false;
                        }
                      } else {
                        validate82.errors = [
                          {
                            instancePath: instancePath + '/Booking/ID',
                            schemaPath: '#/properties/Booking/properties/ID/type',
                            keyword: 'type',
                            params: { type: 'string' },
                            message: 'must be string',
                            schema: schema67.properties.Booking.properties.ID.type,
                            parentSchema: schema67.properties.Booking.properties.ID,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    }
                  }
                  var valid1 = _errs3 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.Time !== undefined) {
                    let data2 = data0.Time;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (data2 && typeof data2 == 'object' && !Array.isArray(data2)) {
                        let missing2;
                        if (
                          (data2.Start === undefined && (missing2 = 'Start')) ||
                          (data2.End === undefined && (missing2 = 'End'))
                        ) {
                          validate82.errors = [
                            {
                              instancePath: instancePath + '/Booking/Time',
                              schemaPath: '#/properties/Booking/properties/Time/required',
                              keyword: 'required',
                              params: { missingProperty: missing2 },
                              message: "must have required property '" + missing2 + "'",
                              schema:
                                schema67.properties.Booking.properties.Time.required,
                              parentSchema: schema67.properties.Booking.properties.Time,
                              data: data2,
                            },
                          ];
                          return false;
                        } else {
                          if (data2.Start !== undefined) {
                            let data3 = data2.Start;
                            const _errs7 = errors;
                            if (errors === _errs7) {
                              if (errors === _errs7) {
                                if (typeof data3 === 'string') {
                                  if (!formats2.validate(data3)) {
                                    validate82.errors = [
                                      {
                                        instancePath:
                                          instancePath + '/Booking/Time/Start',
                                        schemaPath:
                                          '#/properties/Booking/properties/Time/properties/Start/format',
                                        keyword: 'format',
                                        params: { format: 'date-time' },
                                        message:
                                          'must match format "' + 'date-time' + '"',
                                        schema: 'date-time',
                                        parentSchema:
                                          schema67.properties.Booking.properties.Time
                                            .properties.Start,
                                        data: data3,
                                      },
                                    ];
                                    return false;
                                  }
                                } else {
                                  validate82.errors = [
                                    {
                                      instancePath: instancePath + '/Booking/Time/Start',
                                      schemaPath:
                                        '#/properties/Booking/properties/Time/properties/Start/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema67.properties.Booking.properties.Time
                                          .properties.Start.type,
                                      parentSchema:
                                        schema67.properties.Booking.properties.Time
                                          .properties.Start,
                                      data: data3,
                                    },
                                  ];
                                  return false;
                                }
                              }
                            }
                            var valid2 = _errs7 === errors;
                          } else {
                            var valid2 = true;
                          }
                          if (valid2) {
                            if (data2.End !== undefined) {
                              let data4 = data2.End;
                              const _errs9 = errors;
                              if (errors === _errs9) {
                                if (errors === _errs9) {
                                  if (typeof data4 === 'string') {
                                    if (!formats2.validate(data4)) {
                                      validate82.errors = [
                                        {
                                          instancePath:
                                            instancePath + '/Booking/Time/End',
                                          schemaPath:
                                            '#/properties/Booking/properties/Time/properties/End/format',
                                          keyword: 'format',
                                          params: { format: 'date-time' },
                                          message:
                                            'must match format "' + 'date-time' + '"',
                                          schema: 'date-time',
                                          parentSchema:
                                            schema67.properties.Booking.properties.Time
                                              .properties.End,
                                          data: data4,
                                        },
                                      ];
                                      return false;
                                    }
                                  } else {
                                    validate82.errors = [
                                      {
                                        instancePath: instancePath + '/Booking/Time/End',
                                        schemaPath:
                                          '#/properties/Booking/properties/Time/properties/End/type',
                                        keyword: 'type',
                                        params: { type: 'string' },
                                        message: 'must be string',
                                        schema:
                                          schema67.properties.Booking.properties.Time
                                            .properties.End.type,
                                        parentSchema:
                                          schema67.properties.Booking.properties.Time
                                            .properties.End,
                                        data: data4,
                                      },
                                    ];
                                    return false;
                                  }
                                }
                              }
                              var valid2 = _errs9 === errors;
                            } else {
                              var valid2 = true;
                            }
                          }
                        }
                      } else {
                        validate82.errors = [
                          {
                            instancePath: instancePath + '/Booking/Time',
                            schemaPath: '#/properties/Booking/properties/Time/type',
                            keyword: 'type',
                            params: { type: 'object' },
                            message: 'must be object',
                            schema: schema67.properties.Booking.properties.Time.type,
                            parentSchema: schema67.properties.Booking.properties.Time,
                            data: data2,
                          },
                        ];
                        return false;
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data0.Devices !== undefined) {
                      let data5 = data0.Devices;
                      const _errs11 = errors;
                      if (errors === _errs11) {
                        if (Array.isArray(data5)) {
                          var valid3 = true;
                          const len0 = data5.length;
                          for (let i0 = 0; i0 < len0; i0++) {
                            let data6 = data5[i0];
                            const _errs13 = errors;
                            if (errors === _errs13) {
                              if (errors === _errs13) {
                                if (typeof data6 === 'string') {
                                  if (!formats0(data6)) {
                                    validate82.errors = [
                                      {
                                        instancePath:
                                          instancePath + '/Booking/Devices/' + i0,
                                        schemaPath:
                                          '#/properties/Booking/properties/Devices/items/format',
                                        keyword: 'format',
                                        params: { format: 'uri' },
                                        message: 'must match format "' + 'uri' + '"',
                                        schema: 'uri',
                                        parentSchema:
                                          schema67.properties.Booking.properties.Devices
                                            .items,
                                        data: data6,
                                      },
                                    ];
                                    return false;
                                  }
                                } else {
                                  validate82.errors = [
                                    {
                                      instancePath:
                                        instancePath + '/Booking/Devices/' + i0,
                                      schemaPath:
                                        '#/properties/Booking/properties/Devices/items/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema67.properties.Booking.properties.Devices
                                          .items.type,
                                      parentSchema:
                                        schema67.properties.Booking.properties.Devices
                                          .items,
                                      data: data6,
                                    },
                                  ];
                                  return false;
                                }
                              }
                            }
                            var valid3 = _errs13 === errors;
                            if (!valid3) {
                              break;
                            }
                          }
                        } else {
                          validate82.errors = [
                            {
                              instancePath: instancePath + '/Booking/Devices',
                              schemaPath: '#/properties/Booking/properties/Devices/type',
                              keyword: 'type',
                              params: { type: 'array' },
                              message: 'must be array',
                              schema: schema67.properties.Booking.properties.Devices.type,
                              parentSchema:
                                schema67.properties.Booking.properties.Devices,
                              data: data5,
                            },
                          ];
                          return false;
                        }
                      }
                      var valid1 = _errs11 === errors;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data0.Type !== undefined) {
                        let data7 = data0.Type;
                        const _errs15 = errors;
                        if (typeof data7 !== 'string') {
                          validate82.errors = [
                            {
                              instancePath: instancePath + '/Booking/Type',
                              schemaPath: '#/properties/Booking/properties/Type/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema67.properties.Booking.properties.Type.type,
                              parentSchema: schema67.properties.Booking.properties.Type,
                              data: data7,
                            },
                          ];
                          return false;
                        }
                        if (!(data7 === 'normal')) {
                          validate82.errors = [
                            {
                              instancePath: instancePath + '/Booking/Type',
                              schemaPath: '#/properties/Booking/properties/Type/enum',
                              keyword: 'enum',
                              params: {
                                allowedValues:
                                  schema67.properties.Booking.properties.Type.enum,
                              },
                              message: 'must be equal to one of the allowed values',
                              schema: schema67.properties.Booking.properties.Type.enum,
                              parentSchema: schema67.properties.Booking.properties.Type,
                              data: data7,
                            },
                          ];
                          return false;
                        }
                        var valid1 = _errs15 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data0.Status !== undefined) {
                          let data8 = data0.Status;
                          const _errs17 = errors;
                          if (typeof data8 !== 'string') {
                            validate82.errors = [
                              {
                                instancePath: instancePath + '/Booking/Status',
                                schemaPath: '#/properties/Booking/properties/Status/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema:
                                  schema67.properties.Booking.properties.Status.type,
                                parentSchema:
                                  schema67.properties.Booking.properties.Status,
                                data: data8,
                              },
                            ];
                            return false;
                          }
                          if (
                            !(
                              data8 === 'pending' ||
                              data8 === 'booked' ||
                              data8 === 'rejected' ||
                              data8 === 'cancelled' ||
                              data8 === 'active' ||
                              data8 === 'active-pending' ||
                              data8 === 'active-rejected'
                            )
                          ) {
                            validate82.errors = [
                              {
                                instancePath: instancePath + '/Booking/Status',
                                schemaPath: '#/properties/Booking/properties/Status/enum',
                                keyword: 'enum',
                                params: {
                                  allowedValues:
                                    schema67.properties.Booking.properties.Status.enum,
                                },
                                message: 'must be equal to one of the allowed values',
                                schema:
                                  schema67.properties.Booking.properties.Status.enum,
                                parentSchema:
                                  schema67.properties.Booking.properties.Status,
                                data: data8,
                              },
                            ];
                            return false;
                          }
                          var valid1 = _errs17 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data0.You !== undefined) {
                            let data9 = data0.You;
                            const _errs19 = errors;
                            if (typeof data9 !== 'boolean') {
                              validate82.errors = [
                                {
                                  instancePath: instancePath + '/Booking/You',
                                  schemaPath: '#/properties/Booking/properties/You/type',
                                  keyword: 'type',
                                  params: { type: 'boolean' },
                                  message: 'must be boolean',
                                  schema: schema67.properties.Booking.properties.You.type,
                                  parentSchema:
                                    schema67.properties.Booking.properties.You,
                                  data: data9,
                                },
                              ];
                              return false;
                            }
                            var valid1 = _errs19 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data0.External !== undefined) {
                              let data10 = data0.External;
                              const _errs21 = errors;
                              if (typeof data10 !== 'boolean') {
                                validate82.errors = [
                                  {
                                    instancePath: instancePath + '/Booking/External',
                                    schemaPath:
                                      '#/properties/Booking/properties/External/type',
                                    keyword: 'type',
                                    params: { type: 'boolean' },
                                    message: 'must be boolean',
                                    schema:
                                      schema67.properties.Booking.properties.External
                                        .type,
                                    parentSchema:
                                      schema67.properties.Booking.properties.External,
                                    data: data10,
                                  },
                                ];
                                return false;
                              }
                              var valid1 = _errs21 === errors;
                            } else {
                              var valid1 = true;
                            }
                            if (valid1) {
                              if (data0.Message !== undefined) {
                                let data11 = data0.Message;
                                const _errs23 = errors;
                                if (typeof data11 !== 'string') {
                                  validate82.errors = [
                                    {
                                      instancePath: instancePath + '/Booking/Message',
                                      schemaPath:
                                        '#/properties/Booking/properties/Message/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema67.properties.Booking.properties.Message
                                          .type,
                                      parentSchema:
                                        schema67.properties.Booking.properties.Message,
                                      data: data11,
                                    },
                                  ];
                                  return false;
                                }
                                var valid1 = _errs23 === errors;
                              } else {
                                var valid1 = true;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              validate82.errors = [
                {
                  instancePath: instancePath + '/Booking',
                  schemaPath: '#/properties/Booking/type',
                  keyword: 'type',
                  params: { type: 'object' },
                  message: 'must be object',
                  schema: schema67.properties.Booking.type,
                  parentSchema: schema67.properties.Booking,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Locked !== undefined) {
            let data12 = data.Locked;
            const _errs25 = errors;
            if (typeof data12 !== 'boolean') {
              validate82.errors = [
                {
                  instancePath: instancePath + '/Locked',
                  schemaPath: '#/properties/Locked/type',
                  keyword: 'type',
                  params: { type: 'boolean' },
                  message: 'must be boolean',
                  schema: schema67.properties.Locked.type,
                  parentSchema: schema67.properties.Locked,
                  data: data12,
                },
              ];
              return false;
            }
            var valid0 = _errs25 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate82.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema67.type,
          parentSchema: schema67,
          data,
        },
      ];
      return false;
    }
  }
  validate82.errors = vErrors;
  return errors === 0;
}
exports.validateGetBookingResponse200Response = validate83;
const schema68 = {
  type: 'object',
  required: ['Booking', 'Locked'],
  properties: {
    Booking: {
      title: 'Booking',
      description: 'A booking in the booking system.',
      type: 'object',
      required: ['ID', 'Time', 'Devices', 'Status', 'You', 'External'],
      properties: {
        ID: { type: 'string', format: 'uri', description: 'Unique ID of the booking.' },
        Time: {
          title: 'Timeslot',
          description: 'A time slot represents a slice of time used for bookings.',
          type: 'object',
          required: ['Start', 'End'],
          properties: {
            Start: {
              type: 'string',
              description: 'Start time of the booking.',
              format: 'date-time',
            },
            End: {
              type: 'string',
              description: 'End time of the booking.',
              format: 'date-time',
            },
          },
        },
        Devices: { type: 'array', items: { type: 'string', format: 'uri' } },
        Type: {
          description:
            "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
          type: 'string',
          enum: ['normal'],
        },
        Status: {
          description:
            "Current status of the booking. While the booking is pending, it can not be used. Will change automatically and can not be set by user. 'rejected' is set when the initial booking failed, 'cancelled' when the booking was deleted / cancelled after it was once active. The 'active-*' will be used when a device was added after the booking was locked.",
          type: 'string',
          enum: [
            'pending',
            'booked',
            'rejected',
            'cancelled',
            'active',
            'active-pending',
            'active-rejected',
          ],
        },
        You: { type: 'boolean', description: 'If true, this booking was done by you.' },
        External: {
          type: 'boolean',
          description: 'Shows whether the booking was done by an external institution.',
        },
        Message: {
          type: 'string',
          description:
            'User readable notes about the status of the booking (e.g. if devices are unknown).',
        },
      },
    },
    Locked: {
      type: 'boolean',
      description: 'Shows if the booking is in a locked status.',
    },
  },
  'x-standalone': false,
  'x-name': 'getBookingResponse200Response',
  'x-location':
    '#/paths//booking/{ID}/get/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate83(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Booking === undefined && (missing0 = 'Booking')) ||
        (data.Locked === undefined && (missing0 = 'Locked'))
      ) {
        validate83.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema68.required,
            parentSchema: schema68,
            data,
          },
        ];
        return false;
      } else {
        if (data.Booking !== undefined) {
          let data0 = data.Booking;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
              let missing1;
              if (
                (data0.ID === undefined && (missing1 = 'ID')) ||
                (data0.Time === undefined && (missing1 = 'Time')) ||
                (data0.Devices === undefined && (missing1 = 'Devices')) ||
                (data0.Status === undefined && (missing1 = 'Status')) ||
                (data0.You === undefined && (missing1 = 'You')) ||
                (data0.External === undefined && (missing1 = 'External'))
              ) {
                validate83.errors = [
                  {
                    instancePath: instancePath + '/Booking',
                    schemaPath: '#/properties/Booking/required',
                    keyword: 'required',
                    params: { missingProperty: missing1 },
                    message: "must have required property '" + missing1 + "'",
                    schema: schema68.properties.Booking.required,
                    parentSchema: schema68.properties.Booking,
                    data: data0,
                  },
                ];
                return false;
              } else {
                if (data0.ID !== undefined) {
                  let data1 = data0.ID;
                  const _errs3 = errors;
                  if (errors === _errs3) {
                    if (errors === _errs3) {
                      if (typeof data1 === 'string') {
                        if (!formats0(data1)) {
                          validate83.errors = [
                            {
                              instancePath: instancePath + '/Booking/ID',
                              schemaPath: '#/properties/Booking/properties/ID/format',
                              keyword: 'format',
                              params: { format: 'uri' },
                              message: 'must match format "' + 'uri' + '"',
                              schema: 'uri',
                              parentSchema: schema68.properties.Booking.properties.ID,
                              data: data1,
                            },
                          ];
                          return false;
                        }
                      } else {
                        validate83.errors = [
                          {
                            instancePath: instancePath + '/Booking/ID',
                            schemaPath: '#/properties/Booking/properties/ID/type',
                            keyword: 'type',
                            params: { type: 'string' },
                            message: 'must be string',
                            schema: schema68.properties.Booking.properties.ID.type,
                            parentSchema: schema68.properties.Booking.properties.ID,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    }
                  }
                  var valid1 = _errs3 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.Time !== undefined) {
                    let data2 = data0.Time;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (data2 && typeof data2 == 'object' && !Array.isArray(data2)) {
                        let missing2;
                        if (
                          (data2.Start === undefined && (missing2 = 'Start')) ||
                          (data2.End === undefined && (missing2 = 'End'))
                        ) {
                          validate83.errors = [
                            {
                              instancePath: instancePath + '/Booking/Time',
                              schemaPath: '#/properties/Booking/properties/Time/required',
                              keyword: 'required',
                              params: { missingProperty: missing2 },
                              message: "must have required property '" + missing2 + "'",
                              schema:
                                schema68.properties.Booking.properties.Time.required,
                              parentSchema: schema68.properties.Booking.properties.Time,
                              data: data2,
                            },
                          ];
                          return false;
                        } else {
                          if (data2.Start !== undefined) {
                            let data3 = data2.Start;
                            const _errs7 = errors;
                            if (errors === _errs7) {
                              if (errors === _errs7) {
                                if (typeof data3 === 'string') {
                                  if (!formats2.validate(data3)) {
                                    validate83.errors = [
                                      {
                                        instancePath:
                                          instancePath + '/Booking/Time/Start',
                                        schemaPath:
                                          '#/properties/Booking/properties/Time/properties/Start/format',
                                        keyword: 'format',
                                        params: { format: 'date-time' },
                                        message:
                                          'must match format "' + 'date-time' + '"',
                                        schema: 'date-time',
                                        parentSchema:
                                          schema68.properties.Booking.properties.Time
                                            .properties.Start,
                                        data: data3,
                                      },
                                    ];
                                    return false;
                                  }
                                } else {
                                  validate83.errors = [
                                    {
                                      instancePath: instancePath + '/Booking/Time/Start',
                                      schemaPath:
                                        '#/properties/Booking/properties/Time/properties/Start/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema68.properties.Booking.properties.Time
                                          .properties.Start.type,
                                      parentSchema:
                                        schema68.properties.Booking.properties.Time
                                          .properties.Start,
                                      data: data3,
                                    },
                                  ];
                                  return false;
                                }
                              }
                            }
                            var valid2 = _errs7 === errors;
                          } else {
                            var valid2 = true;
                          }
                          if (valid2) {
                            if (data2.End !== undefined) {
                              let data4 = data2.End;
                              const _errs9 = errors;
                              if (errors === _errs9) {
                                if (errors === _errs9) {
                                  if (typeof data4 === 'string') {
                                    if (!formats2.validate(data4)) {
                                      validate83.errors = [
                                        {
                                          instancePath:
                                            instancePath + '/Booking/Time/End',
                                          schemaPath:
                                            '#/properties/Booking/properties/Time/properties/End/format',
                                          keyword: 'format',
                                          params: { format: 'date-time' },
                                          message:
                                            'must match format "' + 'date-time' + '"',
                                          schema: 'date-time',
                                          parentSchema:
                                            schema68.properties.Booking.properties.Time
                                              .properties.End,
                                          data: data4,
                                        },
                                      ];
                                      return false;
                                    }
                                  } else {
                                    validate83.errors = [
                                      {
                                        instancePath: instancePath + '/Booking/Time/End',
                                        schemaPath:
                                          '#/properties/Booking/properties/Time/properties/End/type',
                                        keyword: 'type',
                                        params: { type: 'string' },
                                        message: 'must be string',
                                        schema:
                                          schema68.properties.Booking.properties.Time
                                            .properties.End.type,
                                        parentSchema:
                                          schema68.properties.Booking.properties.Time
                                            .properties.End,
                                        data: data4,
                                      },
                                    ];
                                    return false;
                                  }
                                }
                              }
                              var valid2 = _errs9 === errors;
                            } else {
                              var valid2 = true;
                            }
                          }
                        }
                      } else {
                        validate83.errors = [
                          {
                            instancePath: instancePath + '/Booking/Time',
                            schemaPath: '#/properties/Booking/properties/Time/type',
                            keyword: 'type',
                            params: { type: 'object' },
                            message: 'must be object',
                            schema: schema68.properties.Booking.properties.Time.type,
                            parentSchema: schema68.properties.Booking.properties.Time,
                            data: data2,
                          },
                        ];
                        return false;
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data0.Devices !== undefined) {
                      let data5 = data0.Devices;
                      const _errs11 = errors;
                      if (errors === _errs11) {
                        if (Array.isArray(data5)) {
                          var valid3 = true;
                          const len0 = data5.length;
                          for (let i0 = 0; i0 < len0; i0++) {
                            let data6 = data5[i0];
                            const _errs13 = errors;
                            if (errors === _errs13) {
                              if (errors === _errs13) {
                                if (typeof data6 === 'string') {
                                  if (!formats0(data6)) {
                                    validate83.errors = [
                                      {
                                        instancePath:
                                          instancePath + '/Booking/Devices/' + i0,
                                        schemaPath:
                                          '#/properties/Booking/properties/Devices/items/format',
                                        keyword: 'format',
                                        params: { format: 'uri' },
                                        message: 'must match format "' + 'uri' + '"',
                                        schema: 'uri',
                                        parentSchema:
                                          schema68.properties.Booking.properties.Devices
                                            .items,
                                        data: data6,
                                      },
                                    ];
                                    return false;
                                  }
                                } else {
                                  validate83.errors = [
                                    {
                                      instancePath:
                                        instancePath + '/Booking/Devices/' + i0,
                                      schemaPath:
                                        '#/properties/Booking/properties/Devices/items/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema68.properties.Booking.properties.Devices
                                          .items.type,
                                      parentSchema:
                                        schema68.properties.Booking.properties.Devices
                                          .items,
                                      data: data6,
                                    },
                                  ];
                                  return false;
                                }
                              }
                            }
                            var valid3 = _errs13 === errors;
                            if (!valid3) {
                              break;
                            }
                          }
                        } else {
                          validate83.errors = [
                            {
                              instancePath: instancePath + '/Booking/Devices',
                              schemaPath: '#/properties/Booking/properties/Devices/type',
                              keyword: 'type',
                              params: { type: 'array' },
                              message: 'must be array',
                              schema: schema68.properties.Booking.properties.Devices.type,
                              parentSchema:
                                schema68.properties.Booking.properties.Devices,
                              data: data5,
                            },
                          ];
                          return false;
                        }
                      }
                      var valid1 = _errs11 === errors;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data0.Type !== undefined) {
                        let data7 = data0.Type;
                        const _errs15 = errors;
                        if (typeof data7 !== 'string') {
                          validate83.errors = [
                            {
                              instancePath: instancePath + '/Booking/Type',
                              schemaPath: '#/properties/Booking/properties/Type/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema68.properties.Booking.properties.Type.type,
                              parentSchema: schema68.properties.Booking.properties.Type,
                              data: data7,
                            },
                          ];
                          return false;
                        }
                        if (!(data7 === 'normal')) {
                          validate83.errors = [
                            {
                              instancePath: instancePath + '/Booking/Type',
                              schemaPath: '#/properties/Booking/properties/Type/enum',
                              keyword: 'enum',
                              params: {
                                allowedValues:
                                  schema68.properties.Booking.properties.Type.enum,
                              },
                              message: 'must be equal to one of the allowed values',
                              schema: schema68.properties.Booking.properties.Type.enum,
                              parentSchema: schema68.properties.Booking.properties.Type,
                              data: data7,
                            },
                          ];
                          return false;
                        }
                        var valid1 = _errs15 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data0.Status !== undefined) {
                          let data8 = data0.Status;
                          const _errs17 = errors;
                          if (typeof data8 !== 'string') {
                            validate83.errors = [
                              {
                                instancePath: instancePath + '/Booking/Status',
                                schemaPath: '#/properties/Booking/properties/Status/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema:
                                  schema68.properties.Booking.properties.Status.type,
                                parentSchema:
                                  schema68.properties.Booking.properties.Status,
                                data: data8,
                              },
                            ];
                            return false;
                          }
                          if (
                            !(
                              data8 === 'pending' ||
                              data8 === 'booked' ||
                              data8 === 'rejected' ||
                              data8 === 'cancelled' ||
                              data8 === 'active' ||
                              data8 === 'active-pending' ||
                              data8 === 'active-rejected'
                            )
                          ) {
                            validate83.errors = [
                              {
                                instancePath: instancePath + '/Booking/Status',
                                schemaPath: '#/properties/Booking/properties/Status/enum',
                                keyword: 'enum',
                                params: {
                                  allowedValues:
                                    schema68.properties.Booking.properties.Status.enum,
                                },
                                message: 'must be equal to one of the allowed values',
                                schema:
                                  schema68.properties.Booking.properties.Status.enum,
                                parentSchema:
                                  schema68.properties.Booking.properties.Status,
                                data: data8,
                              },
                            ];
                            return false;
                          }
                          var valid1 = _errs17 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data0.You !== undefined) {
                            let data9 = data0.You;
                            const _errs19 = errors;
                            if (typeof data9 !== 'boolean') {
                              validate83.errors = [
                                {
                                  instancePath: instancePath + '/Booking/You',
                                  schemaPath: '#/properties/Booking/properties/You/type',
                                  keyword: 'type',
                                  params: { type: 'boolean' },
                                  message: 'must be boolean',
                                  schema: schema68.properties.Booking.properties.You.type,
                                  parentSchema:
                                    schema68.properties.Booking.properties.You,
                                  data: data9,
                                },
                              ];
                              return false;
                            }
                            var valid1 = _errs19 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data0.External !== undefined) {
                              let data10 = data0.External;
                              const _errs21 = errors;
                              if (typeof data10 !== 'boolean') {
                                validate83.errors = [
                                  {
                                    instancePath: instancePath + '/Booking/External',
                                    schemaPath:
                                      '#/properties/Booking/properties/External/type',
                                    keyword: 'type',
                                    params: { type: 'boolean' },
                                    message: 'must be boolean',
                                    schema:
                                      schema68.properties.Booking.properties.External
                                        .type,
                                    parentSchema:
                                      schema68.properties.Booking.properties.External,
                                    data: data10,
                                  },
                                ];
                                return false;
                              }
                              var valid1 = _errs21 === errors;
                            } else {
                              var valid1 = true;
                            }
                            if (valid1) {
                              if (data0.Message !== undefined) {
                                let data11 = data0.Message;
                                const _errs23 = errors;
                                if (typeof data11 !== 'string') {
                                  validate83.errors = [
                                    {
                                      instancePath: instancePath + '/Booking/Message',
                                      schemaPath:
                                        '#/properties/Booking/properties/Message/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema68.properties.Booking.properties.Message
                                          .type,
                                      parentSchema:
                                        schema68.properties.Booking.properties.Message,
                                      data: data11,
                                    },
                                  ];
                                  return false;
                                }
                                var valid1 = _errs23 === errors;
                              } else {
                                var valid1 = true;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              validate83.errors = [
                {
                  instancePath: instancePath + '/Booking',
                  schemaPath: '#/properties/Booking/type',
                  keyword: 'type',
                  params: { type: 'object' },
                  message: 'must be object',
                  schema: schema68.properties.Booking.type,
                  parentSchema: schema68.properties.Booking,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Locked !== undefined) {
            let data12 = data.Locked;
            const _errs25 = errors;
            if (typeof data12 !== 'boolean') {
              validate83.errors = [
                {
                  instancePath: instancePath + '/Locked',
                  schemaPath: '#/properties/Locked/type',
                  keyword: 'type',
                  params: { type: 'boolean' },
                  message: 'must be boolean',
                  schema: schema68.properties.Locked.type,
                  parentSchema: schema68.properties.Locked,
                  data: data12,
                },
              ];
              return false;
            }
            var valid0 = _errs25 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate83.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema68.type,
          parentSchema: schema68,
          data,
        },
      ];
      return false;
    }
  }
  validate83.errors = vErrors;
  return errors === 0;
}
exports.validateGetBookingResponse500Request = validate84;
const schema69 = {
  type: 'string',
  description: 'Error code',
  'x-standalone': false,
  'x-name': 'getBookingResponse500Request',
  'x-location':
    '#/paths//booking/{ID}/get/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate84(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate84.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema69.type,
        parentSchema: schema69,
        data,
      },
    ];
    return false;
  }
  validate84.errors = vErrors;
  return errors === 0;
}
exports.validateGetBookingResponse500Response = validate85;
const schema70 = {
  type: 'string',
  description: 'Error code',
  'x-standalone': false,
  'x-name': 'getBookingResponse500Response',
  'x-location':
    '#/paths//booking/{ID}/get/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate85(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate85.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema70.type,
        parentSchema: schema70,
        data,
      },
    ];
    return false;
  }
  validate85.errors = vErrors;
  return errors === 0;
}
exports.validateDestroyBookingResponse500Request = validate86;
const schema71 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'destroyBookingResponse500Request',
  'x-location':
    '#/paths//booking/{ID}/destroy/delete/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate86(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate86.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema71.type,
        parentSchema: schema71,
        data,
      },
    ];
    return false;
  }
  validate86.errors = vErrors;
  return errors === 0;
}
exports.validateDestroyBookingResponse500Response = validate87;
const schema72 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'destroyBookingResponse500Response',
  'x-location':
    '#/paths//booking/{ID}/destroy/delete/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate87(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate87.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema72.type,
        parentSchema: schema72,
        data,
      },
    ];
    return false;
  }
  validate87.errors = vErrors;
  return errors === 0;
}
exports.validateLockBookingResponse200Request = validate88;
const schema73 = {
  type: 'array',
  description:
    'The list of booked devices and selected real devices. Order is guaranteed to be the same as in the booking.',
  items: {
    type: 'object',
    required: ['Requested', 'Selected'],
    properties: {
      Requested: { type: 'string', format: 'uri' },
      Selected: { type: 'string', format: 'uri' },
    },
  },
  'x-standalone': false,
  'x-name': 'lockBookingResponse200Request',
  'x-location':
    '#/paths//booking/{ID}/lock/put/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate88(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.Requested === undefined && (missing0 = 'Requested')) ||
              (data0.Selected === undefined && (missing0 = 'Selected'))
            ) {
              validate88.errors = [
                {
                  instancePath: instancePath + '/' + i0,
                  schemaPath: '#/items/required',
                  keyword: 'required',
                  params: { missingProperty: missing0 },
                  message: "must have required property '" + missing0 + "'",
                  schema: schema73.items.required,
                  parentSchema: schema73.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.Requested !== undefined) {
                let data1 = data0.Requested;
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (errors === _errs3) {
                    if (typeof data1 === 'string') {
                      if (!formats0(data1)) {
                        validate88.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/Requested',
                            schemaPath: '#/items/properties/Requested/format',
                            keyword: 'format',
                            params: { format: 'uri' },
                            message: 'must match format "' + 'uri' + '"',
                            schema: 'uri',
                            parentSchema: schema73.items.properties.Requested,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    } else {
                      validate88.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/Requested',
                          schemaPath: '#/items/properties/Requested/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema73.items.properties.Requested.type,
                          parentSchema: schema73.items.properties.Requested,
                          data: data1,
                        },
                      ];
                      return false;
                    }
                  }
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.Selected !== undefined) {
                  let data2 = data0.Selected;
                  const _errs5 = errors;
                  if (errors === _errs5) {
                    if (errors === _errs5) {
                      if (typeof data2 === 'string') {
                        if (!formats0(data2)) {
                          validate88.errors = [
                            {
                              instancePath: instancePath + '/' + i0 + '/Selected',
                              schemaPath: '#/items/properties/Selected/format',
                              keyword: 'format',
                              params: { format: 'uri' },
                              message: 'must match format "' + 'uri' + '"',
                              schema: 'uri',
                              parentSchema: schema73.items.properties.Selected,
                              data: data2,
                            },
                          ];
                          return false;
                        }
                      } else {
                        validate88.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/Selected',
                            schemaPath: '#/items/properties/Selected/type',
                            keyword: 'type',
                            params: { type: 'string' },
                            message: 'must be string',
                            schema: schema73.items.properties.Selected.type,
                            parentSchema: schema73.items.properties.Selected,
                            data: data2,
                          },
                        ];
                        return false;
                      }
                    }
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
              }
            }
          } else {
            validate88.errors = [
              {
                instancePath: instancePath + '/' + i0,
                schemaPath: '#/items/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema73.items.type,
                parentSchema: schema73.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate88.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
          schema: schema73.type,
          parentSchema: schema73,
          data,
        },
      ];
      return false;
    }
  }
  validate88.errors = vErrors;
  return errors === 0;
}
exports.validateLockBookingResponse200Response = validate89;
const schema74 = {
  type: 'array',
  description:
    'The list of booked devices and selected real devices. Order is guaranteed to be the same as in the booking.',
  items: {
    type: 'object',
    required: ['Requested', 'Selected'],
    properties: {
      Requested: { type: 'string', format: 'uri' },
      Selected: { type: 'string', format: 'uri' },
    },
  },
  'x-standalone': false,
  'x-name': 'lockBookingResponse200Response',
  'x-location':
    '#/paths//booking/{ID}/lock/put/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate89(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.Requested === undefined && (missing0 = 'Requested')) ||
              (data0.Selected === undefined && (missing0 = 'Selected'))
            ) {
              validate89.errors = [
                {
                  instancePath: instancePath + '/' + i0,
                  schemaPath: '#/items/required',
                  keyword: 'required',
                  params: { missingProperty: missing0 },
                  message: "must have required property '" + missing0 + "'",
                  schema: schema74.items.required,
                  parentSchema: schema74.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.Requested !== undefined) {
                let data1 = data0.Requested;
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (errors === _errs3) {
                    if (typeof data1 === 'string') {
                      if (!formats0(data1)) {
                        validate89.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/Requested',
                            schemaPath: '#/items/properties/Requested/format',
                            keyword: 'format',
                            params: { format: 'uri' },
                            message: 'must match format "' + 'uri' + '"',
                            schema: 'uri',
                            parentSchema: schema74.items.properties.Requested,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    } else {
                      validate89.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/Requested',
                          schemaPath: '#/items/properties/Requested/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema74.items.properties.Requested.type,
                          parentSchema: schema74.items.properties.Requested,
                          data: data1,
                        },
                      ];
                      return false;
                    }
                  }
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.Selected !== undefined) {
                  let data2 = data0.Selected;
                  const _errs5 = errors;
                  if (errors === _errs5) {
                    if (errors === _errs5) {
                      if (typeof data2 === 'string') {
                        if (!formats0(data2)) {
                          validate89.errors = [
                            {
                              instancePath: instancePath + '/' + i0 + '/Selected',
                              schemaPath: '#/items/properties/Selected/format',
                              keyword: 'format',
                              params: { format: 'uri' },
                              message: 'must match format "' + 'uri' + '"',
                              schema: 'uri',
                              parentSchema: schema74.items.properties.Selected,
                              data: data2,
                            },
                          ];
                          return false;
                        }
                      } else {
                        validate89.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/Selected',
                            schemaPath: '#/items/properties/Selected/type',
                            keyword: 'type',
                            params: { type: 'string' },
                            message: 'must be string',
                            schema: schema74.items.properties.Selected.type,
                            parentSchema: schema74.items.properties.Selected,
                            data: data2,
                          },
                        ];
                        return false;
                      }
                    }
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
              }
            }
          } else {
            validate89.errors = [
              {
                instancePath: instancePath + '/' + i0,
                schemaPath: '#/items/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema74.items.type,
                parentSchema: schema74.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate89.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
          schema: schema74.type,
          parentSchema: schema74,
          data,
        },
      ];
      return false;
    }
  }
  validate89.errors = vErrors;
  return errors === 0;
}
exports.validateLockBookingResponse500Request = validate90;
const schema75 = {
  type: 'string',
  description: 'Error string',
  'x-standalone': false,
  'x-name': 'lockBookingResponse500Request',
  'x-location':
    '#/paths//booking/{ID}/lock/put/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate90(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate90.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema75.type,
        parentSchema: schema75,
        data,
      },
    ];
    return false;
  }
  validate90.errors = vErrors;
  return errors === 0;
}
exports.validateLockBookingResponse500Response = validate91;
const schema76 = {
  type: 'string',
  description: 'Error string',
  'x-standalone': false,
  'x-name': 'lockBookingResponse500Response',
  'x-location':
    '#/paths//booking/{ID}/lock/put/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate91(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate91.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema76.type,
        parentSchema: schema76,
        data,
      },
    ];
    return false;
  }
  validate91.errors = vErrors;
  return errors === 0;
}
exports.validateUnlockBookingResponse500Request = validate92;
const schema77 = {
  type: 'string',
  description: 'Error description.',
  'x-standalone': false,
  'x-name': 'unlockBookingResponse500Request',
  'x-location':
    '#/paths//booking/{ID}/lock/delete/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate92(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate92.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema77.type,
        parentSchema: schema77,
        data,
      },
    ];
    return false;
  }
  validate92.errors = vErrors;
  return errors === 0;
}
exports.validateUnlockBookingResponse500Response = validate93;
const schema78 = {
  type: 'string',
  description: 'Error description.',
  'x-standalone': false,
  'x-name': 'unlockBookingResponse500Response',
  'x-location':
    '#/paths//booking/{ID}/lock/delete/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate93(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate93.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema78.type,
        parentSchema: schema78,
        data,
      },
    ];
    return false;
  }
  validate93.errors = vErrors;
  return errors === 0;
}
exports.validateBookingCallbackResponse500Request = validate94;
const schema79 = {
  type: 'string',
  description: 'Error description.',
  'x-standalone': false,
  'x-name': 'bookingCallbackResponse500Request',
  'x-location':
    '#/paths//booking_callback/{ID}/post/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate94(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate94.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema79.type,
        parentSchema: schema79,
        data,
      },
    ];
    return false;
  }
  validate94.errors = vErrors;
  return errors === 0;
}
exports.validateBookingCallbackResponse500Response = validate95;
const schema80 = {
  type: 'string',
  description: 'Error description.',
  'x-standalone': false,
  'x-name': 'bookingCallbackResponse500Response',
  'x-location':
    '#/paths//booking_callback/{ID}/post/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate95(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate95.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema80.type,
        parentSchema: schema80,
        data,
      },
    ];
    return false;
  }
  validate95.errors = vErrors;
  return errors === 0;
}
