/* eslint-disable @typescript-eslint/no-explicit-any */
//@ts-nocheck
/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */

import { ValidationError } from '@crosslab/service-common';
import { Request, Response, RequestHandler } from 'express';
import {
    
} from "./types"

import * as type_validation from "./type_validation.cjs"
import * as operations from './operations'

/**
 * This function validates the GET request on /auth
 */
export function validateGetAuth(
    handler: RequestHandler<
        operations.getAuthPathParametersType,
        operations.getAuthResponseBodyType,
        operations.getAuthRequestBodyType>
) {
    return async (req: Request, res: Response, next: any) => {
        try{
            const parameters = {
                    "Authorization": req.get("Authorization"),
			"X-Real-IP": req.get("X-Real-IP"),
			"X-Forwarded-Proto": req.get("X-Forwarded-Proto")
                }
                
                        if(parameters["Authorization"] !== undefined) {if (!type_validation.validateAuthorizationRequest(parameters["Authorization"])) {
                        const errors = (type_validation.validateAuthorizationRequest as any).errors
                        throw new ValidationError('Validation Error', errors, 400);
                    }
                        }
                        if(parameters["X-Real-IP"] !== undefined) {if (!type_validation.validateXRealIPRequest(parameters["X-Real-IP"])) {
                        const errors = (type_validation.validateXRealIPRequest as any).errors
                        throw new ValidationError('Validation Error', errors, 400);
                    }
                        }
                        if(parameters["X-Forwarded-Proto"] !== undefined) {if (!type_validation.validateXForwardedProtoRequest(parameters["X-Forwarded-Proto"])) {
                        const errors = (type_validation.validateXForwardedProtoRequest as any).errors
                        throw new ValidationError('Validation Error', errors, 400);
                    }
                        }
            return await handler(req as any, res, next);
        } catch (err) {
            next(err);
        }
    }
}

/**
 * This function validates the POST request on /login
 */
export function validatePostLogin(
    handler: RequestHandler<
        operations.postLoginPathParametersType,
        operations.postLoginResponseBodyType,
        operations.postLoginRequestBodyType>
) {
    return async (req: Request, res: Response, next: any) => {
        try{
            if (!type_validation.validatePostLoginRequestBodyRequest(req.body)) {
                    const errors = (type_validation.validatePostLoginRequestBodyRequest as any).errors
                    throw new ValidationError('Validation Error', errors, 400);
                }
            return await handler(req as any, res, next);
        } catch (err) {
            next(err);
        }
    }
}

/**
 * This function validates the POST request on /logout
 */
export function validatePostLogout(
    handler: RequestHandler<
        operations.postLogoutPathParametersType,
        operations.postLogoutResponseBodyType,
        operations.postLogoutRequestBodyType>
) {
    return async (req: Request, res: Response, next: any) => {
        try{
            if (!type_validation.validatePostLogoutRequestBodyRequest(req.body)) {
                    const errors = (type_validation.validatePostLogoutRequestBodyRequest as any).errors
                    throw new ValidationError('Validation Error', errors, 400);
                }
            return await handler(req as any, res, next);
        } catch (err) {
            next(err);
        }
    }
}

/**
 * This function validates the GET request on /users
 */
export function validateGetUsers(
    handler: RequestHandler<
        operations.getUsersPathParametersType,
        operations.getUsersResponseBodyType,
        operations.getUsersRequestBodyType>
) {
    return async (req: Request, res: Response, next: any) => {
        try{
            return await handler(req as any, res, next);
        } catch (err) {
            next(err);
        }
    }
}

/**
 * This function validates the POST request on /users
 */
export function validatePostUsers(
    handler: RequestHandler<
        operations.postUsersPathParametersType,
        operations.postUsersResponseBodyType,
        operations.postUsersRequestBodyType>
) {
    return async (req: Request, res: Response, next: any) => {
        try{
            if (!type_validation.validatePostUsersRequestBodyRequest(req.body)) {
                    const errors = (type_validation.validatePostUsersRequestBodyRequest as any).errors
                    throw new ValidationError('Validation Error', errors, 400);
                }
            return await handler(req as any, res, next);
        } catch (err) {
            next(err);
        }
    }
}

/**
 * This function validates the GET request on /users/{user_id}
 */
export function validateGetUsersByUserId(
    handler: RequestHandler<
        operations.getUsersByUserIdPathParametersType,
        operations.getUsersByUserIdResponseBodyType,
        operations.getUsersByUserIdRequestBodyType>
) {
    return async (req: Request, res: Response, next: any) => {
        try{
            const parameters = {
                    "user_id": req.params["user_id"]
                }
                if (!type_validation.validateUserIdRequest(parameters["user_id"])) {
                        const errors = (type_validation.validateUserIdRequest as any).errors
                        throw new ValidationError('Validation Error', errors, 400);
                    }
            return await handler(req as any, res, next);
        } catch (err) {
            next(err);
        }
    }
}

/**
 * This function validates the PATCH request on /users/{user_id}
 */
export function validatePatchUsersByUserId(
    handler: RequestHandler<
        operations.patchUsersByUserIdPathParametersType,
        operations.patchUsersByUserIdResponseBodyType,
        operations.patchUsersByUserIdRequestBodyType>
) {
    return async (req: Request, res: Response, next: any) => {
        try{
            const parameters = {
                    "user_id": req.params["user_id"]
                }
                if (!type_validation.validateUserIdRequest(parameters["user_id"])) {
                        const errors = (type_validation.validateUserIdRequest as any).errors
                        throw new ValidationError('Validation Error', errors, 400);
                    }
            if (!type_validation.validatePatchUsersByUserIdRequestBodyRequest(req.body)) {
                    const errors = (type_validation.validatePatchUsersByUserIdRequestBodyRequest as any).errors
                    throw new ValidationError('Validation Error', errors, 400);
                }
            return await handler(req as any, res, next);
        } catch (err) {
            next(err);
        }
    }
}

/**
 * This function validates the DELETE request on /users/{user_id}
 */
export function validateDeleteUsersByUserId(
    handler: RequestHandler<
        operations.deleteUsersByUserIdPathParametersType,
        operations.deleteUsersByUserIdResponseBodyType,
        operations.deleteUsersByUserIdRequestBodyType>
) {
    return async (req: Request, res: Response, next: any) => {
        try{
            const parameters = {
                    "user_id": req.params["user_id"]
                }
                if (!type_validation.validateUserIdRequest(parameters["user_id"])) {
                        const errors = (type_validation.validateUserIdRequest as any).errors
                        throw new ValidationError('Validation Error', errors, 400);
                    }
            return await handler(req as any, res, next);
        } catch (err) {
            next(err);
        }
    }
}

/**
 * This function validates the GET request on /identity
 */
export function validateGetIdentity(
    handler: RequestHandler<
        operations.getIdentityPathParametersType,
        operations.getIdentityResponseBodyType,
        operations.getIdentityRequestBodyType>
) {
    return async (req: Request, res: Response, next: any) => {
        try{
            return await handler(req as any, res, next);
        } catch (err) {
            next(err);
        }
    }
}

/**
 * This function validates the PATCH request on /identity
 */
export function validatePatchIdentity(
    handler: RequestHandler<
        operations.patchIdentityPathParametersType,
        operations.patchIdentityResponseBodyType,
        operations.patchIdentityRequestBodyType>
) {
    return async (req: Request, res: Response, next: any) => {
        try{
            if (req.body !== undefined) {
                if (!type_validation.validatePatchIdentityRequestBodyRequest(req.body)) {
                    const errors = (type_validation.validatePatchIdentityRequestBodyRequest as any).errors
                    throw new ValidationError('Validation Error', errors, 400);
                }
                    }
            return await handler(req as any, res, next);
        } catch (err) {
            next(err);
        }
    }
}

/**
 * This function validates the POST request on /token
 */
export function validatePostToken(
    handler: RequestHandler<
        operations.postTokenPathParametersType,
        operations.postTokenResponseBodyType,
        operations.postTokenRequestBodyType>
) {
    return async (req: Request, res: Response, next: any) => {
        try{
            if (!type_validation.validatePostTokenRequestBodyRequest(req.body)) {
                    const errors = (type_validation.validatePostTokenRequestBodyRequest as any).errors
                    throw new ValidationError('Validation Error', errors, 400);
                }
            return await handler(req as any, res, next);
        } catch (err) {
            next(err);
        }
    }
}