//@ts-nocheck
/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */
'use strict';
exports.validateUserType = validate21;
const schema6 = {
  title: 'User Type',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri' },
    username: { type: 'string' },
    scopes: { type: 'array', items: { type: 'string' } },
  },
  required: ['url', 'username', 'scopes'],
  'x-typeguard': true,
  'x-standalone': true,
  'x-name': 'UserType',
  'x-location': '#/components/schemas/user_type',
  'x-service-name': 'Utility',
  'x-schema-type': 'all',
};
const formats0 = require('ajv-formats/dist/formats').fullFormats.uri;
function validate21(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.scopes === undefined && (missing0 = 'scopes'))
      ) {
        validate21.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema6.required,
            parentSchema: schema6,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema6.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate21.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema6.properties.url.type,
                    parentSchema: schema6.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.username !== undefined) {
            let data1 = data.username;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate21.errors = [
                {
                  instancePath: instancePath + '/username',
                  schemaPath: '#/properties/username/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema6.properties.username.type,
                  parentSchema: schema6.properties.username,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.scopes !== undefined) {
              let data2 = data.scopes;
              const _errs5 = errors;
              if (errors === _errs5) {
                if (Array.isArray(data2)) {
                  var valid1 = true;
                  const len0 = data2.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data3 = data2[i0];
                    const _errs7 = errors;
                    if (typeof data3 !== 'string') {
                      validate21.errors = [
                        {
                          instancePath: instancePath + '/scopes/' + i0,
                          schemaPath: '#/properties/scopes/items/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema6.properties.scopes.items.type,
                          parentSchema: schema6.properties.scopes.items,
                          data: data3,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs7 === errors;
                    if (!valid1) {
                      break;
                    }
                  }
                } else {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/scopes',
                      schemaPath: '#/properties/scopes/type',
                      keyword: 'type',
                      params: { type: 'array' },
                      message: 'must be array',
                      schema: schema6.properties.scopes.type,
                      parentSchema: schema6.properties.scopes,
                      data: data2,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate21.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema6.type,
          parentSchema: schema6,
          data,
        },
      ];
      return false;
    }
  }
  validate21.errors = vErrors;
  return errors === 0;
}
exports.validateCredentials = validate22;
const schema7 = {
  title: 'Credentials',
  type: 'object',
  properties: {
    username: { description: 'Username of the user.', type: 'string' },
    password: { description: 'Password of the user.', type: 'string' },
  },
  required: ['username', 'password'],
  'x-standalone': true,
  'x-name': 'Credentials',
  'x-location': '#/components/schemas/credentials',
  'x-schema-type': 'all',
};
function validate22(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate22.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema7.required,
            parentSchema: schema7,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate22.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema7.properties.username.type,
                parentSchema: schema7.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate22.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema7.properties.password.type,
                  parentSchema: schema7.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate22.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema7.type,
          parentSchema: schema7,
          data,
        },
      ];
      return false;
    }
  }
  validate22.errors = vErrors;
  return errors === 0;
}
exports.validateAuthMethod = validate23;
const schema8 = {
  title: 'AuthMethod',
  type: 'string',
  description: 'Authentication method.',
  enum: ['tui', 'local'],
  'x-standalone': true,
  'x-name': 'AuthMethod',
  'x-location': '#/components/schemas/auth_method',
  'x-schema-type': 'all',
};
function validate23(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate23.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema8.type,
        parentSchema: schema8,
        data,
      },
    ];
    return false;
  }
  if (!(data === 'tui' || data === 'local')) {
    validate23.errors = [
      {
        instancePath,
        schemaPath: '#/enum',
        keyword: 'enum',
        params: { allowedValues: schema8.enum },
        message: 'must be equal to one of the allowed values',
        schema: schema8.enum,
        parentSchema: schema8,
        data,
      },
    ];
    return false;
  }
  validate23.errors = vErrors;
  return errors === 0;
}
exports.validateUser = validate24;
const schema9 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['url', 'id', 'username', 'password'],
  'x-standalone': true,
  'x-name': 'User',
  'x-location': '#/components/schemas/user',
  'x-schema-type': 'all',
};
function validate24(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate24.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema9.required,
            parentSchema: schema9,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate24.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema9.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate24.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema9.properties.url.type,
                    parentSchema: schema9.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate24.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema9.properties.id.type,
                  parentSchema: schema9.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate24.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema9.properties.username.type,
                    parentSchema: schema9.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== 'string') {
                  validate24.errors = [
                    {
                      instancePath: instancePath + '/password',
                      schemaPath: '#/properties/password/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema9.properties.password.type,
                      parentSchema: schema9.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate24.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema9.type,
          parentSchema: schema9,
          data,
        },
      ];
      return false;
    }
  }
  validate24.errors = vErrors;
  return errors === 0;
}
exports.validateUserUpdate = validate25;
const schema10 = {
  title: 'User Update',
  type: 'object',
  properties: { password: { type: 'string', writeOnly: true } },
  required: ['password'],
  'x-standalone': true,
  'x-name': 'UserUpdate',
  'x-location': '#/components/schemas/user_update',
  'x-schema-type': 'all',
};
function validate25(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = 'password')) {
        validate25.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema10.required,
            parentSchema: schema10,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== 'string') {
            validate25.errors = [
              {
                instancePath: instancePath + '/password',
                schemaPath: '#/properties/password/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema10.properties.password.type,
                parentSchema: schema10.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate25.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema10.type,
          parentSchema: schema10,
          data,
        },
      ];
      return false;
    }
  }
  validate25.errors = vErrors;
  return errors === 0;
}
exports.validateAuthorization = validate26;
const schema11 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'Authorization',
  'x-location': '#/components/parameters/authorization/schema',
  'x-schema-type': 'all',
};
function validate26(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate26.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema11.type,
        parentSchema: schema11,
        data,
      },
    ];
    return false;
  }
  validate26.errors = vErrors;
  return errors === 0;
}
exports.validateXRealIP = validate27;
const schema12 = {
  type: 'string',
  format: 'ipv4',
  description: 'The IP address of the client.',
  'x-standalone': false,
  'x-name': 'XRealIP',
  'x-location': '#/components/parameters/x_real_ip/schema',
  'x-schema-type': 'all',
};
const formats4 =
  /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
function validate27(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === 'string') {
        if (!formats4.test(data)) {
          validate27.errors = [
            {
              instancePath,
              schemaPath: '#/format',
              keyword: 'format',
              params: { format: 'ipv4' },
              message: 'must match format "' + 'ipv4' + '"',
              schema: 'ipv4',
              parentSchema: schema12,
              data,
            },
          ];
          return false;
        }
      } else {
        validate27.errors = [
          {
            instancePath,
            schemaPath: '#/type',
            keyword: 'type',
            params: { type: 'string' },
            message: 'must be string',
            schema: schema12.type,
            parentSchema: schema12,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate27.errors = vErrors;
  return errors === 0;
}
exports.validateXForwardedProto = validate28;
const schema13 = {
  type: 'string',
  description: 'The protocol of the client.',
  'x-standalone': false,
  'x-name': 'XForwardedProto',
  'x-location': '#/components/parameters/x_forwarded_proto/schema',
  'x-schema-type': 'all',
};
function validate28(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate28.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema13.type,
        parentSchema: schema13,
        data,
      },
    ];
    return false;
  }
  validate28.errors = vErrors;
  return errors === 0;
}
exports.validateUserId = validate29;
const schema14 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'UserId',
  'x-location': '#/components/parameters/user_id/schema',
  'x-schema-type': 'all',
};
function validate29(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate29.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema14.type,
        parentSchema: schema14,
        data,
      },
    ];
    return false;
  }
  validate29.errors = vErrors;
  return errors === 0;
}
exports.validateGetAuthHeaderXRequestAuthentication = validate30;
const schema15 = {
  type: 'string',
  format: 'jwt',
  description: 'The JWT which represents the authenticated user.',
  'x-standalone': false,
  'x-name': 'getAuthHeaderXRequestAuthentication',
  'x-location': '#/paths//auth/get/responses/200/headers/X-Request-Authentication/schema',
  'x-schema-type': 'all',
};
const formats6 = /^Bearer ([a-zA-Z0-9_=]+)\.([a-zA-Z0-9_=]+)\.([a-zA-Z0-9_\-+/=]*)/;
function validate30(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === 'string') {
        if (!formats6.test(data)) {
          validate30.errors = [
            {
              instancePath,
              schemaPath: '#/format',
              keyword: 'format',
              params: { format: 'jwt' },
              message: 'must match format "' + 'jwt' + '"',
              schema: 'jwt',
              parentSchema: schema15,
              data,
            },
          ];
          return false;
        }
      } else {
        validate30.errors = [
          {
            instancePath,
            schemaPath: '#/type',
            keyword: 'type',
            params: { type: 'string' },
            message: 'must be string',
            schema: schema15.type,
            parentSchema: schema15,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate30.errors = vErrors;
  return errors === 0;
}
exports.validatePostLoginRequestBody = validate31;
const schema16 = {
  allOf: [
    {
      title: 'Credentials',
      type: 'object',
      properties: {
        username: { description: 'Username of the user.', type: 'string' },
        password: { description: 'Password of the user.', type: 'string' },
      },
      required: ['username', 'password'],
    },
    {
      type: 'object',
      properties: {
        method: {
          title: 'AuthMethod',
          type: 'string',
          description: 'Authentication method.',
          enum: ['tui', 'local'],
        },
      },
    },
  ],
  'x-standalone': false,
  'x-name': 'postLoginRequestBody',
  'x-location': '#/paths//login/post/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate31(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  if (errors === _errs0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate31.errors = [
          {
            instancePath,
            schemaPath: '#/allOf/0/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema16.allOf[0].required,
            parentSchema: schema16.allOf[0],
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs2 = errors;
          if (typeof data0 !== 'string') {
            validate31.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/allOf/0/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema16.allOf[0].properties.username.type,
                parentSchema: schema16.allOf[0].properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid1 = _errs2 === errors;
        } else {
          var valid1 = true;
        }
        if (valid1) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs4 = errors;
            if (typeof data1 !== 'string') {
              validate31.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/allOf/0/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema16.allOf[0].properties.password.type,
                  parentSchema: schema16.allOf[0].properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid1 = _errs4 === errors;
          } else {
            var valid1 = true;
          }
        }
      }
    } else {
      validate31.errors = [
        {
          instancePath,
          schemaPath: '#/allOf/0/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema16.allOf[0].type,
          parentSchema: schema16.allOf[0],
          data,
        },
      ];
      return false;
    }
  }
  var valid0 = _errs0 === errors;
  if (valid0) {
    const _errs6 = errors;
    if (errors === _errs6) {
      if (data && typeof data == 'object' && !Array.isArray(data)) {
        if (data.method !== undefined) {
          let data2 = data.method;
          if (typeof data2 !== 'string') {
            validate31.errors = [
              {
                instancePath: instancePath + '/method',
                schemaPath: '#/allOf/1/properties/method/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema16.allOf[1].properties.method.type,
                parentSchema: schema16.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
          if (!(data2 === 'tui' || data2 === 'local')) {
            validate31.errors = [
              {
                instancePath: instancePath + '/method',
                schemaPath: '#/allOf/1/properties/method/enum',
                keyword: 'enum',
                params: { allowedValues: schema16.allOf[1].properties.method.enum },
                message: 'must be equal to one of the allowed values',
                schema: schema16.allOf[1].properties.method.enum,
                parentSchema: schema16.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
        }
      } else {
        validate31.errors = [
          {
            instancePath,
            schemaPath: '#/allOf/1/type',
            keyword: 'type',
            params: { type: 'object' },
            message: 'must be object',
            schema: schema16.allOf[1].type,
            parentSchema: schema16.allOf[1],
            data,
          },
        ];
        return false;
      }
    }
    var valid0 = _errs6 === errors;
  }
  validate31.errors = vErrors;
  return errors === 0;
}
exports.validatePostLoginResponse201 = validate32;
const schema17 = {
  description: 'The access token.',
  type: 'string',
  'x-standalone': false,
  'x-name': 'postLoginResponse201',
  'x-location': '#/paths//login/post/responses/201/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate32(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate32.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema17.type,
        parentSchema: schema17,
        data,
      },
    ];
    return false;
  }
  validate32.errors = vErrors;
  return errors === 0;
}
exports.validatePostLogoutRequestBody = validate33;
const schema18 = {
  type: 'object',
  properties: { token: { type: 'string', description: 'The token to be invalidated.' } },
  'x-standalone': false,
  'x-name': 'postLogoutRequestBody',
  'x-location': '#/paths//logout/post/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate33(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.token !== undefined) {
        let data0 = data.token;
        if (typeof data0 !== 'string') {
          validate33.errors = [
            {
              instancePath: instancePath + '/token',
              schemaPath: '#/properties/token/type',
              keyword: 'type',
              params: { type: 'string' },
              message: 'must be string',
              schema: schema18.properties.token.type,
              parentSchema: schema18.properties.token,
              data: data0,
            },
          ];
          return false;
        }
      }
    } else {
      validate33.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema18.type,
          parentSchema: schema18,
          data,
        },
      ];
      return false;
    }
  }
  validate33.errors = vErrors;
  return errors === 0;
}
exports.validateGetUsersResponse200 = validate34;
const schema19 = {
  type: 'array',
  items: {
    title: 'User',
    type: 'object',
    properties: {
      url: { type: 'string', format: 'uri', readOnly: true },
      id: { type: 'string', readOnly: true },
      username: { type: 'string' },
      password: { type: 'string', writeOnly: true },
    },
    required: ['url', 'id', 'username', 'password'],
  },
  'x-standalone': false,
  'x-name': 'getUsersResponse200',
  'x-location': '#/paths//users/get/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate34(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.url === undefined && (missing0 = 'url')) ||
              (data0.id === undefined && (missing0 = 'id')) ||
              (data0.username === undefined && (missing0 = 'username')) ||
              (data0.password === undefined && (missing0 = 'password'))
            ) {
              validate34.errors = [
                {
                  instancePath: instancePath + '/' + i0,
                  schemaPath: '#/items/required',
                  keyword: 'required',
                  params: { missingProperty: missing0 },
                  message: "must have required property '" + missing0 + "'",
                  schema: schema19.items.required,
                  parentSchema: schema19.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.url !== undefined) {
                let data1 = data0.url;
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (errors === _errs3) {
                    if (typeof data1 === 'string') {
                      if (!formats0(data1)) {
                        validate34.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/url',
                            schemaPath: '#/items/properties/url/format',
                            keyword: 'format',
                            params: { format: 'uri' },
                            message: 'must match format "' + 'uri' + '"',
                            schema: 'uri',
                            parentSchema: schema19.items.properties.url,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    } else {
                      validate34.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/url',
                          schemaPath: '#/items/properties/url/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema19.items.properties.url.type,
                          parentSchema: schema19.items.properties.url,
                          data: data1,
                        },
                      ];
                      return false;
                    }
                  }
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.id !== undefined) {
                  let data2 = data0.id;
                  const _errs5 = errors;
                  if (typeof data2 !== 'string') {
                    validate34.errors = [
                      {
                        instancePath: instancePath + '/' + i0 + '/id',
                        schemaPath: '#/items/properties/id/type',
                        keyword: 'type',
                        params: { type: 'string' },
                        message: 'must be string',
                        schema: schema19.items.properties.id.type,
                        parentSchema: schema19.items.properties.id,
                        data: data2,
                      },
                    ];
                    return false;
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.username !== undefined) {
                    let data3 = data0.username;
                    const _errs7 = errors;
                    if (typeof data3 !== 'string') {
                      validate34.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/username',
                          schemaPath: '#/items/properties/username/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema19.items.properties.username.type,
                          parentSchema: schema19.items.properties.username,
                          data: data3,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs7 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data0.password !== undefined) {
                      let data4 = data0.password;
                      const _errs9 = errors;
                      if (typeof data4 !== 'string') {
                        validate34.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/password',
                            schemaPath: '#/items/properties/password/type',
                            keyword: 'type',
                            params: { type: 'string' },
                            message: 'must be string',
                            schema: schema19.items.properties.password.type,
                            parentSchema: schema19.items.properties.password,
                            data: data4,
                          },
                        ];
                        return false;
                      }
                      var valid1 = _errs9 === errors;
                    } else {
                      var valid1 = true;
                    }
                  }
                }
              }
            }
          } else {
            validate34.errors = [
              {
                instancePath: instancePath + '/' + i0,
                schemaPath: '#/items/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema19.items.type,
                parentSchema: schema19.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate34.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
          schema: schema19.type,
          parentSchema: schema19,
          data,
        },
      ];
      return false;
    }
  }
  validate34.errors = vErrors;
  return errors === 0;
}
exports.validatePostUsersRequestBody = validate35;
const schema20 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['url', 'id', 'username', 'password'],
  'x-standalone': false,
  'x-name': 'postUsersRequestBody',
  'x-location': '#/paths//users/post/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate35(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate35.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema20.required,
            parentSchema: schema20,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate35.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema20.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate35.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema20.properties.url.type,
                    parentSchema: schema20.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate35.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema20.properties.id.type,
                  parentSchema: schema20.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate35.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema20.properties.username.type,
                    parentSchema: schema20.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== 'string') {
                  validate35.errors = [
                    {
                      instancePath: instancePath + '/password',
                      schemaPath: '#/properties/password/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema20.properties.password.type,
                      parentSchema: schema20.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate35.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema20.type,
          parentSchema: schema20,
          data,
        },
      ];
      return false;
    }
  }
  validate35.errors = vErrors;
  return errors === 0;
}
exports.validatePostUsersResponse201 = validate36;
const schema21 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['url', 'id', 'username', 'password'],
  'x-standalone': false,
  'x-name': 'postUsersResponse201',
  'x-location': '#/paths//users/post/responses/201/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate36(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate36.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema21.required,
            parentSchema: schema21,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate36.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema21.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate36.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema21.properties.url.type,
                    parentSchema: schema21.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate36.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema21.properties.id.type,
                  parentSchema: schema21.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate36.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema21.properties.username.type,
                    parentSchema: schema21.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== 'string') {
                  validate36.errors = [
                    {
                      instancePath: instancePath + '/password',
                      schemaPath: '#/properties/password/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema21.properties.password.type,
                      parentSchema: schema21.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate36.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema21.type,
          parentSchema: schema21,
          data,
        },
      ];
      return false;
    }
  }
  validate36.errors = vErrors;
  return errors === 0;
}
exports.validateGetUsersByUserIdResponse200 = validate37;
const schema22 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['url', 'id', 'username', 'password'],
  'x-standalone': false,
  'x-name': 'getUsersByUserIdResponse200',
  'x-location':
    '#/paths//users/{user_id}/get/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate37(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate37.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema22.required,
            parentSchema: schema22,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate37.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema22.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate37.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema22.properties.url.type,
                    parentSchema: schema22.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate37.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema22.properties.id.type,
                  parentSchema: schema22.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate37.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema22.properties.username.type,
                    parentSchema: schema22.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== 'string') {
                  validate37.errors = [
                    {
                      instancePath: instancePath + '/password',
                      schemaPath: '#/properties/password/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema22.properties.password.type,
                      parentSchema: schema22.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate37.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema22.type,
          parentSchema: schema22,
          data,
        },
      ];
      return false;
    }
  }
  validate37.errors = vErrors;
  return errors === 0;
}
exports.validatePatchUsersByUserIdRequestBody = validate38;
const schema23 = {
  title: 'User Update',
  type: 'object',
  properties: { password: { type: 'string', writeOnly: true } },
  required: ['password'],
  'x-standalone': false,
  'x-name': 'patchUsersByUserIdRequestBody',
  'x-location':
    '#/paths//users/{user_id}/patch/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate38(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = 'password')) {
        validate38.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema23.required,
            parentSchema: schema23,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== 'string') {
            validate38.errors = [
              {
                instancePath: instancePath + '/password',
                schemaPath: '#/properties/password/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema23.properties.password.type,
                parentSchema: schema23.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate38.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema23.type,
          parentSchema: schema23,
          data,
        },
      ];
      return false;
    }
  }
  validate38.errors = vErrors;
  return errors === 0;
}
exports.validatePatchUsersByUserIdResponse200 = validate39;
const schema24 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['url', 'id', 'username', 'password'],
  'x-standalone': false,
  'x-name': 'patchUsersByUserIdResponse200',
  'x-location':
    '#/paths//users/{user_id}/patch/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate39(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate39.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema24.required,
            parentSchema: schema24,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate39.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema24.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate39.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema24.properties.url.type,
                    parentSchema: schema24.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate39.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema24.properties.id.type,
                  parentSchema: schema24.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate39.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema24.properties.username.type,
                    parentSchema: schema24.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== 'string') {
                  validate39.errors = [
                    {
                      instancePath: instancePath + '/password',
                      schemaPath: '#/properties/password/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema24.properties.password.type,
                      parentSchema: schema24.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate39.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema24.type,
          parentSchema: schema24,
          data,
        },
      ];
      return false;
    }
  }
  validate39.errors = vErrors;
  return errors === 0;
}
exports.validateGetIdentityResponse200 = validate40;
const schema25 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['url', 'id', 'username', 'password'],
  'x-standalone': false,
  'x-name': 'getIdentityResponse200',
  'x-location': '#/paths//identity/get/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate40(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate40.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema25.required,
            parentSchema: schema25,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate40.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema25.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate40.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema25.properties.url.type,
                    parentSchema: schema25.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate40.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema25.properties.id.type,
                  parentSchema: schema25.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate40.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema25.properties.username.type,
                    parentSchema: schema25.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== 'string') {
                  validate40.errors = [
                    {
                      instancePath: instancePath + '/password',
                      schemaPath: '#/properties/password/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema25.properties.password.type,
                      parentSchema: schema25.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate40.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema25.type,
          parentSchema: schema25,
          data,
        },
      ];
      return false;
    }
  }
  validate40.errors = vErrors;
  return errors === 0;
}
exports.validatePatchIdentityRequestBody = validate41;
const schema26 = {
  title: 'User Update',
  type: 'object',
  properties: { password: { type: 'string', writeOnly: true } },
  required: ['password'],
  'x-standalone': false,
  'x-name': 'patchIdentityRequestBody',
  'x-location': '#/paths//identity/patch/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate41(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = 'password')) {
        validate41.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema26.required,
            parentSchema: schema26,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== 'string') {
            validate41.errors = [
              {
                instancePath: instancePath + '/password',
                schemaPath: '#/properties/password/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema26.properties.password.type,
                parentSchema: schema26.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate41.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema26.type,
          parentSchema: schema26,
          data,
        },
      ];
      return false;
    }
  }
  validate41.errors = vErrors;
  return errors === 0;
}
exports.validatePatchIdentityResponse200 = validate42;
const schema27 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['url', 'id', 'username', 'password'],
  'x-standalone': false,
  'x-name': 'patchIdentityResponse200',
  'x-location': '#/paths//identity/patch/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate42(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate42.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema27.required,
            parentSchema: schema27,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate42.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema27.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate42.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema27.properties.url.type,
                    parentSchema: schema27.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate42.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema27.properties.id.type,
                  parentSchema: schema27.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate42.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema27.properties.username.type,
                    parentSchema: schema27.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== 'string') {
                  validate42.errors = [
                    {
                      instancePath: instancePath + '/password',
                      schemaPath: '#/properties/password/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema27.properties.password.type,
                      parentSchema: schema27.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate42.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema27.type,
          parentSchema: schema27,
          data,
        },
      ];
      return false;
    }
  }
  validate42.errors = vErrors;
  return errors === 0;
}
exports.validatePostTokenRequestBody = validate43;
const schema28 = {
  type: 'object',
  properties: {
    username: { type: 'string', description: 'The username of the user.' },
    claims: {
      type: 'object',
      description:
        'The claims that will be added to the token. If left empty, the token will have the full scope of the user.\n',
    },
  },
  'x-standalone': false,
  'x-name': 'postTokenRequestBody',
  'x-location': '#/paths//token/post/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate43(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.username !== undefined) {
        let data0 = data.username;
        const _errs1 = errors;
        if (typeof data0 !== 'string') {
          validate43.errors = [
            {
              instancePath: instancePath + '/username',
              schemaPath: '#/properties/username/type',
              keyword: 'type',
              params: { type: 'string' },
              message: 'must be string',
              schema: schema28.properties.username.type,
              parentSchema: schema28.properties.username,
              data: data0,
            },
          ];
          return false;
        }
        var valid0 = _errs1 === errors;
      } else {
        var valid0 = true;
      }
      if (valid0) {
        if (data.claims !== undefined) {
          let data1 = data.claims;
          const _errs3 = errors;
          if (!(data1 && typeof data1 == 'object' && !Array.isArray(data1))) {
            validate43.errors = [
              {
                instancePath: instancePath + '/claims',
                schemaPath: '#/properties/claims/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema28.properties.claims.type,
                parentSchema: schema28.properties.claims,
                data: data1,
              },
            ];
            return false;
          }
          var valid0 = _errs3 === errors;
        } else {
          var valid0 = true;
        }
      }
    } else {
      validate43.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema28.type,
          parentSchema: schema28,
          data,
        },
      ];
      return false;
    }
  }
  validate43.errors = vErrors;
  return errors === 0;
}
exports.validatePostTokenResponse201 = validate44;
const schema29 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'postTokenResponse201',
  'x-location': '#/paths//token/post/responses/201/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate44(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate44.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema29.type,
        parentSchema: schema29,
        data,
      },
    ];
    return false;
  }
  validate44.errors = vErrors;
  return errors === 0;
}
exports.validateUserTypeRequest = validate45;
const schema30 = {
  title: 'User Type',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri' },
    username: { type: 'string' },
    scopes: { type: 'array', items: { type: 'string' } },
  },
  required: ['url', 'username', 'scopes'],
  'x-typeguard': true,
  'x-standalone': true,
  'x-name': 'UserTypeRequest',
  'x-location': '#/components/schemas/user_type_request',
  'x-service-name': 'Utility',
  'x-schema-type': 'request',
};
function validate45(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.scopes === undefined && (missing0 = 'scopes'))
      ) {
        validate45.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema30.required,
            parentSchema: schema30,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate45.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema30.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate45.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema30.properties.url.type,
                    parentSchema: schema30.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.username !== undefined) {
            let data1 = data.username;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate45.errors = [
                {
                  instancePath: instancePath + '/username',
                  schemaPath: '#/properties/username/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema30.properties.username.type,
                  parentSchema: schema30.properties.username,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.scopes !== undefined) {
              let data2 = data.scopes;
              const _errs5 = errors;
              if (errors === _errs5) {
                if (Array.isArray(data2)) {
                  var valid1 = true;
                  const len0 = data2.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data3 = data2[i0];
                    const _errs7 = errors;
                    if (typeof data3 !== 'string') {
                      validate45.errors = [
                        {
                          instancePath: instancePath + '/scopes/' + i0,
                          schemaPath: '#/properties/scopes/items/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema30.properties.scopes.items.type,
                          parentSchema: schema30.properties.scopes.items,
                          data: data3,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs7 === errors;
                    if (!valid1) {
                      break;
                    }
                  }
                } else {
                  validate45.errors = [
                    {
                      instancePath: instancePath + '/scopes',
                      schemaPath: '#/properties/scopes/type',
                      keyword: 'type',
                      params: { type: 'array' },
                      message: 'must be array',
                      schema: schema30.properties.scopes.type,
                      parentSchema: schema30.properties.scopes,
                      data: data2,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate45.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema30.type,
          parentSchema: schema30,
          data,
        },
      ];
      return false;
    }
  }
  validate45.errors = vErrors;
  return errors === 0;
}
exports.validateUserTypeResponse = validate46;
const schema31 = {
  title: 'User Type',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri' },
    username: { type: 'string' },
    scopes: { type: 'array', items: { type: 'string' } },
  },
  required: ['url', 'username', 'scopes'],
  'x-typeguard': true,
  'x-standalone': true,
  'x-name': 'UserTypeResponse',
  'x-location': '#/components/schemas/user_type_response',
  'x-service-name': 'Utility',
  'x-schema-type': 'response',
};
function validate46(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.username === undefined && (missing0 = 'username')) ||
        (data.scopes === undefined && (missing0 = 'scopes'))
      ) {
        validate46.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema31.required,
            parentSchema: schema31,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate46.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema31.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate46.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema31.properties.url.type,
                    parentSchema: schema31.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.username !== undefined) {
            let data1 = data.username;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate46.errors = [
                {
                  instancePath: instancePath + '/username',
                  schemaPath: '#/properties/username/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema31.properties.username.type,
                  parentSchema: schema31.properties.username,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.scopes !== undefined) {
              let data2 = data.scopes;
              const _errs5 = errors;
              if (errors === _errs5) {
                if (Array.isArray(data2)) {
                  var valid1 = true;
                  const len0 = data2.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data3 = data2[i0];
                    const _errs7 = errors;
                    if (typeof data3 !== 'string') {
                      validate46.errors = [
                        {
                          instancePath: instancePath + '/scopes/' + i0,
                          schemaPath: '#/properties/scopes/items/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema31.properties.scopes.items.type,
                          parentSchema: schema31.properties.scopes.items,
                          data: data3,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs7 === errors;
                    if (!valid1) {
                      break;
                    }
                  }
                } else {
                  validate46.errors = [
                    {
                      instancePath: instancePath + '/scopes',
                      schemaPath: '#/properties/scopes/type',
                      keyword: 'type',
                      params: { type: 'array' },
                      message: 'must be array',
                      schema: schema31.properties.scopes.type,
                      parentSchema: schema31.properties.scopes,
                      data: data2,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate46.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema31.type,
          parentSchema: schema31,
          data,
        },
      ];
      return false;
    }
  }
  validate46.errors = vErrors;
  return errors === 0;
}
exports.validateCredentialsRequest = validate47;
const schema32 = {
  title: 'Credentials',
  type: 'object',
  properties: {
    username: { description: 'Username of the user.', type: 'string' },
    password: { description: 'Password of the user.', type: 'string' },
  },
  required: ['username', 'password'],
  'x-standalone': true,
  'x-name': 'CredentialsRequest',
  'x-location': '#/components/schemas/credentials_request',
  'x-schema-type': 'request',
};
function validate47(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate47.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema32.required,
            parentSchema: schema32,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate47.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema32.properties.username.type,
                parentSchema: schema32.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate47.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema32.properties.password.type,
                  parentSchema: schema32.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate47.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema32.type,
          parentSchema: schema32,
          data,
        },
      ];
      return false;
    }
  }
  validate47.errors = vErrors;
  return errors === 0;
}
exports.validateCredentialsResponse = validate48;
const schema33 = {
  title: 'Credentials',
  type: 'object',
  properties: {
    username: { description: 'Username of the user.', type: 'string' },
    password: { description: 'Password of the user.', type: 'string' },
  },
  required: ['username', 'password'],
  'x-standalone': true,
  'x-name': 'CredentialsResponse',
  'x-location': '#/components/schemas/credentials_response',
  'x-schema-type': 'response',
};
function validate48(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate48.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema33.required,
            parentSchema: schema33,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate48.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema33.properties.username.type,
                parentSchema: schema33.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate48.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema33.properties.password.type,
                  parentSchema: schema33.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate48.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema33.type,
          parentSchema: schema33,
          data,
        },
      ];
      return false;
    }
  }
  validate48.errors = vErrors;
  return errors === 0;
}
exports.validateAuthMethodRequest = validate49;
const schema34 = {
  title: 'AuthMethod',
  type: 'string',
  description: 'Authentication method.',
  enum: ['tui', 'local'],
  'x-standalone': true,
  'x-name': 'AuthMethodRequest',
  'x-location': '#/components/schemas/auth_method_request',
  'x-schema-type': 'request',
};
function validate49(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate49.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema34.type,
        parentSchema: schema34,
        data,
      },
    ];
    return false;
  }
  if (!(data === 'tui' || data === 'local')) {
    validate49.errors = [
      {
        instancePath,
        schemaPath: '#/enum',
        keyword: 'enum',
        params: { allowedValues: schema34.enum },
        message: 'must be equal to one of the allowed values',
        schema: schema34.enum,
        parentSchema: schema34,
        data,
      },
    ];
    return false;
  }
  validate49.errors = vErrors;
  return errors === 0;
}
exports.validateAuthMethodResponse = validate50;
const schema35 = {
  title: 'AuthMethod',
  type: 'string',
  description: 'Authentication method.',
  enum: ['tui', 'local'],
  'x-standalone': true,
  'x-name': 'AuthMethodResponse',
  'x-location': '#/components/schemas/auth_method_response',
  'x-schema-type': 'response',
};
function validate50(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate50.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema35.type,
        parentSchema: schema35,
        data,
      },
    ];
    return false;
  }
  if (!(data === 'tui' || data === 'local')) {
    validate50.errors = [
      {
        instancePath,
        schemaPath: '#/enum',
        keyword: 'enum',
        params: { allowedValues: schema35.enum },
        message: 'must be equal to one of the allowed values',
        schema: schema35.enum,
        parentSchema: schema35,
        data,
      },
    ];
    return false;
  }
  validate50.errors = vErrors;
  return errors === 0;
}
exports.validateUserRequest = validate51;
const schema36 = {
  title: 'User',
  type: 'object',
  properties: {
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['username', 'password'],
  'x-standalone': true,
  'x-name': 'UserRequest',
  'x-location': '#/components/schemas/user_request',
  'x-schema-type': 'request',
};
function validate51(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate51.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema36.required,
            parentSchema: schema36,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate51.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema36.properties.username.type,
                parentSchema: schema36.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate51.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema36.properties.password.type,
                  parentSchema: schema36.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate51.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema36.type,
          parentSchema: schema36,
          data,
        },
      ];
      return false;
    }
  }
  validate51.errors = vErrors;
  return errors === 0;
}
exports.validateUserResponse = validate52;
const schema37 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
  },
  required: ['url', 'id', 'username'],
  'x-standalone': true,
  'x-name': 'UserResponse',
  'x-location': '#/components/schemas/user_response',
  'x-schema-type': 'response',
};
function validate52(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username'))
      ) {
        validate52.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema37.required,
            parentSchema: schema37,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate52.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema37.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate52.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema37.properties.url.type,
                    parentSchema: schema37.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate52.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema37.properties.id.type,
                  parentSchema: schema37.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate52.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema37.properties.username.type,
                    parentSchema: schema37.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate52.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema37.type,
          parentSchema: schema37,
          data,
        },
      ];
      return false;
    }
  }
  validate52.errors = vErrors;
  return errors === 0;
}
exports.validateUserUpdateRequest = validate53;
const schema38 = {
  title: 'User Update',
  type: 'object',
  properties: { password: { type: 'string', writeOnly: true } },
  required: ['password'],
  'x-standalone': true,
  'x-name': 'UserUpdateRequest',
  'x-location': '#/components/schemas/user_update_request',
  'x-schema-type': 'request',
};
function validate53(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = 'password')) {
        validate53.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema38.required,
            parentSchema: schema38,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== 'string') {
            validate53.errors = [
              {
                instancePath: instancePath + '/password',
                schemaPath: '#/properties/password/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema38.properties.password.type,
                parentSchema: schema38.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate53.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema38.type,
          parentSchema: schema38,
          data,
        },
      ];
      return false;
    }
  }
  validate53.errors = vErrors;
  return errors === 0;
}
exports.validateUserUpdateResponse = validate54;
const schema39 = {
  title: 'User Update',
  type: 'object',
  properties: {},
  required: [],
  'x-standalone': true,
  'x-name': 'UserUpdateResponse',
  'x-location': '#/components/schemas/user_update_response',
  'x-schema-type': 'response',
};
function validate54(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (!(data && typeof data == 'object' && !Array.isArray(data))) {
      validate54.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema39.type,
          parentSchema: schema39,
          data,
        },
      ];
      return false;
    }
  }
  validate54.errors = vErrors;
  return errors === 0;
}
exports.validateAuthorizationRequest = validate55;
const schema40 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'AuthorizationRequest',
  'x-location': '#/components/parameters/authorization/schema_request',
  'x-schema-type': 'request',
};
function validate55(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate55.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema40.type,
        parentSchema: schema40,
        data,
      },
    ];
    return false;
  }
  validate55.errors = vErrors;
  return errors === 0;
}
exports.validateAuthorizationResponse = validate56;
const schema41 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'AuthorizationResponse',
  'x-location': '#/components/parameters/authorization/schema_response',
  'x-schema-type': 'response',
};
function validate56(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate56.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema41.type,
        parentSchema: schema41,
        data,
      },
    ];
    return false;
  }
  validate56.errors = vErrors;
  return errors === 0;
}
exports.validateXRealIPRequest = validate57;
const schema42 = {
  type: 'string',
  format: 'ipv4',
  description: 'The IP address of the client.',
  'x-standalone': false,
  'x-name': 'XRealIPRequest',
  'x-location': '#/components/parameters/x_real_ip/schema_request',
  'x-schema-type': 'request',
};
function validate57(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === 'string') {
        if (!formats4.test(data)) {
          validate57.errors = [
            {
              instancePath,
              schemaPath: '#/format',
              keyword: 'format',
              params: { format: 'ipv4' },
              message: 'must match format "' + 'ipv4' + '"',
              schema: 'ipv4',
              parentSchema: schema42,
              data,
            },
          ];
          return false;
        }
      } else {
        validate57.errors = [
          {
            instancePath,
            schemaPath: '#/type',
            keyword: 'type',
            params: { type: 'string' },
            message: 'must be string',
            schema: schema42.type,
            parentSchema: schema42,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate57.errors = vErrors;
  return errors === 0;
}
exports.validateXRealIPResponse = validate58;
const schema43 = {
  type: 'string',
  format: 'ipv4',
  description: 'The IP address of the client.',
  'x-standalone': false,
  'x-name': 'XRealIPResponse',
  'x-location': '#/components/parameters/x_real_ip/schema_response',
  'x-schema-type': 'response',
};
function validate58(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === 'string') {
        if (!formats4.test(data)) {
          validate58.errors = [
            {
              instancePath,
              schemaPath: '#/format',
              keyword: 'format',
              params: { format: 'ipv4' },
              message: 'must match format "' + 'ipv4' + '"',
              schema: 'ipv4',
              parentSchema: schema43,
              data,
            },
          ];
          return false;
        }
      } else {
        validate58.errors = [
          {
            instancePath,
            schemaPath: '#/type',
            keyword: 'type',
            params: { type: 'string' },
            message: 'must be string',
            schema: schema43.type,
            parentSchema: schema43,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate58.errors = vErrors;
  return errors === 0;
}
exports.validateXForwardedProtoRequest = validate59;
const schema44 = {
  type: 'string',
  description: 'The protocol of the client.',
  'x-standalone': false,
  'x-name': 'XForwardedProtoRequest',
  'x-location': '#/components/parameters/x_forwarded_proto/schema_request',
  'x-schema-type': 'request',
};
function validate59(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate59.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema44.type,
        parentSchema: schema44,
        data,
      },
    ];
    return false;
  }
  validate59.errors = vErrors;
  return errors === 0;
}
exports.validateXForwardedProtoResponse = validate60;
const schema45 = {
  type: 'string',
  description: 'The protocol of the client.',
  'x-standalone': false,
  'x-name': 'XForwardedProtoResponse',
  'x-location': '#/components/parameters/x_forwarded_proto/schema_response',
  'x-schema-type': 'response',
};
function validate60(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate60.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema45.type,
        parentSchema: schema45,
        data,
      },
    ];
    return false;
  }
  validate60.errors = vErrors;
  return errors === 0;
}
exports.validateUserIdRequest = validate61;
const schema46 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'UserIdRequest',
  'x-location': '#/components/parameters/user_id/schema_request',
  'x-schema-type': 'request',
};
function validate61(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate61.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema46.type,
        parentSchema: schema46,
        data,
      },
    ];
    return false;
  }
  validate61.errors = vErrors;
  return errors === 0;
}
exports.validateUserIdResponse = validate62;
const schema47 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'UserIdResponse',
  'x-location': '#/components/parameters/user_id/schema_response',
  'x-schema-type': 'response',
};
function validate62(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate62.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema47.type,
        parentSchema: schema47,
        data,
      },
    ];
    return false;
  }
  validate62.errors = vErrors;
  return errors === 0;
}
exports.validateGetAuthHeaderXRequestAuthenticationRequest = validate63;
const schema48 = {
  type: 'string',
  format: 'jwt',
  description: 'The JWT which represents the authenticated user.',
  'x-standalone': false,
  'x-name': 'getAuthHeaderXRequestAuthenticationRequest',
  'x-location':
    '#/paths//auth/get/responses/200/headers/X-Request-Authentication/schema_request',
  'x-schema-type': 'request',
};
function validate63(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === 'string') {
        if (!formats6.test(data)) {
          validate63.errors = [
            {
              instancePath,
              schemaPath: '#/format',
              keyword: 'format',
              params: { format: 'jwt' },
              message: 'must match format "' + 'jwt' + '"',
              schema: 'jwt',
              parentSchema: schema48,
              data,
            },
          ];
          return false;
        }
      } else {
        validate63.errors = [
          {
            instancePath,
            schemaPath: '#/type',
            keyword: 'type',
            params: { type: 'string' },
            message: 'must be string',
            schema: schema48.type,
            parentSchema: schema48,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate63.errors = vErrors;
  return errors === 0;
}
exports.validateGetAuthHeaderXRequestAuthenticationResponse = validate64;
const schema49 = {
  type: 'string',
  format: 'jwt',
  description: 'The JWT which represents the authenticated user.',
  'x-standalone': false,
  'x-name': 'getAuthHeaderXRequestAuthenticationResponse',
  'x-location':
    '#/paths//auth/get/responses/200/headers/X-Request-Authentication/schema_response',
  'x-schema-type': 'response',
};
function validate64(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === 'string') {
        if (!formats6.test(data)) {
          validate64.errors = [
            {
              instancePath,
              schemaPath: '#/format',
              keyword: 'format',
              params: { format: 'jwt' },
              message: 'must match format "' + 'jwt' + '"',
              schema: 'jwt',
              parentSchema: schema49,
              data,
            },
          ];
          return false;
        }
      } else {
        validate64.errors = [
          {
            instancePath,
            schemaPath: '#/type',
            keyword: 'type',
            params: { type: 'string' },
            message: 'must be string',
            schema: schema49.type,
            parentSchema: schema49,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate64.errors = vErrors;
  return errors === 0;
}
exports.validatePostLoginRequestBodyRequest = validate65;
const schema50 = {
  allOf: [
    {
      title: 'Credentials',
      type: 'object',
      properties: {
        username: { description: 'Username of the user.', type: 'string' },
        password: { description: 'Password of the user.', type: 'string' },
      },
      required: ['username', 'password'],
    },
    {
      type: 'object',
      properties: {
        method: {
          title: 'AuthMethod',
          type: 'string',
          description: 'Authentication method.',
          enum: ['tui', 'local'],
        },
      },
    },
  ],
  'x-standalone': false,
  'x-name': 'postLoginRequestBodyRequest',
  'x-location': '#/paths//login/post/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate65(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  if (errors === _errs0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate65.errors = [
          {
            instancePath,
            schemaPath: '#/allOf/0/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema50.allOf[0].required,
            parentSchema: schema50.allOf[0],
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs2 = errors;
          if (typeof data0 !== 'string') {
            validate65.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/allOf/0/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema50.allOf[0].properties.username.type,
                parentSchema: schema50.allOf[0].properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid1 = _errs2 === errors;
        } else {
          var valid1 = true;
        }
        if (valid1) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs4 = errors;
            if (typeof data1 !== 'string') {
              validate65.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/allOf/0/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema50.allOf[0].properties.password.type,
                  parentSchema: schema50.allOf[0].properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid1 = _errs4 === errors;
          } else {
            var valid1 = true;
          }
        }
      }
    } else {
      validate65.errors = [
        {
          instancePath,
          schemaPath: '#/allOf/0/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema50.allOf[0].type,
          parentSchema: schema50.allOf[0],
          data,
        },
      ];
      return false;
    }
  }
  var valid0 = _errs0 === errors;
  if (valid0) {
    const _errs6 = errors;
    if (errors === _errs6) {
      if (data && typeof data == 'object' && !Array.isArray(data)) {
        if (data.method !== undefined) {
          let data2 = data.method;
          if (typeof data2 !== 'string') {
            validate65.errors = [
              {
                instancePath: instancePath + '/method',
                schemaPath: '#/allOf/1/properties/method/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema50.allOf[1].properties.method.type,
                parentSchema: schema50.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
          if (!(data2 === 'tui' || data2 === 'local')) {
            validate65.errors = [
              {
                instancePath: instancePath + '/method',
                schemaPath: '#/allOf/1/properties/method/enum',
                keyword: 'enum',
                params: { allowedValues: schema50.allOf[1].properties.method.enum },
                message: 'must be equal to one of the allowed values',
                schema: schema50.allOf[1].properties.method.enum,
                parentSchema: schema50.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
        }
      } else {
        validate65.errors = [
          {
            instancePath,
            schemaPath: '#/allOf/1/type',
            keyword: 'type',
            params: { type: 'object' },
            message: 'must be object',
            schema: schema50.allOf[1].type,
            parentSchema: schema50.allOf[1],
            data,
          },
        ];
        return false;
      }
    }
    var valid0 = _errs6 === errors;
  }
  validate65.errors = vErrors;
  return errors === 0;
}
exports.validatePostLoginRequestBodyResponse = validate66;
const schema51 = {
  allOf: [
    {
      title: 'Credentials',
      type: 'object',
      properties: {
        username: { description: 'Username of the user.', type: 'string' },
        password: { description: 'Password of the user.', type: 'string' },
      },
      required: ['username', 'password'],
    },
    {
      type: 'object',
      properties: {
        method: {
          title: 'AuthMethod',
          type: 'string',
          description: 'Authentication method.',
          enum: ['tui', 'local'],
        },
      },
    },
  ],
  'x-standalone': false,
  'x-name': 'postLoginRequestBodyResponse',
  'x-location':
    '#/paths//login/post/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate66(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  if (errors === _errs0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate66.errors = [
          {
            instancePath,
            schemaPath: '#/allOf/0/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema51.allOf[0].required,
            parentSchema: schema51.allOf[0],
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs2 = errors;
          if (typeof data0 !== 'string') {
            validate66.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/allOf/0/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema51.allOf[0].properties.username.type,
                parentSchema: schema51.allOf[0].properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid1 = _errs2 === errors;
        } else {
          var valid1 = true;
        }
        if (valid1) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs4 = errors;
            if (typeof data1 !== 'string') {
              validate66.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/allOf/0/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema51.allOf[0].properties.password.type,
                  parentSchema: schema51.allOf[0].properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid1 = _errs4 === errors;
          } else {
            var valid1 = true;
          }
        }
      }
    } else {
      validate66.errors = [
        {
          instancePath,
          schemaPath: '#/allOf/0/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema51.allOf[0].type,
          parentSchema: schema51.allOf[0],
          data,
        },
      ];
      return false;
    }
  }
  var valid0 = _errs0 === errors;
  if (valid0) {
    const _errs6 = errors;
    if (errors === _errs6) {
      if (data && typeof data == 'object' && !Array.isArray(data)) {
        if (data.method !== undefined) {
          let data2 = data.method;
          if (typeof data2 !== 'string') {
            validate66.errors = [
              {
                instancePath: instancePath + '/method',
                schemaPath: '#/allOf/1/properties/method/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema51.allOf[1].properties.method.type,
                parentSchema: schema51.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
          if (!(data2 === 'tui' || data2 === 'local')) {
            validate66.errors = [
              {
                instancePath: instancePath + '/method',
                schemaPath: '#/allOf/1/properties/method/enum',
                keyword: 'enum',
                params: { allowedValues: schema51.allOf[1].properties.method.enum },
                message: 'must be equal to one of the allowed values',
                schema: schema51.allOf[1].properties.method.enum,
                parentSchema: schema51.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
        }
      } else {
        validate66.errors = [
          {
            instancePath,
            schemaPath: '#/allOf/1/type',
            keyword: 'type',
            params: { type: 'object' },
            message: 'must be object',
            schema: schema51.allOf[1].type,
            parentSchema: schema51.allOf[1],
            data,
          },
        ];
        return false;
      }
    }
    var valid0 = _errs6 === errors;
  }
  validate66.errors = vErrors;
  return errors === 0;
}
exports.validatePostLoginResponse201Request = validate67;
const schema52 = {
  description: 'The access token.',
  type: 'string',
  'x-standalone': false,
  'x-name': 'postLoginResponse201Request',
  'x-location':
    '#/paths//login/post/responses/201/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate67(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate67.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema52.type,
        parentSchema: schema52,
        data,
      },
    ];
    return false;
  }
  validate67.errors = vErrors;
  return errors === 0;
}
exports.validatePostLoginResponse201Response = validate68;
const schema53 = {
  description: 'The access token.',
  type: 'string',
  'x-standalone': false,
  'x-name': 'postLoginResponse201Response',
  'x-location':
    '#/paths//login/post/responses/201/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate68(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate68.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema53.type,
        parentSchema: schema53,
        data,
      },
    ];
    return false;
  }
  validate68.errors = vErrors;
  return errors === 0;
}
exports.validatePostLogoutRequestBodyRequest = validate69;
const schema54 = {
  type: 'object',
  properties: { token: { type: 'string', description: 'The token to be invalidated.' } },
  'x-standalone': false,
  'x-name': 'postLogoutRequestBodyRequest',
  'x-location':
    '#/paths//logout/post/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate69(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.token !== undefined) {
        let data0 = data.token;
        if (typeof data0 !== 'string') {
          validate69.errors = [
            {
              instancePath: instancePath + '/token',
              schemaPath: '#/properties/token/type',
              keyword: 'type',
              params: { type: 'string' },
              message: 'must be string',
              schema: schema54.properties.token.type,
              parentSchema: schema54.properties.token,
              data: data0,
            },
          ];
          return false;
        }
      }
    } else {
      validate69.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema54.type,
          parentSchema: schema54,
          data,
        },
      ];
      return false;
    }
  }
  validate69.errors = vErrors;
  return errors === 0;
}
exports.validatePostLogoutRequestBodyResponse = validate70;
const schema55 = {
  type: 'object',
  properties: { token: { type: 'string', description: 'The token to be invalidated.' } },
  'x-standalone': false,
  'x-name': 'postLogoutRequestBodyResponse',
  'x-location':
    '#/paths//logout/post/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate70(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.token !== undefined) {
        let data0 = data.token;
        if (typeof data0 !== 'string') {
          validate70.errors = [
            {
              instancePath: instancePath + '/token',
              schemaPath: '#/properties/token/type',
              keyword: 'type',
              params: { type: 'string' },
              message: 'must be string',
              schema: schema55.properties.token.type,
              parentSchema: schema55.properties.token,
              data: data0,
            },
          ];
          return false;
        }
      }
    } else {
      validate70.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema55.type,
          parentSchema: schema55,
          data,
        },
      ];
      return false;
    }
  }
  validate70.errors = vErrors;
  return errors === 0;
}
exports.validateGetUsersResponse200Request = validate71;
const schema56 = {
  type: 'array',
  items: {
    title: 'User',
    type: 'object',
    properties: {
      username: { type: 'string' },
      password: { type: 'string', writeOnly: true },
    },
    required: ['username', 'password'],
  },
  'x-standalone': false,
  'x-name': 'getUsersResponse200Request',
  'x-location':
    '#/paths//users/get/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate71(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.username === undefined && (missing0 = 'username')) ||
              (data0.password === undefined && (missing0 = 'password'))
            ) {
              validate71.errors = [
                {
                  instancePath: instancePath + '/' + i0,
                  schemaPath: '#/items/required',
                  keyword: 'required',
                  params: { missingProperty: missing0 },
                  message: "must have required property '" + missing0 + "'",
                  schema: schema56.items.required,
                  parentSchema: schema56.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.username !== undefined) {
                let data1 = data0.username;
                const _errs3 = errors;
                if (typeof data1 !== 'string') {
                  validate71.errors = [
                    {
                      instancePath: instancePath + '/' + i0 + '/username',
                      schemaPath: '#/items/properties/username/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema56.items.properties.username.type,
                      parentSchema: schema56.items.properties.username,
                      data: data1,
                    },
                  ];
                  return false;
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.password !== undefined) {
                  let data2 = data0.password;
                  const _errs5 = errors;
                  if (typeof data2 !== 'string') {
                    validate71.errors = [
                      {
                        instancePath: instancePath + '/' + i0 + '/password',
                        schemaPath: '#/items/properties/password/type',
                        keyword: 'type',
                        params: { type: 'string' },
                        message: 'must be string',
                        schema: schema56.items.properties.password.type,
                        parentSchema: schema56.items.properties.password,
                        data: data2,
                      },
                    ];
                    return false;
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
              }
            }
          } else {
            validate71.errors = [
              {
                instancePath: instancePath + '/' + i0,
                schemaPath: '#/items/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema56.items.type,
                parentSchema: schema56.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate71.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
          schema: schema56.type,
          parentSchema: schema56,
          data,
        },
      ];
      return false;
    }
  }
  validate71.errors = vErrors;
  return errors === 0;
}
exports.validateGetUsersResponse200Response = validate72;
const schema57 = {
  type: 'array',
  items: {
    title: 'User',
    type: 'object',
    properties: {
      url: { type: 'string', format: 'uri', readOnly: true },
      id: { type: 'string', readOnly: true },
      username: { type: 'string' },
    },
    required: ['url', 'id', 'username'],
  },
  'x-standalone': false,
  'x-name': 'getUsersResponse200Response',
  'x-location':
    '#/paths//users/get/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate72(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.url === undefined && (missing0 = 'url')) ||
              (data0.id === undefined && (missing0 = 'id')) ||
              (data0.username === undefined && (missing0 = 'username'))
            ) {
              validate72.errors = [
                {
                  instancePath: instancePath + '/' + i0,
                  schemaPath: '#/items/required',
                  keyword: 'required',
                  params: { missingProperty: missing0 },
                  message: "must have required property '" + missing0 + "'",
                  schema: schema57.items.required,
                  parentSchema: schema57.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.url !== undefined) {
                let data1 = data0.url;
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (errors === _errs3) {
                    if (typeof data1 === 'string') {
                      if (!formats0(data1)) {
                        validate72.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/url',
                            schemaPath: '#/items/properties/url/format',
                            keyword: 'format',
                            params: { format: 'uri' },
                            message: 'must match format "' + 'uri' + '"',
                            schema: 'uri',
                            parentSchema: schema57.items.properties.url,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    } else {
                      validate72.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/url',
                          schemaPath: '#/items/properties/url/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema57.items.properties.url.type,
                          parentSchema: schema57.items.properties.url,
                          data: data1,
                        },
                      ];
                      return false;
                    }
                  }
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.id !== undefined) {
                  let data2 = data0.id;
                  const _errs5 = errors;
                  if (typeof data2 !== 'string') {
                    validate72.errors = [
                      {
                        instancePath: instancePath + '/' + i0 + '/id',
                        schemaPath: '#/items/properties/id/type',
                        keyword: 'type',
                        params: { type: 'string' },
                        message: 'must be string',
                        schema: schema57.items.properties.id.type,
                        parentSchema: schema57.items.properties.id,
                        data: data2,
                      },
                    ];
                    return false;
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.username !== undefined) {
                    let data3 = data0.username;
                    const _errs7 = errors;
                    if (typeof data3 !== 'string') {
                      validate72.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/username',
                          schemaPath: '#/items/properties/username/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema57.items.properties.username.type,
                          parentSchema: schema57.items.properties.username,
                          data: data3,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs7 === errors;
                  } else {
                    var valid1 = true;
                  }
                }
              }
            }
          } else {
            validate72.errors = [
              {
                instancePath: instancePath + '/' + i0,
                schemaPath: '#/items/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema57.items.type,
                parentSchema: schema57.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate72.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
          schema: schema57.type,
          parentSchema: schema57,
          data,
        },
      ];
      return false;
    }
  }
  validate72.errors = vErrors;
  return errors === 0;
}
exports.validatePostUsersRequestBodyRequest = validate73;
const schema58 = {
  title: 'User',
  type: 'object',
  properties: {
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['username', 'password'],
  'x-standalone': false,
  'x-name': 'postUsersRequestBodyRequest',
  'x-location': '#/paths//users/post/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate73(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate73.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema58.required,
            parentSchema: schema58,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate73.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema58.properties.username.type,
                parentSchema: schema58.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate73.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema58.properties.password.type,
                  parentSchema: schema58.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate73.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema58.type,
          parentSchema: schema58,
          data,
        },
      ];
      return false;
    }
  }
  validate73.errors = vErrors;
  return errors === 0;
}
exports.validatePostUsersRequestBodyResponse = validate74;
const schema59 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
  },
  required: ['url', 'id', 'username'],
  'x-standalone': false,
  'x-name': 'postUsersRequestBodyResponse',
  'x-location':
    '#/paths//users/post/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate74(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username'))
      ) {
        validate74.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema59.required,
            parentSchema: schema59,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate74.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema59.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate74.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema59.properties.url.type,
                    parentSchema: schema59.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate74.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema59.properties.id.type,
                  parentSchema: schema59.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate74.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema59.properties.username.type,
                    parentSchema: schema59.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate74.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema59.type,
          parentSchema: schema59,
          data,
        },
      ];
      return false;
    }
  }
  validate74.errors = vErrors;
  return errors === 0;
}
exports.validatePostUsersResponse201Request = validate75;
const schema60 = {
  title: 'User',
  type: 'object',
  properties: {
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['username', 'password'],
  'x-standalone': false,
  'x-name': 'postUsersResponse201Request',
  'x-location':
    '#/paths//users/post/responses/201/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate75(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate75.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema60.required,
            parentSchema: schema60,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate75.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema60.properties.username.type,
                parentSchema: schema60.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate75.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema60.properties.password.type,
                  parentSchema: schema60.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate75.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema60.type,
          parentSchema: schema60,
          data,
        },
      ];
      return false;
    }
  }
  validate75.errors = vErrors;
  return errors === 0;
}
exports.validatePostUsersResponse201Response = validate76;
const schema61 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
  },
  required: ['url', 'id', 'username'],
  'x-standalone': false,
  'x-name': 'postUsersResponse201Response',
  'x-location':
    '#/paths//users/post/responses/201/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate76(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username'))
      ) {
        validate76.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema61.required,
            parentSchema: schema61,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate76.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema61.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate76.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema61.properties.url.type,
                    parentSchema: schema61.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate76.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema61.properties.id.type,
                  parentSchema: schema61.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate76.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema61.properties.username.type,
                    parentSchema: schema61.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate76.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema61.type,
          parentSchema: schema61,
          data,
        },
      ];
      return false;
    }
  }
  validate76.errors = vErrors;
  return errors === 0;
}
exports.validateGetUsersByUserIdResponse200Request = validate77;
const schema62 = {
  title: 'User',
  type: 'object',
  properties: {
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['username', 'password'],
  'x-standalone': false,
  'x-name': 'getUsersByUserIdResponse200Request',
  'x-location':
    '#/paths//users/{user_id}/get/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate77(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate77.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema62.required,
            parentSchema: schema62,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate77.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema62.properties.username.type,
                parentSchema: schema62.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate77.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema62.properties.password.type,
                  parentSchema: schema62.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate77.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema62.type,
          parentSchema: schema62,
          data,
        },
      ];
      return false;
    }
  }
  validate77.errors = vErrors;
  return errors === 0;
}
exports.validateGetUsersByUserIdResponse200Response = validate78;
const schema63 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
  },
  required: ['url', 'id', 'username'],
  'x-standalone': false,
  'x-name': 'getUsersByUserIdResponse200Response',
  'x-location':
    '#/paths//users/{user_id}/get/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate78(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username'))
      ) {
        validate78.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema63.required,
            parentSchema: schema63,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate78.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema63.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate78.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema63.properties.url.type,
                    parentSchema: schema63.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate78.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema63.properties.id.type,
                  parentSchema: schema63.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate78.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema63.properties.username.type,
                    parentSchema: schema63.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate78.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema63.type,
          parentSchema: schema63,
          data,
        },
      ];
      return false;
    }
  }
  validate78.errors = vErrors;
  return errors === 0;
}
exports.validatePatchUsersByUserIdRequestBodyRequest = validate79;
const schema64 = {
  title: 'User Update',
  type: 'object',
  properties: { password: { type: 'string', writeOnly: true } },
  required: ['password'],
  'x-standalone': false,
  'x-name': 'patchUsersByUserIdRequestBodyRequest',
  'x-location':
    '#/paths//users/{user_id}/patch/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate79(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = 'password')) {
        validate79.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema64.required,
            parentSchema: schema64,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== 'string') {
            validate79.errors = [
              {
                instancePath: instancePath + '/password',
                schemaPath: '#/properties/password/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema64.properties.password.type,
                parentSchema: schema64.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate79.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema64.type,
          parentSchema: schema64,
          data,
        },
      ];
      return false;
    }
  }
  validate79.errors = vErrors;
  return errors === 0;
}
exports.validatePatchUsersByUserIdRequestBodyResponse = validate80;
const schema65 = {
  title: 'User Update',
  type: 'object',
  properties: {},
  required: [],
  'x-standalone': false,
  'x-name': 'patchUsersByUserIdRequestBodyResponse',
  'x-location':
    '#/paths//users/{user_id}/patch/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate80(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (!(data && typeof data == 'object' && !Array.isArray(data))) {
      validate80.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema65.type,
          parentSchema: schema65,
          data,
        },
      ];
      return false;
    }
  }
  validate80.errors = vErrors;
  return errors === 0;
}
exports.validatePatchUsersByUserIdResponse200Request = validate81;
const schema66 = {
  title: 'User',
  type: 'object',
  properties: {
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['username', 'password'],
  'x-standalone': false,
  'x-name': 'patchUsersByUserIdResponse200Request',
  'x-location':
    '#/paths//users/{user_id}/patch/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate81(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate81.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema66.required,
            parentSchema: schema66,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate81.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema66.properties.username.type,
                parentSchema: schema66.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate81.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema66.properties.password.type,
                  parentSchema: schema66.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate81.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema66.type,
          parentSchema: schema66,
          data,
        },
      ];
      return false;
    }
  }
  validate81.errors = vErrors;
  return errors === 0;
}
exports.validatePatchUsersByUserIdResponse200Response = validate82;
const schema67 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
  },
  required: ['url', 'id', 'username'],
  'x-standalone': false,
  'x-name': 'patchUsersByUserIdResponse200Response',
  'x-location':
    '#/paths//users/{user_id}/patch/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate82(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username'))
      ) {
        validate82.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema67.required,
            parentSchema: schema67,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate82.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema67.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate82.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema67.properties.url.type,
                    parentSchema: schema67.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate82.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema67.properties.id.type,
                  parentSchema: schema67.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate82.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema67.properties.username.type,
                    parentSchema: schema67.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate82.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema67.type,
          parentSchema: schema67,
          data,
        },
      ];
      return false;
    }
  }
  validate82.errors = vErrors;
  return errors === 0;
}
exports.validateGetIdentityResponse200Request = validate83;
const schema68 = {
  title: 'User',
  type: 'object',
  properties: {
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['username', 'password'],
  'x-standalone': false,
  'x-name': 'getIdentityResponse200Request',
  'x-location':
    '#/paths//identity/get/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate83(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate83.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema68.required,
            parentSchema: schema68,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate83.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema68.properties.username.type,
                parentSchema: schema68.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate83.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema68.properties.password.type,
                  parentSchema: schema68.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate83.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema68.type,
          parentSchema: schema68,
          data,
        },
      ];
      return false;
    }
  }
  validate83.errors = vErrors;
  return errors === 0;
}
exports.validateGetIdentityResponse200Response = validate84;
const schema69 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
  },
  required: ['url', 'id', 'username'],
  'x-standalone': false,
  'x-name': 'getIdentityResponse200Response',
  'x-location':
    '#/paths//identity/get/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate84(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username'))
      ) {
        validate84.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema69.required,
            parentSchema: schema69,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate84.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema69.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate84.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema69.properties.url.type,
                    parentSchema: schema69.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate84.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema69.properties.id.type,
                  parentSchema: schema69.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate84.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema69.properties.username.type,
                    parentSchema: schema69.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate84.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema69.type,
          parentSchema: schema69,
          data,
        },
      ];
      return false;
    }
  }
  validate84.errors = vErrors;
  return errors === 0;
}
exports.validatePatchIdentityRequestBodyRequest = validate85;
const schema70 = {
  title: 'User Update',
  type: 'object',
  properties: { password: { type: 'string', writeOnly: true } },
  required: ['password'],
  'x-standalone': false,
  'x-name': 'patchIdentityRequestBodyRequest',
  'x-location':
    '#/paths//identity/patch/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate85(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = 'password')) {
        validate85.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema70.required,
            parentSchema: schema70,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== 'string') {
            validate85.errors = [
              {
                instancePath: instancePath + '/password',
                schemaPath: '#/properties/password/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema70.properties.password.type,
                parentSchema: schema70.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate85.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema70.type,
          parentSchema: schema70,
          data,
        },
      ];
      return false;
    }
  }
  validate85.errors = vErrors;
  return errors === 0;
}
exports.validatePatchIdentityRequestBodyResponse = validate86;
const schema71 = {
  title: 'User Update',
  type: 'object',
  properties: {},
  required: [],
  'x-standalone': false,
  'x-name': 'patchIdentityRequestBodyResponse',
  'x-location':
    '#/paths//identity/patch/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate86(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (!(data && typeof data == 'object' && !Array.isArray(data))) {
      validate86.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema71.type,
          parentSchema: schema71,
          data,
        },
      ];
      return false;
    }
  }
  validate86.errors = vErrors;
  return errors === 0;
}
exports.validatePatchIdentityResponse200Request = validate87;
const schema72 = {
  title: 'User',
  type: 'object',
  properties: {
    username: { type: 'string' },
    password: { type: 'string', writeOnly: true },
  },
  required: ['username', 'password'],
  'x-standalone': false,
  'x-name': 'patchIdentityResponse200Request',
  'x-location':
    '#/paths//identity/patch/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate87(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = 'username')) ||
        (data.password === undefined && (missing0 = 'password'))
      ) {
        validate87.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema72.required,
            parentSchema: schema72,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== 'string') {
            validate87.errors = [
              {
                instancePath: instancePath + '/username',
                schemaPath: '#/properties/username/type',
                keyword: 'type',
                params: { type: 'string' },
                message: 'must be string',
                schema: schema72.properties.username.type,
                parentSchema: schema72.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate87.errors = [
                {
                  instancePath: instancePath + '/password',
                  schemaPath: '#/properties/password/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema72.properties.password.type,
                  parentSchema: schema72.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate87.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema72.type,
          parentSchema: schema72,
          data,
        },
      ];
      return false;
    }
  }
  validate87.errors = vErrors;
  return errors === 0;
}
exports.validatePatchIdentityResponse200Response = validate88;
const schema73 = {
  title: 'User',
  type: 'object',
  properties: {
    url: { type: 'string', format: 'uri', readOnly: true },
    id: { type: 'string', readOnly: true },
    username: { type: 'string' },
  },
  required: ['url', 'id', 'username'],
  'x-standalone': false,
  'x-name': 'patchIdentityResponse200Response',
  'x-location':
    '#/paths//identity/patch/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate88(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = 'url')) ||
        (data.id === undefined && (missing0 = 'id')) ||
        (data.username === undefined && (missing0 = 'username'))
      ) {
        validate88.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema73.required,
            parentSchema: schema73,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate88.errors = [
                    {
                      instancePath: instancePath + '/url',
                      schemaPath: '#/properties/url/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema73.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate88.errors = [
                  {
                    instancePath: instancePath + '/url',
                    schemaPath: '#/properties/url/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema73.properties.url.type,
                    parentSchema: schema73.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== 'string') {
              validate88.errors = [
                {
                  instancePath: instancePath + '/id',
                  schemaPath: '#/properties/id/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema73.properties.id.type,
                  parentSchema: schema73.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== 'string') {
                validate88.errors = [
                  {
                    instancePath: instancePath + '/username',
                    schemaPath: '#/properties/username/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema73.properties.username.type,
                    parentSchema: schema73.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate88.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema73.type,
          parentSchema: schema73,
          data,
        },
      ];
      return false;
    }
  }
  validate88.errors = vErrors;
  return errors === 0;
}
exports.validatePostTokenRequestBodyRequest = validate89;
const schema74 = {
  type: 'object',
  properties: {
    username: { type: 'string', description: 'The username of the user.' },
    claims: {
      type: 'object',
      description:
        'The claims that will be added to the token. If left empty, the token will have the full scope of the user.\n',
    },
  },
  'x-standalone': false,
  'x-name': 'postTokenRequestBodyRequest',
  'x-location': '#/paths//token/post/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate89(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.username !== undefined) {
        let data0 = data.username;
        const _errs1 = errors;
        if (typeof data0 !== 'string') {
          validate89.errors = [
            {
              instancePath: instancePath + '/username',
              schemaPath: '#/properties/username/type',
              keyword: 'type',
              params: { type: 'string' },
              message: 'must be string',
              schema: schema74.properties.username.type,
              parentSchema: schema74.properties.username,
              data: data0,
            },
          ];
          return false;
        }
        var valid0 = _errs1 === errors;
      } else {
        var valid0 = true;
      }
      if (valid0) {
        if (data.claims !== undefined) {
          let data1 = data.claims;
          const _errs3 = errors;
          if (!(data1 && typeof data1 == 'object' && !Array.isArray(data1))) {
            validate89.errors = [
              {
                instancePath: instancePath + '/claims',
                schemaPath: '#/properties/claims/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema74.properties.claims.type,
                parentSchema: schema74.properties.claims,
                data: data1,
              },
            ];
            return false;
          }
          var valid0 = _errs3 === errors;
        } else {
          var valid0 = true;
        }
      }
    } else {
      validate89.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema74.type,
          parentSchema: schema74,
          data,
        },
      ];
      return false;
    }
  }
  validate89.errors = vErrors;
  return errors === 0;
}
exports.validatePostTokenRequestBodyResponse = validate90;
const schema75 = {
  type: 'object',
  properties: {
    username: { type: 'string', description: 'The username of the user.' },
    claims: {
      type: 'object',
      description:
        'The claims that will be added to the token. If left empty, the token will have the full scope of the user.\n',
    },
  },
  'x-standalone': false,
  'x-name': 'postTokenRequestBodyResponse',
  'x-location':
    '#/paths//token/post/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate90(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.username !== undefined) {
        let data0 = data.username;
        const _errs1 = errors;
        if (typeof data0 !== 'string') {
          validate90.errors = [
            {
              instancePath: instancePath + '/username',
              schemaPath: '#/properties/username/type',
              keyword: 'type',
              params: { type: 'string' },
              message: 'must be string',
              schema: schema75.properties.username.type,
              parentSchema: schema75.properties.username,
              data: data0,
            },
          ];
          return false;
        }
        var valid0 = _errs1 === errors;
      } else {
        var valid0 = true;
      }
      if (valid0) {
        if (data.claims !== undefined) {
          let data1 = data.claims;
          const _errs3 = errors;
          if (!(data1 && typeof data1 == 'object' && !Array.isArray(data1))) {
            validate90.errors = [
              {
                instancePath: instancePath + '/claims',
                schemaPath: '#/properties/claims/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema75.properties.claims.type,
                parentSchema: schema75.properties.claims,
                data: data1,
              },
            ];
            return false;
          }
          var valid0 = _errs3 === errors;
        } else {
          var valid0 = true;
        }
      }
    } else {
      validate90.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema75.type,
          parentSchema: schema75,
          data,
        },
      ];
      return false;
    }
  }
  validate90.errors = vErrors;
  return errors === 0;
}
exports.validatePostTokenResponse201Request = validate91;
const schema76 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'postTokenResponse201Request',
  'x-location':
    '#/paths//token/post/responses/201/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate91(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate91.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema76.type,
        parentSchema: schema76,
        data,
      },
    ];
    return false;
  }
  validate91.errors = vErrors;
  return errors === 0;
}
exports.validatePostTokenResponse201Response = validate92;
const schema77 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'postTokenResponse201Response',
  'x-location':
    '#/paths//token/post/responses/201/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate92(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate92.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema77.type,
        parentSchema: schema77,
        data,
      },
    ];
    return false;
  }
  validate92.errors = vErrors;
  return errors === 0;
}
