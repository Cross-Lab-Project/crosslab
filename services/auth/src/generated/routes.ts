/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */
import express from "express"

import operations from "../operations/index.js"

import {
    TypedRequest,
	ValidationError
} from "./types.js"

import {
    getAuthParametersType,
	postLoginRequestBodyType,
	postLogoutRequestBodyType,
	getUsersParametersType,
	postUsersRequestBodyType,
	getUsersByUserIdParametersType,
	patchUsersByUserIdParametersType,
	patchUsersByUserIdRequestBodyType,
	deleteUsersByUserIdParametersType,
	patchIdentityRequestBodyType,
	postTokenRequestBodyType
} from "./signatures.js"

import {
    validateGetAuthInput,
	validateGetAuthOutput,
	validatePostLoginInput,
	validatePostLoginOutput,
	validatePostLogoutInput,
	validatePostLogoutOutput,
	validateGetUsersInput,
	validateGetUsersOutput,
	validatePostUsersInput,
	validatePostUsersOutput,
	validateGetUsersByUserIdInput,
	validateGetUsersByUserIdOutput,
	validatePatchUsersByUserIdInput,
	validatePatchUsersByUserIdOutput,
	validateDeleteUsersByUserIdInput,
	validateDeleteUsersByUserIdOutput,
	validateGetIdentityInput,
	validateGetIdentityOutput,
	validatePatchIdentityInput,
	validatePatchIdentityOutput,
	validatePostTokenInput,
	validatePostTokenOutput
} from "./requestValidation.js"

export default function router(): express.Router {
    const router = express.Router()

    router.get("/auth", async (req: TypedRequest<{},{},{}>, res, next) => {
        const parameters: getAuthParametersType = {
            "Authorization": req.get("Authorization"),
			"X-Real-IP": req.get("X-Real-IP"),
			"X-Forwarded-Proto": req.get("X-Forwarded-Proto")
        }

        try {
            if (!validateGetAuthInput(parameters)) {
                throw new ValidationError("Request validation failed", (validateGetAuthInput as any).errors, 400)
            }

            const result = await operations.getAuth(
                req,parameters)

            if (!validateGetAuthOutput(result)) {
                throw new ValidationError("Response validation failed", (validateGetAuthOutput as any).errors, 500)
            }

            for (const headerName in result.headers) {
                const header = result.headers[headerName]
                if (header) {
                    res.setHeader(headerName, header)
                }
            }

            return res.status(result.status).json(result.body)
        } catch(error) {
            next(error)
            return
        }
    })

    router.post("/login", async (req: TypedRequest<{},postLoginRequestBodyType,{}>, res, next) => {
        const body: postLoginRequestBodyType = req.body

        try {
            if (!validatePostLoginInput(body)) {
                throw new ValidationError("Request validation failed", (validatePostLoginInput as any).errors, 400)
            }

            const result = await operations.postLogin(
                req,body)

            if (!validatePostLoginOutput(result)) {
                throw new ValidationError("Response validation failed", (validatePostLoginOutput as any).errors, 500)
            }

            for (const headerName in result.headers) {
                const header = result.headers[headerName]
                if (header) {
                    res.setHeader(headerName, header)
                }
            }

            return res.status(result.status).json(result.body)
        } catch(error) {
            next(error)
            return
        }
    })

    router.post("/logout", async (req: TypedRequest<{},postLogoutRequestBodyType,{}>, res, next) => {
        const body: postLogoutRequestBodyType = req.body

        try {
            if (!validatePostLogoutInput(body)) {
                throw new ValidationError("Request validation failed", (validatePostLogoutInput as any).errors, 400)
            }

            const result = await operations.postLogout(
                req,body)

            if (!validatePostLogoutOutput(result)) {
                throw new ValidationError("Response validation failed", (validatePostLogoutOutput as any).errors, 500)
            }

            for (const headerName in result.headers) {
                const header = result.headers[headerName]
                if (header) {
                    res.setHeader(headerName, header)
                }
            }

            return res.status(result.status).json(result.body)
        } catch(error) {
            next(error)
            return
        }
    })

    router.get("/users", async (req: TypedRequest<{},{},{ "username": string }>, res, next) => {
        const parameters: getUsersParametersType = {
            "username": req.query["username"]
        }

        try {
            if (!validateGetUsersInput(parameters)) {
                throw new ValidationError("Request validation failed", (validateGetUsersInput as any).errors, 400)
            }

            const result = await operations.getUsers(
                req,parameters)

            if (!validateGetUsersOutput(result)) {
                throw new ValidationError("Response validation failed", (validateGetUsersOutput as any).errors, 500)
            }

            for (const headerName in result.headers) {
                const header = result.headers[headerName]
                if (header) {
                    res.setHeader(headerName, header)
                }
            }

            return res.status(result.status).json(result.body)
        } catch(error) {
            next(error)
            return
        }
    })

    router.post("/users", async (req: TypedRequest<{},postUsersRequestBodyType,{}>, res, next) => {
        const body: postUsersRequestBodyType = req.body

        try {
            if (!validatePostUsersInput(body)) {
                throw new ValidationError("Request validation failed", (validatePostUsersInput as any).errors, 400)
            }

            const result = await operations.postUsers(
                req,body)

            if (!validatePostUsersOutput(result)) {
                throw new ValidationError("Response validation failed", (validatePostUsersOutput as any).errors, 500)
            }

            for (const headerName in result.headers) {
                const header = result.headers[headerName]
                if (header) {
                    res.setHeader(headerName, header)
                }
            }

            return res.status(result.status).json(result.body)
        } catch(error) {
            next(error)
            return
        }
    })

    router.get("/users/:user_id", async (req: TypedRequest<{ "user_id": string },{},{}>, res, next) => {
        const parameters: getUsersByUserIdParametersType = {
            "user_id": req.params["user_id"]
        }

        try {
            if (!validateGetUsersByUserIdInput(parameters)) {
                throw new ValidationError("Request validation failed", (validateGetUsersByUserIdInput as any).errors, 400)
            }

            const result = await operations.getUsersByUserId(
                req,parameters)

            if (!validateGetUsersByUserIdOutput(result)) {
                throw new ValidationError("Response validation failed", (validateGetUsersByUserIdOutput as any).errors, 500)
            }

            for (const headerName in result.headers) {
                const header = result.headers[headerName]
                if (header) {
                    res.setHeader(headerName, header)
                }
            }

            return res.status(result.status).json(result.body)
        } catch(error) {
            next(error)
            return
        }
    })

    router.patch("/users/:user_id", async (req: TypedRequest<{ "user_id": string },patchUsersByUserIdRequestBodyType,{}>, res, next) => {
        const parameters: patchUsersByUserIdParametersType = {
            "user_id": req.params["user_id"]
        }

        const body: patchUsersByUserIdRequestBodyType = req.body

        try {
            if (!validatePatchUsersByUserIdInput(parameters, body)) {
                throw new ValidationError("Request validation failed", (validatePatchUsersByUserIdInput as any).errors, 400)
            }

            const result = await operations.patchUsersByUserId(
                req,parameters, body)

            if (!validatePatchUsersByUserIdOutput(result)) {
                throw new ValidationError("Response validation failed", (validatePatchUsersByUserIdOutput as any).errors, 500)
            }

            for (const headerName in result.headers) {
                const header = result.headers[headerName]
                if (header) {
                    res.setHeader(headerName, header)
                }
            }

            return res.status(result.status).json(result.body)
        } catch(error) {
            next(error)
            return
        }
    })

    router.delete("/users/:user_id", async (req: TypedRequest<{ "user_id": string },{},{}>, res, next) => {
        const parameters: deleteUsersByUserIdParametersType = {
            "user_id": req.params["user_id"]
        }

        try {
            if (!validateDeleteUsersByUserIdInput(parameters)) {
                throw new ValidationError("Request validation failed", (validateDeleteUsersByUserIdInput as any).errors, 400)
            }

            const result = await operations.deleteUsersByUserId(
                req,parameters)

            if (!validateDeleteUsersByUserIdOutput(result)) {
                throw new ValidationError("Response validation failed", (validateDeleteUsersByUserIdOutput as any).errors, 500)
            }

            for (const headerName in result.headers) {
                const header = result.headers[headerName]
                if (header) {
                    res.setHeader(headerName, header)
                }
            }

            return res.status(result.status).json(result.body)
        } catch(error) {
            next(error)
            return
        }
    })

    router.get("/identity", async (req: TypedRequest<{},{},{}>, res, next) => {
        try {
            if (!validateGetIdentityInput()) {
                throw new ValidationError("Request validation failed", (validateGetIdentityInput as any).errors, 400)
            }

            const result = await operations.getIdentity(
                req,)

            if (!validateGetIdentityOutput(result)) {
                throw new ValidationError("Response validation failed", (validateGetIdentityOutput as any).errors, 500)
            }

            for (const headerName in result.headers) {
                const header = result.headers[headerName]
                if (header) {
                    res.setHeader(headerName, header)
                }
            }

            return res.status(result.status).json(result.body)
        } catch(error) {
            next(error)
            return
        }
    })

    router.patch("/identity", async (req: TypedRequest<{},patchIdentityRequestBodyType,{}>, res, next) => {
        const body: patchIdentityRequestBodyType = req.body

        try {
            if (!validatePatchIdentityInput(body)) {
                throw new ValidationError("Request validation failed", (validatePatchIdentityInput as any).errors, 400)
            }

            const result = await operations.patchIdentity(
                req,body)

            if (!validatePatchIdentityOutput(result)) {
                throw new ValidationError("Response validation failed", (validatePatchIdentityOutput as any).errors, 500)
            }

            for (const headerName in result.headers) {
                const header = result.headers[headerName]
                if (header) {
                    res.setHeader(headerName, header)
                }
            }

            return res.status(result.status).json(result.body)
        } catch(error) {
            next(error)
            return
        }
    })

    router.post("/token", async (req: TypedRequest<{},postTokenRequestBodyType,{}>, res, next) => {
        const body: postTokenRequestBodyType = req.body

        try {
            if (!validatePostTokenInput(body)) {
                throw new ValidationError("Request validation failed", (validatePostTokenInput as any).errors, 400)
            }

            const result = await operations.postToken(
                req,body)

            if (!validatePostTokenOutput(result)) {
                throw new ValidationError("Response validation failed", (validatePostTokenOutput as any).errors, 500)
            }

            for (const headerName in result.headers) {
                const header = result.headers[headerName]
                if (header) {
                    res.setHeader(headerName, header)
                }
            }

            return res.status(result.status).json(result.body)
        } catch(error) {
            next(error)
            return
        }
    })

    return router
}