//@ts-nocheck
/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */
"use strict";
export const validateBasicUserType = validate21;
const schema6 = {
  title: "Basic User Type",
  type: "object",
  properties: {
    url: {type: "string", format: "uri"},
    username: {type: "string"},
    scopes: {type: "array", items: {type: "string"}},
  },
  required: ["url", "username", "scopes"],
  "x-typeguard": true,
  "x-standalone": true,
  "x-name": "BasicUserType",
  "x-location": "#/components/schemas/basic_user_type",
  "x-service-name": "Utility",
  "x-schema-type": "all",
};
const formats0 = require("ajv-formats/dist/formats").fullFormats.uri;
function validate21(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.username === undefined && (missing0 = "username")) ||
        (data.scopes === undefined && (missing0 = "scopes"))
      ) {
        validate21.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema6.required,
            parentSchema: schema6,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate21.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema6.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate21.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema6.properties.url.type,
                    parentSchema: schema6.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.username !== undefined) {
            let data1 = data.username;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate21.errors = [
                {
                  instancePath: instancePath + "/username",
                  schemaPath: "#/properties/username/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema6.properties.username.type,
                  parentSchema: schema6.properties.username,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.scopes !== undefined) {
              let data2 = data.scopes;
              const _errs5 = errors;
              if (errors === _errs5) {
                if (Array.isArray(data2)) {
                  var valid1 = true;
                  const len0 = data2.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data3 = data2[i0];
                    const _errs7 = errors;
                    if (typeof data3 !== "string") {
                      validate21.errors = [
                        {
                          instancePath: instancePath + "/scopes/" + i0,
                          schemaPath: "#/properties/scopes/items/type",
                          keyword: "type",
                          params: {type: "string"},
                          message: "must be string",
                          schema: schema6.properties.scopes.items.type,
                          parentSchema: schema6.properties.scopes.items,
                          data: data3,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs7 === errors;
                    if (!valid1) {
                      break;
                    }
                  }
                } else {
                  validate21.errors = [
                    {
                      instancePath: instancePath + "/scopes",
                      schemaPath: "#/properties/scopes/type",
                      keyword: "type",
                      params: {type: "array"},
                      message: "must be array",
                      schema: schema6.properties.scopes.type,
                      parentSchema: schema6.properties.scopes,
                      data: data2,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate21.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema6.type,
          parentSchema: schema6,
          data,
        },
      ];
      return false;
    }
  }
  validate21.errors = vErrors;
  return errors === 0;
}
export const validateUserTypeJWT = validate22;
const schema7 = {
  title: "User Type JWT",
  type: "object",
  properties: {
    url: {type: "string", format: "uri"},
    username: {type: "string"},
    scopes: {type: "array", items: {type: "string"}},
    jwt: {type: "string"},
  },
  required: ["url", "username", "scopes", "jwt"],
  "x-typeguard": true,
  "x-standalone": true,
  "x-name": "UserTypeJWT",
  "x-location": "#/components/schemas/user_type_jwt",
  "x-service-name": "Utility",
  "x-schema-type": "all",
};
function validate22(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.username === undefined && (missing0 = "username")) ||
        (data.scopes === undefined && (missing0 = "scopes")) ||
        (data.jwt === undefined && (missing0 = "jwt"))
      ) {
        validate22.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema7.required,
            parentSchema: schema7,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate22.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema7.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate22.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema7.properties.url.type,
                    parentSchema: schema7.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.username !== undefined) {
            let data1 = data.username;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate22.errors = [
                {
                  instancePath: instancePath + "/username",
                  schemaPath: "#/properties/username/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema7.properties.username.type,
                  parentSchema: schema7.properties.username,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.scopes !== undefined) {
              let data2 = data.scopes;
              const _errs5 = errors;
              if (errors === _errs5) {
                if (Array.isArray(data2)) {
                  var valid1 = true;
                  const len0 = data2.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data3 = data2[i0];
                    const _errs7 = errors;
                    if (typeof data3 !== "string") {
                      validate22.errors = [
                        {
                          instancePath: instancePath + "/scopes/" + i0,
                          schemaPath: "#/properties/scopes/items/type",
                          keyword: "type",
                          params: {type: "string"},
                          message: "must be string",
                          schema: schema7.properties.scopes.items.type,
                          parentSchema: schema7.properties.scopes.items,
                          data: data3,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs7 === errors;
                    if (!valid1) {
                      break;
                    }
                  }
                } else {
                  validate22.errors = [
                    {
                      instancePath: instancePath + "/scopes",
                      schemaPath: "#/properties/scopes/type",
                      keyword: "type",
                      params: {type: "array"},
                      message: "must be array",
                      schema: schema7.properties.scopes.type,
                      parentSchema: schema7.properties.scopes,
                      data: data2,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.jwt !== undefined) {
                let data4 = data.jwt;
                const _errs9 = errors;
                if (typeof data4 !== "string") {
                  validate22.errors = [
                    {
                      instancePath: instancePath + "/jwt",
                      schemaPath: "#/properties/jwt/type",
                      keyword: "type",
                      params: {type: "string"},
                      message: "must be string",
                      schema: schema7.properties.jwt.type,
                      parentSchema: schema7.properties.jwt,
                      data: data4,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs9 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate22.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema7.type,
          parentSchema: schema7,
          data,
        },
      ];
      return false;
    }
  }
  validate22.errors = vErrors;
  return errors === 0;
}
export const validateCredentials = validate23;
const schema8 = {
  title: "Credentials",
  type: "object",
  properties: {
    username: {description: "Username of the user.", type: "string"},
    password: {description: "Password of the user.", type: "string"},
  },
  required: ["username", "password"],
  "x-standalone": true,
  "x-name": "Credentials",
  "x-location": "#/components/schemas/credentials",
  "x-schema-type": "all",
};
function validate23(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate23.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema8.required,
            parentSchema: schema8,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== "string") {
            validate23.errors = [
              {
                instancePath: instancePath + "/username",
                schemaPath: "#/properties/username/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema8.properties.username.type,
                parentSchema: schema8.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate23.errors = [
                {
                  instancePath: instancePath + "/password",
                  schemaPath: "#/properties/password/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema8.properties.password.type,
                  parentSchema: schema8.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate23.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema8.type,
          parentSchema: schema8,
          data,
        },
      ];
      return false;
    }
  }
  validate23.errors = vErrors;
  return errors === 0;
}
export const validateAuthMethod = validate24;
const schema9 = {
  title: "AuthMethod",
  type: "string",
  description: "Authentication method.",
  enum: ["tui", "local"],
  "x-standalone": true,
  "x-name": "AuthMethod",
  "x-location": "#/components/schemas/auth_method",
  "x-schema-type": "all",
};
function validate24(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate24.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema9.type,
        parentSchema: schema9,
        data,
      },
    ];
    return false;
  }
  if (!(data === "tui" || data === "local")) {
    validate24.errors = [
      {
        instancePath,
        schemaPath: "#/enum",
        keyword: "enum",
        params: {allowedValues: schema9.enum},
        message: "must be equal to one of the allowed values",
        schema: schema9.enum,
        parentSchema: schema9,
        data,
      },
    ];
    return false;
  }
  validate24.errors = vErrors;
  return errors === 0;
}
export const validateUser = validate25;
const schema10 = {
  title: "User",
  type: "object",
  properties: {
    url: {type: "string", format: "uri", readOnly: true},
    id: {type: "string", readOnly: true},
    username: {type: "string"},
    password: {type: "string", writeOnly: true},
  },
  required: ["url", "id", "username", "password"],
  "x-standalone": true,
  "x-name": "User",
  "x-location": "#/components/schemas/user",
  "x-schema-type": "all",
};
function validate25(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.id === undefined && (missing0 = "id")) ||
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate25.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema10.required,
            parentSchema: schema10,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate25.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema10.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate25.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema10.properties.url.type,
                    parentSchema: schema10.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate25.errors = [
                {
                  instancePath: instancePath + "/id",
                  schemaPath: "#/properties/id/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema10.properties.id.type,
                  parentSchema: schema10.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== "string") {
                validate25.errors = [
                  {
                    instancePath: instancePath + "/username",
                    schemaPath: "#/properties/username/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema10.properties.username.type,
                    parentSchema: schema10.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== "string") {
                  validate25.errors = [
                    {
                      instancePath: instancePath + "/password",
                      schemaPath: "#/properties/password/type",
                      keyword: "type",
                      params: {type: "string"},
                      message: "must be string",
                      schema: schema10.properties.password.type,
                      parentSchema: schema10.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate25.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema10.type,
          parentSchema: schema10,
          data,
        },
      ];
      return false;
    }
  }
  validate25.errors = vErrors;
  return errors === 0;
}
export const validateUserUpdate = validate26;
const schema11 = {
  title: "User Update",
  type: "object",
  properties: {password: {type: "string", writeOnly: true}},
  required: ["password"],
  "x-standalone": true,
  "x-name": "UserUpdate",
  "x-location": "#/components/schemas/user_update",
  "x-schema-type": "all",
};
function validate26(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = "password")) {
        validate26.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema11.required,
            parentSchema: schema11,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== "string") {
            validate26.errors = [
              {
                instancePath: instancePath + "/password",
                schemaPath: "#/properties/password/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema11.properties.password.type,
                parentSchema: schema11.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate26.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema11.type,
          parentSchema: schema11,
          data,
        },
      ];
      return false;
    }
  }
  validate26.errors = vErrors;
  return errors === 0;
}
export const validateAuthorization = validate27;
const schema12 = {
  type: "string",
  "x-standalone": false,
  "x-name": "Authorization",
  "x-location": "#/components/parameters/authorization/schema",
  "x-schema-type": "all",
};
function validate27(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate27.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema12.type,
        parentSchema: schema12,
        data,
      },
    ];
    return false;
  }
  validate27.errors = vErrors;
  return errors === 0;
}
export const validateXRealIP = validate28;
const schema13 = {
  type: "string",
  format: "ipv4",
  description: "The IP address of the client.",
  "x-standalone": false,
  "x-name": "XRealIP",
  "x-location": "#/components/parameters/x_real_ip/schema",
  "x-schema-type": "all",
};
const formats6 =
  /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
function validate28(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === "string") {
        if (!formats6.test(data)) {
          validate28.errors = [
            {
              instancePath,
              schemaPath: "#/format",
              keyword: "format",
              params: {format: "ipv4"},
              message: 'must match format "' + "ipv4" + '"',
              schema: "ipv4",
              parentSchema: schema13,
              data,
            },
          ];
          return false;
        }
      } else {
        validate28.errors = [
          {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {type: "string"},
            message: "must be string",
            schema: schema13.type,
            parentSchema: schema13,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate28.errors = vErrors;
  return errors === 0;
}
export const validateXForwardedProto = validate29;
const schema14 = {
  type: "string",
  description: "The protocol of the client.",
  "x-standalone": false,
  "x-name": "XForwardedProto",
  "x-location": "#/components/parameters/x_forwarded_proto/schema",
  "x-schema-type": "all",
};
function validate29(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate29.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema14.type,
        parentSchema: schema14,
        data,
      },
    ];
    return false;
  }
  validate29.errors = vErrors;
  return errors === 0;
}
export const validateUserId = validate30;
const schema15 = {
  type: "string",
  "x-standalone": false,
  "x-name": "UserId",
  "x-location": "#/components/parameters/user_id/schema",
  "x-schema-type": "all",
};
function validate30(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate30.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema15.type,
        parentSchema: schema15,
        data,
      },
    ];
    return false;
  }
  validate30.errors = vErrors;
  return errors === 0;
}
export const validateGetAuthHeaderXRequestAuthentication = validate31;
const schema16 = {
  type: "string",
  format: "jwt",
  description: "The JWT which represents the authenticated user.",
  "x-standalone": false,
  "x-name": "getAuthHeaderXRequestAuthentication",
  "x-location": "#/paths//auth/get/responses/200/headers/X-Request-Authentication/schema",
  "x-schema-type": "all",
};
const formats8 = /^Bearer ([a-zA-Z0-9_=]+)\.([a-zA-Z0-9_=]+)\.([a-zA-Z0-9_\-+/=]*)/;
function validate31(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === "string") {
        if (!formats8.test(data)) {
          validate31.errors = [
            {
              instancePath,
              schemaPath: "#/format",
              keyword: "format",
              params: {format: "jwt"},
              message: 'must match format "' + "jwt" + '"',
              schema: "jwt",
              parentSchema: schema16,
              data,
            },
          ];
          return false;
        }
      } else {
        validate31.errors = [
          {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {type: "string"},
            message: "must be string",
            schema: schema16.type,
            parentSchema: schema16,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate31.errors = vErrors;
  return errors === 0;
}
export const validatePostLoginRequestBody = validate32;
const schema17 = {
  allOf: [
    {
      title: "Credentials",
      type: "object",
      properties: {
        username: {description: "Username of the user.", type: "string"},
        password: {description: "Password of the user.", type: "string"},
      },
      required: ["username", "password"],
    },
    {
      type: "object",
      properties: {
        method: {
          title: "AuthMethod",
          type: "string",
          description: "Authentication method.",
          enum: ["tui", "local"],
        },
      },
    },
  ],
  "x-standalone": false,
  "x-name": "postLoginRequestBody",
  "x-location": "#/paths//login/post/requestBody/content/application/json/schema",
  "x-schema-type": "all",
};
function validate32(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  if (errors === _errs0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate32.errors = [
          {
            instancePath,
            schemaPath: "#/allOf/0/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema17.allOf[0].required,
            parentSchema: schema17.allOf[0],
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs2 = errors;
          if (typeof data0 !== "string") {
            validate32.errors = [
              {
                instancePath: instancePath + "/username",
                schemaPath: "#/allOf/0/properties/username/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema17.allOf[0].properties.username.type,
                parentSchema: schema17.allOf[0].properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid1 = _errs2 === errors;
        } else {
          var valid1 = true;
        }
        if (valid1) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs4 = errors;
            if (typeof data1 !== "string") {
              validate32.errors = [
                {
                  instancePath: instancePath + "/password",
                  schemaPath: "#/allOf/0/properties/password/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema17.allOf[0].properties.password.type,
                  parentSchema: schema17.allOf[0].properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid1 = _errs4 === errors;
          } else {
            var valid1 = true;
          }
        }
      }
    } else {
      validate32.errors = [
        {
          instancePath,
          schemaPath: "#/allOf/0/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema17.allOf[0].type,
          parentSchema: schema17.allOf[0],
          data,
        },
      ];
      return false;
    }
  }
  var valid0 = _errs0 === errors;
  if (valid0) {
    const _errs6 = errors;
    if (errors === _errs6) {
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.method !== undefined) {
          let data2 = data.method;
          if (typeof data2 !== "string") {
            validate32.errors = [
              {
                instancePath: instancePath + "/method",
                schemaPath: "#/allOf/1/properties/method/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema17.allOf[1].properties.method.type,
                parentSchema: schema17.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
          if (!(data2 === "tui" || data2 === "local")) {
            validate32.errors = [
              {
                instancePath: instancePath + "/method",
                schemaPath: "#/allOf/1/properties/method/enum",
                keyword: "enum",
                params: {allowedValues: schema17.allOf[1].properties.method.enum},
                message: "must be equal to one of the allowed values",
                schema: schema17.allOf[1].properties.method.enum,
                parentSchema: schema17.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
        }
      } else {
        validate32.errors = [
          {
            instancePath,
            schemaPath: "#/allOf/1/type",
            keyword: "type",
            params: {type: "object"},
            message: "must be object",
            schema: schema17.allOf[1].type,
            parentSchema: schema17.allOf[1],
            data,
          },
        ];
        return false;
      }
    }
    var valid0 = _errs6 === errors;
  }
  validate32.errors = vErrors;
  return errors === 0;
}
export const validatePostLoginResponse201 = validate33;
const schema18 = {
  description: "The access token.",
  type: "string",
  "x-standalone": false,
  "x-name": "postLoginResponse201",
  "x-location": "#/paths//login/post/responses/201/content/application/json/schema",
  "x-schema-type": "all",
};
function validate33(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate33.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema18.type,
        parentSchema: schema18,
        data,
      },
    ];
    return false;
  }
  validate33.errors = vErrors;
  return errors === 0;
}
export const validatePostLogoutRequestBody = validate34;
const schema19 = {
  type: "object",
  properties: {token: {type: "string", description: "The token to be invalidated."}},
  "x-standalone": false,
  "x-name": "postLogoutRequestBody",
  "x-location": "#/paths//logout/post/requestBody/content/application/json/schema",
  "x-schema-type": "all",
};
function validate34(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.token !== undefined) {
        let data0 = data.token;
        if (typeof data0 !== "string") {
          validate34.errors = [
            {
              instancePath: instancePath + "/token",
              schemaPath: "#/properties/token/type",
              keyword: "type",
              params: {type: "string"},
              message: "must be string",
              schema: schema19.properties.token.type,
              parentSchema: schema19.properties.token,
              data: data0,
            },
          ];
          return false;
        }
      }
    } else {
      validate34.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema19.type,
          parentSchema: schema19,
          data,
        },
      ];
      return false;
    }
  }
  validate34.errors = vErrors;
  return errors === 0;
}
export const validateGetUsersResponse200 = validate35;
const schema20 = {
  type: "array",
  items: {
    title: "User",
    type: "object",
    properties: {
      url: {type: "string", format: "uri", readOnly: true},
      id: {type: "string", readOnly: true},
      username: {type: "string"},
      password: {type: "string", writeOnly: true},
    },
    required: ["url", "id", "username", "password"],
  },
  "x-standalone": false,
  "x-name": "getUsersResponse200",
  "x-location": "#/paths//users/get/responses/200/content/application/json/schema",
  "x-schema-type": "all",
};
function validate35(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.url === undefined && (missing0 = "url")) ||
              (data0.id === undefined && (missing0 = "id")) ||
              (data0.username === undefined && (missing0 = "username")) ||
              (data0.password === undefined && (missing0 = "password"))
            ) {
              validate35.errors = [
                {
                  instancePath: instancePath + "/" + i0,
                  schemaPath: "#/items/required",
                  keyword: "required",
                  params: {missingProperty: missing0},
                  message: "must have required property '" + missing0 + "'",
                  schema: schema20.items.required,
                  parentSchema: schema20.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.url !== undefined) {
                let data1 = data0.url;
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (errors === _errs3) {
                    if (typeof data1 === "string") {
                      if (!formats0(data1)) {
                        validate35.errors = [
                          {
                            instancePath: instancePath + "/" + i0 + "/url",
                            schemaPath: "#/items/properties/url/format",
                            keyword: "format",
                            params: {format: "uri"},
                            message: 'must match format "' + "uri" + '"',
                            schema: "uri",
                            parentSchema: schema20.items.properties.url,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    } else {
                      validate35.errors = [
                        {
                          instancePath: instancePath + "/" + i0 + "/url",
                          schemaPath: "#/items/properties/url/type",
                          keyword: "type",
                          params: {type: "string"},
                          message: "must be string",
                          schema: schema20.items.properties.url.type,
                          parentSchema: schema20.items.properties.url,
                          data: data1,
                        },
                      ];
                      return false;
                    }
                  }
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.id !== undefined) {
                  let data2 = data0.id;
                  const _errs5 = errors;
                  if (typeof data2 !== "string") {
                    validate35.errors = [
                      {
                        instancePath: instancePath + "/" + i0 + "/id",
                        schemaPath: "#/items/properties/id/type",
                        keyword: "type",
                        params: {type: "string"},
                        message: "must be string",
                        schema: schema20.items.properties.id.type,
                        parentSchema: schema20.items.properties.id,
                        data: data2,
                      },
                    ];
                    return false;
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.username !== undefined) {
                    let data3 = data0.username;
                    const _errs7 = errors;
                    if (typeof data3 !== "string") {
                      validate35.errors = [
                        {
                          instancePath: instancePath + "/" + i0 + "/username",
                          schemaPath: "#/items/properties/username/type",
                          keyword: "type",
                          params: {type: "string"},
                          message: "must be string",
                          schema: schema20.items.properties.username.type,
                          parentSchema: schema20.items.properties.username,
                          data: data3,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs7 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data0.password !== undefined) {
                      let data4 = data0.password;
                      const _errs9 = errors;
                      if (typeof data4 !== "string") {
                        validate35.errors = [
                          {
                            instancePath: instancePath + "/" + i0 + "/password",
                            schemaPath: "#/items/properties/password/type",
                            keyword: "type",
                            params: {type: "string"},
                            message: "must be string",
                            schema: schema20.items.properties.password.type,
                            parentSchema: schema20.items.properties.password,
                            data: data4,
                          },
                        ];
                        return false;
                      }
                      var valid1 = _errs9 === errors;
                    } else {
                      var valid1 = true;
                    }
                  }
                }
              }
            }
          } else {
            validate35.errors = [
              {
                instancePath: instancePath + "/" + i0,
                schemaPath: "#/items/type",
                keyword: "type",
                params: {type: "object"},
                message: "must be object",
                schema: schema20.items.type,
                parentSchema: schema20.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate35.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "array"},
          message: "must be array",
          schema: schema20.type,
          parentSchema: schema20,
          data,
        },
      ];
      return false;
    }
  }
  validate35.errors = vErrors;
  return errors === 0;
}
export const validatePostUsersRequestBody = validate36;
const schema21 = {
  title: "User",
  type: "object",
  properties: {
    url: {type: "string", format: "uri", readOnly: true},
    id: {type: "string", readOnly: true},
    username: {type: "string"},
    password: {type: "string", writeOnly: true},
  },
  required: ["url", "id", "username", "password"],
  "x-standalone": false,
  "x-name": "postUsersRequestBody",
  "x-location": "#/paths//users/post/requestBody/content/application/json/schema",
  "x-schema-type": "all",
};
function validate36(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.id === undefined && (missing0 = "id")) ||
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate36.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema21.required,
            parentSchema: schema21,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate36.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema21.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate36.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema21.properties.url.type,
                    parentSchema: schema21.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate36.errors = [
                {
                  instancePath: instancePath + "/id",
                  schemaPath: "#/properties/id/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema21.properties.id.type,
                  parentSchema: schema21.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== "string") {
                validate36.errors = [
                  {
                    instancePath: instancePath + "/username",
                    schemaPath: "#/properties/username/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema21.properties.username.type,
                    parentSchema: schema21.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== "string") {
                  validate36.errors = [
                    {
                      instancePath: instancePath + "/password",
                      schemaPath: "#/properties/password/type",
                      keyword: "type",
                      params: {type: "string"},
                      message: "must be string",
                      schema: schema21.properties.password.type,
                      parentSchema: schema21.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate36.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema21.type,
          parentSchema: schema21,
          data,
        },
      ];
      return false;
    }
  }
  validate36.errors = vErrors;
  return errors === 0;
}
export const validatePostUsersResponse201 = validate37;
const schema22 = {
  title: "User",
  type: "object",
  properties: {
    url: {type: "string", format: "uri", readOnly: true},
    id: {type: "string", readOnly: true},
    username: {type: "string"},
    password: {type: "string", writeOnly: true},
  },
  required: ["url", "id", "username", "password"],
  "x-standalone": false,
  "x-name": "postUsersResponse201",
  "x-location": "#/paths//users/post/responses/201/content/application/json/schema",
  "x-schema-type": "all",
};
function validate37(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.id === undefined && (missing0 = "id")) ||
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate37.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema22.required,
            parentSchema: schema22,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate37.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema22.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate37.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema22.properties.url.type,
                    parentSchema: schema22.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate37.errors = [
                {
                  instancePath: instancePath + "/id",
                  schemaPath: "#/properties/id/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema22.properties.id.type,
                  parentSchema: schema22.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== "string") {
                validate37.errors = [
                  {
                    instancePath: instancePath + "/username",
                    schemaPath: "#/properties/username/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema22.properties.username.type,
                    parentSchema: schema22.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== "string") {
                  validate37.errors = [
                    {
                      instancePath: instancePath + "/password",
                      schemaPath: "#/properties/password/type",
                      keyword: "type",
                      params: {type: "string"},
                      message: "must be string",
                      schema: schema22.properties.password.type,
                      parentSchema: schema22.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate37.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema22.type,
          parentSchema: schema22,
          data,
        },
      ];
      return false;
    }
  }
  validate37.errors = vErrors;
  return errors === 0;
}
export const validateGetUsersByUserIdResponse200 = validate38;
const schema23 = {
  title: "User",
  type: "object",
  properties: {
    url: {type: "string", format: "uri", readOnly: true},
    id: {type: "string", readOnly: true},
    username: {type: "string"},
    password: {type: "string", writeOnly: true},
  },
  required: ["url", "id", "username", "password"],
  "x-standalone": false,
  "x-name": "getUsersByUserIdResponse200",
  "x-location":
    "#/paths//users/{user_id}/get/responses/200/content/application/json/schema",
  "x-schema-type": "all",
};
function validate38(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.id === undefined && (missing0 = "id")) ||
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate38.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema23.required,
            parentSchema: schema23,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate38.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema23.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate38.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema23.properties.url.type,
                    parentSchema: schema23.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate38.errors = [
                {
                  instancePath: instancePath + "/id",
                  schemaPath: "#/properties/id/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema23.properties.id.type,
                  parentSchema: schema23.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== "string") {
                validate38.errors = [
                  {
                    instancePath: instancePath + "/username",
                    schemaPath: "#/properties/username/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema23.properties.username.type,
                    parentSchema: schema23.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== "string") {
                  validate38.errors = [
                    {
                      instancePath: instancePath + "/password",
                      schemaPath: "#/properties/password/type",
                      keyword: "type",
                      params: {type: "string"},
                      message: "must be string",
                      schema: schema23.properties.password.type,
                      parentSchema: schema23.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate38.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema23.type,
          parentSchema: schema23,
          data,
        },
      ];
      return false;
    }
  }
  validate38.errors = vErrors;
  return errors === 0;
}
export const validatePatchUsersByUserIdRequestBody = validate39;
const schema24 = {
  title: "User Update",
  type: "object",
  properties: {password: {type: "string", writeOnly: true}},
  required: ["password"],
  "x-standalone": false,
  "x-name": "patchUsersByUserIdRequestBody",
  "x-location":
    "#/paths//users/{user_id}/patch/requestBody/content/application/json/schema",
  "x-schema-type": "all",
};
function validate39(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = "password")) {
        validate39.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema24.required,
            parentSchema: schema24,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== "string") {
            validate39.errors = [
              {
                instancePath: instancePath + "/password",
                schemaPath: "#/properties/password/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema24.properties.password.type,
                parentSchema: schema24.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate39.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema24.type,
          parentSchema: schema24,
          data,
        },
      ];
      return false;
    }
  }
  validate39.errors = vErrors;
  return errors === 0;
}
export const validatePatchUsersByUserIdResponse200 = validate40;
const schema25 = {
  title: "User",
  type: "object",
  properties: {
    url: {type: "string", format: "uri", readOnly: true},
    id: {type: "string", readOnly: true},
    username: {type: "string"},
    password: {type: "string", writeOnly: true},
  },
  required: ["url", "id", "username", "password"],
  "x-standalone": false,
  "x-name": "patchUsersByUserIdResponse200",
  "x-location":
    "#/paths//users/{user_id}/patch/responses/200/content/application/json/schema",
  "x-schema-type": "all",
};
function validate40(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.id === undefined && (missing0 = "id")) ||
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate40.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema25.required,
            parentSchema: schema25,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate40.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema25.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate40.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema25.properties.url.type,
                    parentSchema: schema25.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate40.errors = [
                {
                  instancePath: instancePath + "/id",
                  schemaPath: "#/properties/id/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema25.properties.id.type,
                  parentSchema: schema25.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== "string") {
                validate40.errors = [
                  {
                    instancePath: instancePath + "/username",
                    schemaPath: "#/properties/username/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema25.properties.username.type,
                    parentSchema: schema25.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== "string") {
                  validate40.errors = [
                    {
                      instancePath: instancePath + "/password",
                      schemaPath: "#/properties/password/type",
                      keyword: "type",
                      params: {type: "string"},
                      message: "must be string",
                      schema: schema25.properties.password.type,
                      parentSchema: schema25.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate40.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema25.type,
          parentSchema: schema25,
          data,
        },
      ];
      return false;
    }
  }
  validate40.errors = vErrors;
  return errors === 0;
}
export const validateGetIdentityResponse200 = validate41;
const schema26 = {
  title: "User",
  type: "object",
  properties: {
    url: {type: "string", format: "uri", readOnly: true},
    id: {type: "string", readOnly: true},
    username: {type: "string"},
    password: {type: "string", writeOnly: true},
  },
  required: ["url", "id", "username", "password"],
  "x-standalone": false,
  "x-name": "getIdentityResponse200",
  "x-location": "#/paths//identity/get/responses/200/content/application/json/schema",
  "x-schema-type": "all",
};
function validate41(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.id === undefined && (missing0 = "id")) ||
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate41.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema26.required,
            parentSchema: schema26,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate41.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema26.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate41.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema26.properties.url.type,
                    parentSchema: schema26.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate41.errors = [
                {
                  instancePath: instancePath + "/id",
                  schemaPath: "#/properties/id/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema26.properties.id.type,
                  parentSchema: schema26.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== "string") {
                validate41.errors = [
                  {
                    instancePath: instancePath + "/username",
                    schemaPath: "#/properties/username/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema26.properties.username.type,
                    parentSchema: schema26.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== "string") {
                  validate41.errors = [
                    {
                      instancePath: instancePath + "/password",
                      schemaPath: "#/properties/password/type",
                      keyword: "type",
                      params: {type: "string"},
                      message: "must be string",
                      schema: schema26.properties.password.type,
                      parentSchema: schema26.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate41.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema26.type,
          parentSchema: schema26,
          data,
        },
      ];
      return false;
    }
  }
  validate41.errors = vErrors;
  return errors === 0;
}
export const validatePatchIdentityRequestBody = validate42;
const schema27 = {
  title: "User Update",
  type: "object",
  properties: {password: {type: "string", writeOnly: true}},
  required: ["password"],
  "x-standalone": false,
  "x-name": "patchIdentityRequestBody",
  "x-location": "#/paths//identity/patch/requestBody/content/application/json/schema",
  "x-schema-type": "all",
};
function validate42(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = "password")) {
        validate42.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema27.required,
            parentSchema: schema27,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== "string") {
            validate42.errors = [
              {
                instancePath: instancePath + "/password",
                schemaPath: "#/properties/password/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema27.properties.password.type,
                parentSchema: schema27.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate42.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema27.type,
          parentSchema: schema27,
          data,
        },
      ];
      return false;
    }
  }
  validate42.errors = vErrors;
  return errors === 0;
}
export const validatePatchIdentityResponse200 = validate43;
const schema28 = {
  title: "User",
  type: "object",
  properties: {
    url: {type: "string", format: "uri", readOnly: true},
    id: {type: "string", readOnly: true},
    username: {type: "string"},
    password: {type: "string", writeOnly: true},
  },
  required: ["url", "id", "username", "password"],
  "x-standalone": false,
  "x-name": "patchIdentityResponse200",
  "x-location": "#/paths//identity/patch/responses/200/content/application/json/schema",
  "x-schema-type": "all",
};
function validate43(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.id === undefined && (missing0 = "id")) ||
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate43.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema28.required,
            parentSchema: schema28,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate43.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema28.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate43.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema28.properties.url.type,
                    parentSchema: schema28.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate43.errors = [
                {
                  instancePath: instancePath + "/id",
                  schemaPath: "#/properties/id/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema28.properties.id.type,
                  parentSchema: schema28.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== "string") {
                validate43.errors = [
                  {
                    instancePath: instancePath + "/username",
                    schemaPath: "#/properties/username/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema28.properties.username.type,
                    parentSchema: schema28.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.password !== undefined) {
                let data3 = data.password;
                const _errs7 = errors;
                if (typeof data3 !== "string") {
                  validate43.errors = [
                    {
                      instancePath: instancePath + "/password",
                      schemaPath: "#/properties/password/type",
                      keyword: "type",
                      params: {type: "string"},
                      message: "must be string",
                      schema: schema28.properties.password.type,
                      parentSchema: schema28.properties.password,
                      data: data3,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate43.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema28.type,
          parentSchema: schema28,
          data,
        },
      ];
      return false;
    }
  }
  validate43.errors = vErrors;
  return errors === 0;
}
export const validatePostTokenRequestBody = validate44;
const schema29 = {
  type: "object",
  properties: {
    username: {type: "string", description: "The username of the user."},
    claims: {
      type: "object",
      description:
        "The claims that will be added to the token. If left empty, the token will have the full scope of the user.\n",
    },
  },
  "x-standalone": false,
  "x-name": "postTokenRequestBody",
  "x-location": "#/paths//token/post/requestBody/content/application/json/schema",
  "x-schema-type": "all",
};
function validate44(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.username !== undefined) {
        let data0 = data.username;
        const _errs1 = errors;
        if (typeof data0 !== "string") {
          validate44.errors = [
            {
              instancePath: instancePath + "/username",
              schemaPath: "#/properties/username/type",
              keyword: "type",
              params: {type: "string"},
              message: "must be string",
              schema: schema29.properties.username.type,
              parentSchema: schema29.properties.username,
              data: data0,
            },
          ];
          return false;
        }
        var valid0 = _errs1 === errors;
      } else {
        var valid0 = true;
      }
      if (valid0) {
        if (data.claims !== undefined) {
          let data1 = data.claims;
          const _errs3 = errors;
          if (!(data1 && typeof data1 == "object" && !Array.isArray(data1))) {
            validate44.errors = [
              {
                instancePath: instancePath + "/claims",
                schemaPath: "#/properties/claims/type",
                keyword: "type",
                params: {type: "object"},
                message: "must be object",
                schema: schema29.properties.claims.type,
                parentSchema: schema29.properties.claims,
                data: data1,
              },
            ];
            return false;
          }
          var valid0 = _errs3 === errors;
        } else {
          var valid0 = true;
        }
      }
    } else {
      validate44.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema29.type,
          parentSchema: schema29,
          data,
        },
      ];
      return false;
    }
  }
  validate44.errors = vErrors;
  return errors === 0;
}
export const validatePostTokenResponse201 = validate45;
const schema30 = {
  type: "string",
  "x-standalone": false,
  "x-name": "postTokenResponse201",
  "x-location": "#/paths//token/post/responses/201/content/application/json/schema",
  "x-schema-type": "all",
};
function validate45(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate45.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema30.type,
        parentSchema: schema30,
        data,
      },
    ];
    return false;
  }
  validate45.errors = vErrors;
  return errors === 0;
}
export const validateBasicUserTypeRequest = validate46;
const schema31 = {
  title: "Basic User Type",
  type: "object",
  properties: {
    url: {type: "string", format: "uri"},
    username: {type: "string"},
    scopes: {type: "array", items: {type: "string"}},
  },
  required: ["url", "username", "scopes"],
  "x-typeguard": true,
  "x-standalone": true,
  "x-name": "BasicUserTypeRequest",
  "x-location": "#/components/schemas/basic_user_type_request",
  "x-service-name": "Utility",
  "x-schema-type": "request",
};
function validate46(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.username === undefined && (missing0 = "username")) ||
        (data.scopes === undefined && (missing0 = "scopes"))
      ) {
        validate46.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema31.required,
            parentSchema: schema31,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate46.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema31.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate46.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema31.properties.url.type,
                    parentSchema: schema31.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.username !== undefined) {
            let data1 = data.username;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate46.errors = [
                {
                  instancePath: instancePath + "/username",
                  schemaPath: "#/properties/username/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema31.properties.username.type,
                  parentSchema: schema31.properties.username,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.scopes !== undefined) {
              let data2 = data.scopes;
              const _errs5 = errors;
              if (errors === _errs5) {
                if (Array.isArray(data2)) {
                  var valid1 = true;
                  const len0 = data2.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data3 = data2[i0];
                    const _errs7 = errors;
                    if (typeof data3 !== "string") {
                      validate46.errors = [
                        {
                          instancePath: instancePath + "/scopes/" + i0,
                          schemaPath: "#/properties/scopes/items/type",
                          keyword: "type",
                          params: {type: "string"},
                          message: "must be string",
                          schema: schema31.properties.scopes.items.type,
                          parentSchema: schema31.properties.scopes.items,
                          data: data3,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs7 === errors;
                    if (!valid1) {
                      break;
                    }
                  }
                } else {
                  validate46.errors = [
                    {
                      instancePath: instancePath + "/scopes",
                      schemaPath: "#/properties/scopes/type",
                      keyword: "type",
                      params: {type: "array"},
                      message: "must be array",
                      schema: schema31.properties.scopes.type,
                      parentSchema: schema31.properties.scopes,
                      data: data2,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate46.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema31.type,
          parentSchema: schema31,
          data,
        },
      ];
      return false;
    }
  }
  validate46.errors = vErrors;
  return errors === 0;
}
export const validateBasicUserTypeResponse = validate47;
const schema32 = {
  title: "Basic User Type",
  type: "object",
  properties: {
    url: {type: "string", format: "uri"},
    username: {type: "string"},
    scopes: {type: "array", items: {type: "string"}},
  },
  required: ["url", "username", "scopes"],
  "x-typeguard": true,
  "x-standalone": true,
  "x-name": "BasicUserTypeResponse",
  "x-location": "#/components/schemas/basic_user_type_response",
  "x-service-name": "Utility",
  "x-schema-type": "response",
};
function validate47(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.username === undefined && (missing0 = "username")) ||
        (data.scopes === undefined && (missing0 = "scopes"))
      ) {
        validate47.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema32.required,
            parentSchema: schema32,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate47.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema32.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate47.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema32.properties.url.type,
                    parentSchema: schema32.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.username !== undefined) {
            let data1 = data.username;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate47.errors = [
                {
                  instancePath: instancePath + "/username",
                  schemaPath: "#/properties/username/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema32.properties.username.type,
                  parentSchema: schema32.properties.username,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.scopes !== undefined) {
              let data2 = data.scopes;
              const _errs5 = errors;
              if (errors === _errs5) {
                if (Array.isArray(data2)) {
                  var valid1 = true;
                  const len0 = data2.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data3 = data2[i0];
                    const _errs7 = errors;
                    if (typeof data3 !== "string") {
                      validate47.errors = [
                        {
                          instancePath: instancePath + "/scopes/" + i0,
                          schemaPath: "#/properties/scopes/items/type",
                          keyword: "type",
                          params: {type: "string"},
                          message: "must be string",
                          schema: schema32.properties.scopes.items.type,
                          parentSchema: schema32.properties.scopes.items,
                          data: data3,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs7 === errors;
                    if (!valid1) {
                      break;
                    }
                  }
                } else {
                  validate47.errors = [
                    {
                      instancePath: instancePath + "/scopes",
                      schemaPath: "#/properties/scopes/type",
                      keyword: "type",
                      params: {type: "array"},
                      message: "must be array",
                      schema: schema32.properties.scopes.type,
                      parentSchema: schema32.properties.scopes,
                      data: data2,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate47.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema32.type,
          parentSchema: schema32,
          data,
        },
      ];
      return false;
    }
  }
  validate47.errors = vErrors;
  return errors === 0;
}
export const validateUserTypeJWTRequest = validate48;
const schema33 = {
  title: "User Type JWT",
  type: "object",
  properties: {
    url: {type: "string", format: "uri"},
    username: {type: "string"},
    scopes: {type: "array", items: {type: "string"}},
    jwt: {type: "string"},
  },
  required: ["url", "username", "scopes", "jwt"],
  "x-typeguard": true,
  "x-standalone": true,
  "x-name": "UserTypeJWTRequest",
  "x-location": "#/components/schemas/user_type_jwt_request",
  "x-service-name": "Utility",
  "x-schema-type": "request",
};
function validate48(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.username === undefined && (missing0 = "username")) ||
        (data.scopes === undefined && (missing0 = "scopes")) ||
        (data.jwt === undefined && (missing0 = "jwt"))
      ) {
        validate48.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema33.required,
            parentSchema: schema33,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate48.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema33.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate48.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema33.properties.url.type,
                    parentSchema: schema33.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.username !== undefined) {
            let data1 = data.username;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate48.errors = [
                {
                  instancePath: instancePath + "/username",
                  schemaPath: "#/properties/username/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema33.properties.username.type,
                  parentSchema: schema33.properties.username,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.scopes !== undefined) {
              let data2 = data.scopes;
              const _errs5 = errors;
              if (errors === _errs5) {
                if (Array.isArray(data2)) {
                  var valid1 = true;
                  const len0 = data2.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data3 = data2[i0];
                    const _errs7 = errors;
                    if (typeof data3 !== "string") {
                      validate48.errors = [
                        {
                          instancePath: instancePath + "/scopes/" + i0,
                          schemaPath: "#/properties/scopes/items/type",
                          keyword: "type",
                          params: {type: "string"},
                          message: "must be string",
                          schema: schema33.properties.scopes.items.type,
                          parentSchema: schema33.properties.scopes.items,
                          data: data3,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs7 === errors;
                    if (!valid1) {
                      break;
                    }
                  }
                } else {
                  validate48.errors = [
                    {
                      instancePath: instancePath + "/scopes",
                      schemaPath: "#/properties/scopes/type",
                      keyword: "type",
                      params: {type: "array"},
                      message: "must be array",
                      schema: schema33.properties.scopes.type,
                      parentSchema: schema33.properties.scopes,
                      data: data2,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.jwt !== undefined) {
                let data4 = data.jwt;
                const _errs9 = errors;
                if (typeof data4 !== "string") {
                  validate48.errors = [
                    {
                      instancePath: instancePath + "/jwt",
                      schemaPath: "#/properties/jwt/type",
                      keyword: "type",
                      params: {type: "string"},
                      message: "must be string",
                      schema: schema33.properties.jwt.type,
                      parentSchema: schema33.properties.jwt,
                      data: data4,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs9 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate48.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema33.type,
          parentSchema: schema33,
          data,
        },
      ];
      return false;
    }
  }
  validate48.errors = vErrors;
  return errors === 0;
}
export const validateUserTypeJWTResponse = validate49;
const schema34 = {
  title: "User Type JWT",
  type: "object",
  properties: {
    url: {type: "string", format: "uri"},
    username: {type: "string"},
    scopes: {type: "array", items: {type: "string"}},
    jwt: {type: "string"},
  },
  required: ["url", "username", "scopes", "jwt"],
  "x-typeguard": true,
  "x-standalone": true,
  "x-name": "UserTypeJWTResponse",
  "x-location": "#/components/schemas/user_type_jwt_response",
  "x-service-name": "Utility",
  "x-schema-type": "response",
};
function validate49(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.username === undefined && (missing0 = "username")) ||
        (data.scopes === undefined && (missing0 = "scopes")) ||
        (data.jwt === undefined && (missing0 = "jwt"))
      ) {
        validate49.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema34.required,
            parentSchema: schema34,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate49.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema34.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate49.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema34.properties.url.type,
                    parentSchema: schema34.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.username !== undefined) {
            let data1 = data.username;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate49.errors = [
                {
                  instancePath: instancePath + "/username",
                  schemaPath: "#/properties/username/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema34.properties.username.type,
                  parentSchema: schema34.properties.username,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.scopes !== undefined) {
              let data2 = data.scopes;
              const _errs5 = errors;
              if (errors === _errs5) {
                if (Array.isArray(data2)) {
                  var valid1 = true;
                  const len0 = data2.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data3 = data2[i0];
                    const _errs7 = errors;
                    if (typeof data3 !== "string") {
                      validate49.errors = [
                        {
                          instancePath: instancePath + "/scopes/" + i0,
                          schemaPath: "#/properties/scopes/items/type",
                          keyword: "type",
                          params: {type: "string"},
                          message: "must be string",
                          schema: schema34.properties.scopes.items.type,
                          parentSchema: schema34.properties.scopes.items,
                          data: data3,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs7 === errors;
                    if (!valid1) {
                      break;
                    }
                  }
                } else {
                  validate49.errors = [
                    {
                      instancePath: instancePath + "/scopes",
                      schemaPath: "#/properties/scopes/type",
                      keyword: "type",
                      params: {type: "array"},
                      message: "must be array",
                      schema: schema34.properties.scopes.type,
                      parentSchema: schema34.properties.scopes,
                      data: data2,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.jwt !== undefined) {
                let data4 = data.jwt;
                const _errs9 = errors;
                if (typeof data4 !== "string") {
                  validate49.errors = [
                    {
                      instancePath: instancePath + "/jwt",
                      schemaPath: "#/properties/jwt/type",
                      keyword: "type",
                      params: {type: "string"},
                      message: "must be string",
                      schema: schema34.properties.jwt.type,
                      parentSchema: schema34.properties.jwt,
                      data: data4,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs9 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate49.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema34.type,
          parentSchema: schema34,
          data,
        },
      ];
      return false;
    }
  }
  validate49.errors = vErrors;
  return errors === 0;
}
export const validateCredentialsRequest = validate50;
const schema35 = {
  title: "Credentials",
  type: "object",
  properties: {
    username: {description: "Username of the user.", type: "string"},
    password: {description: "Password of the user.", type: "string"},
  },
  required: ["username", "password"],
  "x-standalone": true,
  "x-name": "CredentialsRequest",
  "x-location": "#/components/schemas/credentials_request",
  "x-schema-type": "request",
};
function validate50(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate50.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema35.required,
            parentSchema: schema35,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== "string") {
            validate50.errors = [
              {
                instancePath: instancePath + "/username",
                schemaPath: "#/properties/username/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema35.properties.username.type,
                parentSchema: schema35.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate50.errors = [
                {
                  instancePath: instancePath + "/password",
                  schemaPath: "#/properties/password/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema35.properties.password.type,
                  parentSchema: schema35.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate50.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema35.type,
          parentSchema: schema35,
          data,
        },
      ];
      return false;
    }
  }
  validate50.errors = vErrors;
  return errors === 0;
}
export const validateCredentialsResponse = validate51;
const schema36 = {
  title: "Credentials",
  type: "object",
  properties: {
    username: {description: "Username of the user.", type: "string"},
    password: {description: "Password of the user.", type: "string"},
  },
  required: ["username", "password"],
  "x-standalone": true,
  "x-name": "CredentialsResponse",
  "x-location": "#/components/schemas/credentials_response",
  "x-schema-type": "response",
};
function validate51(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate51.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema36.required,
            parentSchema: schema36,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== "string") {
            validate51.errors = [
              {
                instancePath: instancePath + "/username",
                schemaPath: "#/properties/username/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema36.properties.username.type,
                parentSchema: schema36.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate51.errors = [
                {
                  instancePath: instancePath + "/password",
                  schemaPath: "#/properties/password/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema36.properties.password.type,
                  parentSchema: schema36.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate51.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema36.type,
          parentSchema: schema36,
          data,
        },
      ];
      return false;
    }
  }
  validate51.errors = vErrors;
  return errors === 0;
}
export const validateAuthMethodRequest = validate52;
const schema37 = {
  title: "AuthMethod",
  type: "string",
  description: "Authentication method.",
  enum: ["tui", "local"],
  "x-standalone": true,
  "x-name": "AuthMethodRequest",
  "x-location": "#/components/schemas/auth_method_request",
  "x-schema-type": "request",
};
function validate52(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate52.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema37.type,
        parentSchema: schema37,
        data,
      },
    ];
    return false;
  }
  if (!(data === "tui" || data === "local")) {
    validate52.errors = [
      {
        instancePath,
        schemaPath: "#/enum",
        keyword: "enum",
        params: {allowedValues: schema37.enum},
        message: "must be equal to one of the allowed values",
        schema: schema37.enum,
        parentSchema: schema37,
        data,
      },
    ];
    return false;
  }
  validate52.errors = vErrors;
  return errors === 0;
}
export const validateAuthMethodResponse = validate53;
const schema38 = {
  title: "AuthMethod",
  type: "string",
  description: "Authentication method.",
  enum: ["tui", "local"],
  "x-standalone": true,
  "x-name": "AuthMethodResponse",
  "x-location": "#/components/schemas/auth_method_response",
  "x-schema-type": "response",
};
function validate53(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate53.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema38.type,
        parentSchema: schema38,
        data,
      },
    ];
    return false;
  }
  if (!(data === "tui" || data === "local")) {
    validate53.errors = [
      {
        instancePath,
        schemaPath: "#/enum",
        keyword: "enum",
        params: {allowedValues: schema38.enum},
        message: "must be equal to one of the allowed values",
        schema: schema38.enum,
        parentSchema: schema38,
        data,
      },
    ];
    return false;
  }
  validate53.errors = vErrors;
  return errors === 0;
}
export const validateUserRequest = validate54;
const schema39 = {
  title: "User",
  type: "object",
  properties: {username: {type: "string"}, password: {type: "string", writeOnly: true}},
  required: ["username", "password"],
  "x-standalone": true,
  "x-name": "UserRequest",
  "x-location": "#/components/schemas/user_request",
  "x-schema-type": "request",
};
function validate54(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate54.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema39.required,
            parentSchema: schema39,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== "string") {
            validate54.errors = [
              {
                instancePath: instancePath + "/username",
                schemaPath: "#/properties/username/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema39.properties.username.type,
                parentSchema: schema39.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate54.errors = [
                {
                  instancePath: instancePath + "/password",
                  schemaPath: "#/properties/password/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema39.properties.password.type,
                  parentSchema: schema39.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate54.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema39.type,
          parentSchema: schema39,
          data,
        },
      ];
      return false;
    }
  }
  validate54.errors = vErrors;
  return errors === 0;
}
export const validateUserResponse = validate55;
const schema40 = {
  title: "User",
  type: "object",
  properties: {
    url: {type: "string", format: "uri", readOnly: true},
    id: {type: "string", readOnly: true},
    username: {type: "string"},
  },
  required: ["url", "id", "username"],
  "x-standalone": true,
  "x-name": "UserResponse",
  "x-location": "#/components/schemas/user_response",
  "x-schema-type": "response",
};
function validate55(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.id === undefined && (missing0 = "id")) ||
        (data.username === undefined && (missing0 = "username"))
      ) {
        validate55.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema40.required,
            parentSchema: schema40,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate55.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema40.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate55.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema40.properties.url.type,
                    parentSchema: schema40.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate55.errors = [
                {
                  instancePath: instancePath + "/id",
                  schemaPath: "#/properties/id/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema40.properties.id.type,
                  parentSchema: schema40.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== "string") {
                validate55.errors = [
                  {
                    instancePath: instancePath + "/username",
                    schemaPath: "#/properties/username/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema40.properties.username.type,
                    parentSchema: schema40.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate55.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema40.type,
          parentSchema: schema40,
          data,
        },
      ];
      return false;
    }
  }
  validate55.errors = vErrors;
  return errors === 0;
}
export const validateUserUpdateRequest = validate56;
const schema41 = {
  title: "User Update",
  type: "object",
  properties: {password: {type: "string", writeOnly: true}},
  required: ["password"],
  "x-standalone": true,
  "x-name": "UserUpdateRequest",
  "x-location": "#/components/schemas/user_update_request",
  "x-schema-type": "request",
};
function validate56(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = "password")) {
        validate56.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema41.required,
            parentSchema: schema41,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== "string") {
            validate56.errors = [
              {
                instancePath: instancePath + "/password",
                schemaPath: "#/properties/password/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema41.properties.password.type,
                parentSchema: schema41.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate56.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema41.type,
          parentSchema: schema41,
          data,
        },
      ];
      return false;
    }
  }
  validate56.errors = vErrors;
  return errors === 0;
}
export const validateUserUpdateResponse = validate57;
const schema42 = {
  title: "User Update",
  type: "object",
  properties: {},
  required: [],
  "x-standalone": true,
  "x-name": "UserUpdateResponse",
  "x-location": "#/components/schemas/user_update_response",
  "x-schema-type": "response",
};
function validate57(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (!(data && typeof data == "object" && !Array.isArray(data))) {
      validate57.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema42.type,
          parentSchema: schema42,
          data,
        },
      ];
      return false;
    }
  }
  validate57.errors = vErrors;
  return errors === 0;
}
export const validateAuthorizationRequest = validate58;
const schema43 = {
  type: "string",
  "x-standalone": false,
  "x-name": "AuthorizationRequest",
  "x-location": "#/components/parameters/authorization/schema_request",
  "x-schema-type": "request",
};
function validate58(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate58.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema43.type,
        parentSchema: schema43,
        data,
      },
    ];
    return false;
  }
  validate58.errors = vErrors;
  return errors === 0;
}
export const validateAuthorizationResponse = validate59;
const schema44 = {
  type: "string",
  "x-standalone": false,
  "x-name": "AuthorizationResponse",
  "x-location": "#/components/parameters/authorization/schema_response",
  "x-schema-type": "response",
};
function validate59(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate59.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema44.type,
        parentSchema: schema44,
        data,
      },
    ];
    return false;
  }
  validate59.errors = vErrors;
  return errors === 0;
}
export const validateXRealIPRequest = validate60;
const schema45 = {
  type: "string",
  format: "ipv4",
  description: "The IP address of the client.",
  "x-standalone": false,
  "x-name": "XRealIPRequest",
  "x-location": "#/components/parameters/x_real_ip/schema_request",
  "x-schema-type": "request",
};
function validate60(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === "string") {
        if (!formats6.test(data)) {
          validate60.errors = [
            {
              instancePath,
              schemaPath: "#/format",
              keyword: "format",
              params: {format: "ipv4"},
              message: 'must match format "' + "ipv4" + '"',
              schema: "ipv4",
              parentSchema: schema45,
              data,
            },
          ];
          return false;
        }
      } else {
        validate60.errors = [
          {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {type: "string"},
            message: "must be string",
            schema: schema45.type,
            parentSchema: schema45,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate60.errors = vErrors;
  return errors === 0;
}
export const validateXRealIPResponse = validate61;
const schema46 = {
  type: "string",
  format: "ipv4",
  description: "The IP address of the client.",
  "x-standalone": false,
  "x-name": "XRealIPResponse",
  "x-location": "#/components/parameters/x_real_ip/schema_response",
  "x-schema-type": "response",
};
function validate61(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === "string") {
        if (!formats6.test(data)) {
          validate61.errors = [
            {
              instancePath,
              schemaPath: "#/format",
              keyword: "format",
              params: {format: "ipv4"},
              message: 'must match format "' + "ipv4" + '"',
              schema: "ipv4",
              parentSchema: schema46,
              data,
            },
          ];
          return false;
        }
      } else {
        validate61.errors = [
          {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {type: "string"},
            message: "must be string",
            schema: schema46.type,
            parentSchema: schema46,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate61.errors = vErrors;
  return errors === 0;
}
export const validateXForwardedProtoRequest = validate62;
const schema47 = {
  type: "string",
  description: "The protocol of the client.",
  "x-standalone": false,
  "x-name": "XForwardedProtoRequest",
  "x-location": "#/components/parameters/x_forwarded_proto/schema_request",
  "x-schema-type": "request",
};
function validate62(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate62.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema47.type,
        parentSchema: schema47,
        data,
      },
    ];
    return false;
  }
  validate62.errors = vErrors;
  return errors === 0;
}
export const validateXForwardedProtoResponse = validate63;
const schema48 = {
  type: "string",
  description: "The protocol of the client.",
  "x-standalone": false,
  "x-name": "XForwardedProtoResponse",
  "x-location": "#/components/parameters/x_forwarded_proto/schema_response",
  "x-schema-type": "response",
};
function validate63(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate63.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema48.type,
        parentSchema: schema48,
        data,
      },
    ];
    return false;
  }
  validate63.errors = vErrors;
  return errors === 0;
}
export const validateUserIdRequest = validate64;
const schema49 = {
  type: "string",
  "x-standalone": false,
  "x-name": "UserIdRequest",
  "x-location": "#/components/parameters/user_id/schema_request",
  "x-schema-type": "request",
};
function validate64(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate64.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema49.type,
        parentSchema: schema49,
        data,
      },
    ];
    return false;
  }
  validate64.errors = vErrors;
  return errors === 0;
}
export const validateUserIdResponse = validate65;
const schema50 = {
  type: "string",
  "x-standalone": false,
  "x-name": "UserIdResponse",
  "x-location": "#/components/parameters/user_id/schema_response",
  "x-schema-type": "response",
};
function validate65(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate65.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema50.type,
        parentSchema: schema50,
        data,
      },
    ];
    return false;
  }
  validate65.errors = vErrors;
  return errors === 0;
}
export const validateGetAuthHeaderXRequestAuthenticationRequest = validate66;
const schema51 = {
  type: "string",
  format: "jwt",
  description: "The JWT which represents the authenticated user.",
  "x-standalone": false,
  "x-name": "getAuthHeaderXRequestAuthenticationRequest",
  "x-location":
    "#/paths//auth/get/responses/200/headers/X-Request-Authentication/schema_request",
  "x-schema-type": "request",
};
function validate66(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === "string") {
        if (!formats8.test(data)) {
          validate66.errors = [
            {
              instancePath,
              schemaPath: "#/format",
              keyword: "format",
              params: {format: "jwt"},
              message: 'must match format "' + "jwt" + '"',
              schema: "jwt",
              parentSchema: schema51,
              data,
            },
          ];
          return false;
        }
      } else {
        validate66.errors = [
          {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {type: "string"},
            message: "must be string",
            schema: schema51.type,
            parentSchema: schema51,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate66.errors = vErrors;
  return errors === 0;
}
export const validateGetAuthHeaderXRequestAuthenticationResponse = validate67;
const schema52 = {
  type: "string",
  format: "jwt",
  description: "The JWT which represents the authenticated user.",
  "x-standalone": false,
  "x-name": "getAuthHeaderXRequestAuthenticationResponse",
  "x-location":
    "#/paths//auth/get/responses/200/headers/X-Request-Authentication/schema_response",
  "x-schema-type": "response",
};
function validate67(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (errors === 0) {
      if (typeof data === "string") {
        if (!formats8.test(data)) {
          validate67.errors = [
            {
              instancePath,
              schemaPath: "#/format",
              keyword: "format",
              params: {format: "jwt"},
              message: 'must match format "' + "jwt" + '"',
              schema: "jwt",
              parentSchema: schema52,
              data,
            },
          ];
          return false;
        }
      } else {
        validate67.errors = [
          {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {type: "string"},
            message: "must be string",
            schema: schema52.type,
            parentSchema: schema52,
            data,
          },
        ];
        return false;
      }
    }
  }
  validate67.errors = vErrors;
  return errors === 0;
}
export const validatePostLoginRequestBodyRequest = validate68;
const schema53 = {
  allOf: [
    {
      title: "Credentials",
      type: "object",
      properties: {
        username: {description: "Username of the user.", type: "string"},
        password: {description: "Password of the user.", type: "string"},
      },
      required: ["username", "password"],
    },
    {
      type: "object",
      properties: {
        method: {
          title: "AuthMethod",
          type: "string",
          description: "Authentication method.",
          enum: ["tui", "local"],
        },
      },
    },
  ],
  "x-standalone": false,
  "x-name": "postLoginRequestBodyRequest",
  "x-location": "#/paths//login/post/requestBody/content/application/json/schema_request",
  "x-schema-type": "request",
};
function validate68(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  if (errors === _errs0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate68.errors = [
          {
            instancePath,
            schemaPath: "#/allOf/0/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema53.allOf[0].required,
            parentSchema: schema53.allOf[0],
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs2 = errors;
          if (typeof data0 !== "string") {
            validate68.errors = [
              {
                instancePath: instancePath + "/username",
                schemaPath: "#/allOf/0/properties/username/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema53.allOf[0].properties.username.type,
                parentSchema: schema53.allOf[0].properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid1 = _errs2 === errors;
        } else {
          var valid1 = true;
        }
        if (valid1) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs4 = errors;
            if (typeof data1 !== "string") {
              validate68.errors = [
                {
                  instancePath: instancePath + "/password",
                  schemaPath: "#/allOf/0/properties/password/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema53.allOf[0].properties.password.type,
                  parentSchema: schema53.allOf[0].properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid1 = _errs4 === errors;
          } else {
            var valid1 = true;
          }
        }
      }
    } else {
      validate68.errors = [
        {
          instancePath,
          schemaPath: "#/allOf/0/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema53.allOf[0].type,
          parentSchema: schema53.allOf[0],
          data,
        },
      ];
      return false;
    }
  }
  var valid0 = _errs0 === errors;
  if (valid0) {
    const _errs6 = errors;
    if (errors === _errs6) {
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.method !== undefined) {
          let data2 = data.method;
          if (typeof data2 !== "string") {
            validate68.errors = [
              {
                instancePath: instancePath + "/method",
                schemaPath: "#/allOf/1/properties/method/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema53.allOf[1].properties.method.type,
                parentSchema: schema53.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
          if (!(data2 === "tui" || data2 === "local")) {
            validate68.errors = [
              {
                instancePath: instancePath + "/method",
                schemaPath: "#/allOf/1/properties/method/enum",
                keyword: "enum",
                params: {allowedValues: schema53.allOf[1].properties.method.enum},
                message: "must be equal to one of the allowed values",
                schema: schema53.allOf[1].properties.method.enum,
                parentSchema: schema53.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
        }
      } else {
        validate68.errors = [
          {
            instancePath,
            schemaPath: "#/allOf/1/type",
            keyword: "type",
            params: {type: "object"},
            message: "must be object",
            schema: schema53.allOf[1].type,
            parentSchema: schema53.allOf[1],
            data,
          },
        ];
        return false;
      }
    }
    var valid0 = _errs6 === errors;
  }
  validate68.errors = vErrors;
  return errors === 0;
}
export const validatePostLoginRequestBodyResponse = validate69;
const schema54 = {
  allOf: [
    {
      title: "Credentials",
      type: "object",
      properties: {
        username: {description: "Username of the user.", type: "string"},
        password: {description: "Password of the user.", type: "string"},
      },
      required: ["username", "password"],
    },
    {
      type: "object",
      properties: {
        method: {
          title: "AuthMethod",
          type: "string",
          description: "Authentication method.",
          enum: ["tui", "local"],
        },
      },
    },
  ],
  "x-standalone": false,
  "x-name": "postLoginRequestBodyResponse",
  "x-location":
    "#/paths//login/post/requestBody/content/application/json/schema_response",
  "x-schema-type": "response",
};
function validate69(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  if (errors === _errs0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate69.errors = [
          {
            instancePath,
            schemaPath: "#/allOf/0/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema54.allOf[0].required,
            parentSchema: schema54.allOf[0],
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs2 = errors;
          if (typeof data0 !== "string") {
            validate69.errors = [
              {
                instancePath: instancePath + "/username",
                schemaPath: "#/allOf/0/properties/username/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema54.allOf[0].properties.username.type,
                parentSchema: schema54.allOf[0].properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid1 = _errs2 === errors;
        } else {
          var valid1 = true;
        }
        if (valid1) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs4 = errors;
            if (typeof data1 !== "string") {
              validate69.errors = [
                {
                  instancePath: instancePath + "/password",
                  schemaPath: "#/allOf/0/properties/password/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema54.allOf[0].properties.password.type,
                  parentSchema: schema54.allOf[0].properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid1 = _errs4 === errors;
          } else {
            var valid1 = true;
          }
        }
      }
    } else {
      validate69.errors = [
        {
          instancePath,
          schemaPath: "#/allOf/0/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema54.allOf[0].type,
          parentSchema: schema54.allOf[0],
          data,
        },
      ];
      return false;
    }
  }
  var valid0 = _errs0 === errors;
  if (valid0) {
    const _errs6 = errors;
    if (errors === _errs6) {
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.method !== undefined) {
          let data2 = data.method;
          if (typeof data2 !== "string") {
            validate69.errors = [
              {
                instancePath: instancePath + "/method",
                schemaPath: "#/allOf/1/properties/method/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema54.allOf[1].properties.method.type,
                parentSchema: schema54.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
          if (!(data2 === "tui" || data2 === "local")) {
            validate69.errors = [
              {
                instancePath: instancePath + "/method",
                schemaPath: "#/allOf/1/properties/method/enum",
                keyword: "enum",
                params: {allowedValues: schema54.allOf[1].properties.method.enum},
                message: "must be equal to one of the allowed values",
                schema: schema54.allOf[1].properties.method.enum,
                parentSchema: schema54.allOf[1].properties.method,
                data: data2,
              },
            ];
            return false;
          }
        }
      } else {
        validate69.errors = [
          {
            instancePath,
            schemaPath: "#/allOf/1/type",
            keyword: "type",
            params: {type: "object"},
            message: "must be object",
            schema: schema54.allOf[1].type,
            parentSchema: schema54.allOf[1],
            data,
          },
        ];
        return false;
      }
    }
    var valid0 = _errs6 === errors;
  }
  validate69.errors = vErrors;
  return errors === 0;
}
export const validatePostLoginResponse201Request = validate70;
const schema55 = {
  description: "The access token.",
  type: "string",
  "x-standalone": false,
  "x-name": "postLoginResponse201Request",
  "x-location":
    "#/paths//login/post/responses/201/content/application/json/schema_request",
  "x-schema-type": "request",
};
function validate70(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate70.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema55.type,
        parentSchema: schema55,
        data,
      },
    ];
    return false;
  }
  validate70.errors = vErrors;
  return errors === 0;
}
export const validatePostLoginResponse201Response = validate71;
const schema56 = {
  description: "The access token.",
  type: "string",
  "x-standalone": false,
  "x-name": "postLoginResponse201Response",
  "x-location":
    "#/paths//login/post/responses/201/content/application/json/schema_response",
  "x-schema-type": "response",
};
function validate71(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate71.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema56.type,
        parentSchema: schema56,
        data,
      },
    ];
    return false;
  }
  validate71.errors = vErrors;
  return errors === 0;
}
export const validatePostLogoutRequestBodyRequest = validate72;
const schema57 = {
  type: "object",
  properties: {token: {type: "string", description: "The token to be invalidated."}},
  "x-standalone": false,
  "x-name": "postLogoutRequestBodyRequest",
  "x-location":
    "#/paths//logout/post/requestBody/content/application/json/schema_request",
  "x-schema-type": "request",
};
function validate72(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.token !== undefined) {
        let data0 = data.token;
        if (typeof data0 !== "string") {
          validate72.errors = [
            {
              instancePath: instancePath + "/token",
              schemaPath: "#/properties/token/type",
              keyword: "type",
              params: {type: "string"},
              message: "must be string",
              schema: schema57.properties.token.type,
              parentSchema: schema57.properties.token,
              data: data0,
            },
          ];
          return false;
        }
      }
    } else {
      validate72.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema57.type,
          parentSchema: schema57,
          data,
        },
      ];
      return false;
    }
  }
  validate72.errors = vErrors;
  return errors === 0;
}
export const validatePostLogoutRequestBodyResponse = validate73;
const schema58 = {
  type: "object",
  properties: {token: {type: "string", description: "The token to be invalidated."}},
  "x-standalone": false,
  "x-name": "postLogoutRequestBodyResponse",
  "x-location":
    "#/paths//logout/post/requestBody/content/application/json/schema_response",
  "x-schema-type": "response",
};
function validate73(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.token !== undefined) {
        let data0 = data.token;
        if (typeof data0 !== "string") {
          validate73.errors = [
            {
              instancePath: instancePath + "/token",
              schemaPath: "#/properties/token/type",
              keyword: "type",
              params: {type: "string"},
              message: "must be string",
              schema: schema58.properties.token.type,
              parentSchema: schema58.properties.token,
              data: data0,
            },
          ];
          return false;
        }
      }
    } else {
      validate73.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema58.type,
          parentSchema: schema58,
          data,
        },
      ];
      return false;
    }
  }
  validate73.errors = vErrors;
  return errors === 0;
}
export const validateGetUsersResponse200Request = validate74;
const schema59 = {
  type: "array",
  items: {
    title: "User",
    type: "object",
    properties: {username: {type: "string"}, password: {type: "string", writeOnly: true}},
    required: ["username", "password"],
  },
  "x-standalone": false,
  "x-name": "getUsersResponse200Request",
  "x-location":
    "#/paths//users/get/responses/200/content/application/json/schema_request",
  "x-schema-type": "request",
};
function validate74(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.username === undefined && (missing0 = "username")) ||
              (data0.password === undefined && (missing0 = "password"))
            ) {
              validate74.errors = [
                {
                  instancePath: instancePath + "/" + i0,
                  schemaPath: "#/items/required",
                  keyword: "required",
                  params: {missingProperty: missing0},
                  message: "must have required property '" + missing0 + "'",
                  schema: schema59.items.required,
                  parentSchema: schema59.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.username !== undefined) {
                let data1 = data0.username;
                const _errs3 = errors;
                if (typeof data1 !== "string") {
                  validate74.errors = [
                    {
                      instancePath: instancePath + "/" + i0 + "/username",
                      schemaPath: "#/items/properties/username/type",
                      keyword: "type",
                      params: {type: "string"},
                      message: "must be string",
                      schema: schema59.items.properties.username.type,
                      parentSchema: schema59.items.properties.username,
                      data: data1,
                    },
                  ];
                  return false;
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.password !== undefined) {
                  let data2 = data0.password;
                  const _errs5 = errors;
                  if (typeof data2 !== "string") {
                    validate74.errors = [
                      {
                        instancePath: instancePath + "/" + i0 + "/password",
                        schemaPath: "#/items/properties/password/type",
                        keyword: "type",
                        params: {type: "string"},
                        message: "must be string",
                        schema: schema59.items.properties.password.type,
                        parentSchema: schema59.items.properties.password,
                        data: data2,
                      },
                    ];
                    return false;
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
              }
            }
          } else {
            validate74.errors = [
              {
                instancePath: instancePath + "/" + i0,
                schemaPath: "#/items/type",
                keyword: "type",
                params: {type: "object"},
                message: "must be object",
                schema: schema59.items.type,
                parentSchema: schema59.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate74.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "array"},
          message: "must be array",
          schema: schema59.type,
          parentSchema: schema59,
          data,
        },
      ];
      return false;
    }
  }
  validate74.errors = vErrors;
  return errors === 0;
}
export const validateGetUsersResponse200Response = validate75;
const schema60 = {
  type: "array",
  items: {
    title: "User",
    type: "object",
    properties: {
      url: {type: "string", format: "uri", readOnly: true},
      id: {type: "string", readOnly: true},
      username: {type: "string"},
    },
    required: ["url", "id", "username"],
  },
  "x-standalone": false,
  "x-name": "getUsersResponse200Response",
  "x-location":
    "#/paths//users/get/responses/200/content/application/json/schema_response",
  "x-schema-type": "response",
};
function validate75(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.url === undefined && (missing0 = "url")) ||
              (data0.id === undefined && (missing0 = "id")) ||
              (data0.username === undefined && (missing0 = "username"))
            ) {
              validate75.errors = [
                {
                  instancePath: instancePath + "/" + i0,
                  schemaPath: "#/items/required",
                  keyword: "required",
                  params: {missingProperty: missing0},
                  message: "must have required property '" + missing0 + "'",
                  schema: schema60.items.required,
                  parentSchema: schema60.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.url !== undefined) {
                let data1 = data0.url;
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (errors === _errs3) {
                    if (typeof data1 === "string") {
                      if (!formats0(data1)) {
                        validate75.errors = [
                          {
                            instancePath: instancePath + "/" + i0 + "/url",
                            schemaPath: "#/items/properties/url/format",
                            keyword: "format",
                            params: {format: "uri"},
                            message: 'must match format "' + "uri" + '"',
                            schema: "uri",
                            parentSchema: schema60.items.properties.url,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    } else {
                      validate75.errors = [
                        {
                          instancePath: instancePath + "/" + i0 + "/url",
                          schemaPath: "#/items/properties/url/type",
                          keyword: "type",
                          params: {type: "string"},
                          message: "must be string",
                          schema: schema60.items.properties.url.type,
                          parentSchema: schema60.items.properties.url,
                          data: data1,
                        },
                      ];
                      return false;
                    }
                  }
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.id !== undefined) {
                  let data2 = data0.id;
                  const _errs5 = errors;
                  if (typeof data2 !== "string") {
                    validate75.errors = [
                      {
                        instancePath: instancePath + "/" + i0 + "/id",
                        schemaPath: "#/items/properties/id/type",
                        keyword: "type",
                        params: {type: "string"},
                        message: "must be string",
                        schema: schema60.items.properties.id.type,
                        parentSchema: schema60.items.properties.id,
                        data: data2,
                      },
                    ];
                    return false;
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.username !== undefined) {
                    let data3 = data0.username;
                    const _errs7 = errors;
                    if (typeof data3 !== "string") {
                      validate75.errors = [
                        {
                          instancePath: instancePath + "/" + i0 + "/username",
                          schemaPath: "#/items/properties/username/type",
                          keyword: "type",
                          params: {type: "string"},
                          message: "must be string",
                          schema: schema60.items.properties.username.type,
                          parentSchema: schema60.items.properties.username,
                          data: data3,
                        },
                      ];
                      return false;
                    }
                    var valid1 = _errs7 === errors;
                  } else {
                    var valid1 = true;
                  }
                }
              }
            }
          } else {
            validate75.errors = [
              {
                instancePath: instancePath + "/" + i0,
                schemaPath: "#/items/type",
                keyword: "type",
                params: {type: "object"},
                message: "must be object",
                schema: schema60.items.type,
                parentSchema: schema60.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate75.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "array"},
          message: "must be array",
          schema: schema60.type,
          parentSchema: schema60,
          data,
        },
      ];
      return false;
    }
  }
  validate75.errors = vErrors;
  return errors === 0;
}
export const validatePostUsersRequestBodyRequest = validate76;
const schema61 = {
  title: "User",
  type: "object",
  properties: {username: {type: "string"}, password: {type: "string", writeOnly: true}},
  required: ["username", "password"],
  "x-standalone": false,
  "x-name": "postUsersRequestBodyRequest",
  "x-location": "#/paths//users/post/requestBody/content/application/json/schema_request",
  "x-schema-type": "request",
};
function validate76(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate76.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema61.required,
            parentSchema: schema61,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== "string") {
            validate76.errors = [
              {
                instancePath: instancePath + "/username",
                schemaPath: "#/properties/username/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema61.properties.username.type,
                parentSchema: schema61.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate76.errors = [
                {
                  instancePath: instancePath + "/password",
                  schemaPath: "#/properties/password/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema61.properties.password.type,
                  parentSchema: schema61.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate76.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema61.type,
          parentSchema: schema61,
          data,
        },
      ];
      return false;
    }
  }
  validate76.errors = vErrors;
  return errors === 0;
}
export const validatePostUsersRequestBodyResponse = validate77;
const schema62 = {
  title: "User",
  type: "object",
  properties: {
    url: {type: "string", format: "uri", readOnly: true},
    id: {type: "string", readOnly: true},
    username: {type: "string"},
  },
  required: ["url", "id", "username"],
  "x-standalone": false,
  "x-name": "postUsersRequestBodyResponse",
  "x-location":
    "#/paths//users/post/requestBody/content/application/json/schema_response",
  "x-schema-type": "response",
};
function validate77(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.id === undefined && (missing0 = "id")) ||
        (data.username === undefined && (missing0 = "username"))
      ) {
        validate77.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema62.required,
            parentSchema: schema62,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate77.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema62.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate77.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema62.properties.url.type,
                    parentSchema: schema62.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate77.errors = [
                {
                  instancePath: instancePath + "/id",
                  schemaPath: "#/properties/id/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema62.properties.id.type,
                  parentSchema: schema62.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== "string") {
                validate77.errors = [
                  {
                    instancePath: instancePath + "/username",
                    schemaPath: "#/properties/username/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema62.properties.username.type,
                    parentSchema: schema62.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate77.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema62.type,
          parentSchema: schema62,
          data,
        },
      ];
      return false;
    }
  }
  validate77.errors = vErrors;
  return errors === 0;
}
export const validatePostUsersResponse201Request = validate78;
const schema63 = {
  title: "User",
  type: "object",
  properties: {username: {type: "string"}, password: {type: "string", writeOnly: true}},
  required: ["username", "password"],
  "x-standalone": false,
  "x-name": "postUsersResponse201Request",
  "x-location":
    "#/paths//users/post/responses/201/content/application/json/schema_request",
  "x-schema-type": "request",
};
function validate78(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate78.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema63.required,
            parentSchema: schema63,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== "string") {
            validate78.errors = [
              {
                instancePath: instancePath + "/username",
                schemaPath: "#/properties/username/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema63.properties.username.type,
                parentSchema: schema63.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate78.errors = [
                {
                  instancePath: instancePath + "/password",
                  schemaPath: "#/properties/password/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema63.properties.password.type,
                  parentSchema: schema63.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate78.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema63.type,
          parentSchema: schema63,
          data,
        },
      ];
      return false;
    }
  }
  validate78.errors = vErrors;
  return errors === 0;
}
export const validatePostUsersResponse201Response = validate79;
const schema64 = {
  title: "User",
  type: "object",
  properties: {
    url: {type: "string", format: "uri", readOnly: true},
    id: {type: "string", readOnly: true},
    username: {type: "string"},
  },
  required: ["url", "id", "username"],
  "x-standalone": false,
  "x-name": "postUsersResponse201Response",
  "x-location":
    "#/paths//users/post/responses/201/content/application/json/schema_response",
  "x-schema-type": "response",
};
function validate79(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.id === undefined && (missing0 = "id")) ||
        (data.username === undefined && (missing0 = "username"))
      ) {
        validate79.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema64.required,
            parentSchema: schema64,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate79.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema64.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate79.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema64.properties.url.type,
                    parentSchema: schema64.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate79.errors = [
                {
                  instancePath: instancePath + "/id",
                  schemaPath: "#/properties/id/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema64.properties.id.type,
                  parentSchema: schema64.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== "string") {
                validate79.errors = [
                  {
                    instancePath: instancePath + "/username",
                    schemaPath: "#/properties/username/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema64.properties.username.type,
                    parentSchema: schema64.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate79.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema64.type,
          parentSchema: schema64,
          data,
        },
      ];
      return false;
    }
  }
  validate79.errors = vErrors;
  return errors === 0;
}
export const validateGetUsersByUserIdResponse200Request = validate80;
const schema65 = {
  title: "User",
  type: "object",
  properties: {username: {type: "string"}, password: {type: "string", writeOnly: true}},
  required: ["username", "password"],
  "x-standalone": false,
  "x-name": "getUsersByUserIdResponse200Request",
  "x-location":
    "#/paths//users/{user_id}/get/responses/200/content/application/json/schema_request",
  "x-schema-type": "request",
};
function validate80(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate80.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema65.required,
            parentSchema: schema65,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== "string") {
            validate80.errors = [
              {
                instancePath: instancePath + "/username",
                schemaPath: "#/properties/username/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema65.properties.username.type,
                parentSchema: schema65.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate80.errors = [
                {
                  instancePath: instancePath + "/password",
                  schemaPath: "#/properties/password/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema65.properties.password.type,
                  parentSchema: schema65.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate80.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema65.type,
          parentSchema: schema65,
          data,
        },
      ];
      return false;
    }
  }
  validate80.errors = vErrors;
  return errors === 0;
}
export const validateGetUsersByUserIdResponse200Response = validate81;
const schema66 = {
  title: "User",
  type: "object",
  properties: {
    url: {type: "string", format: "uri", readOnly: true},
    id: {type: "string", readOnly: true},
    username: {type: "string"},
  },
  required: ["url", "id", "username"],
  "x-standalone": false,
  "x-name": "getUsersByUserIdResponse200Response",
  "x-location":
    "#/paths//users/{user_id}/get/responses/200/content/application/json/schema_response",
  "x-schema-type": "response",
};
function validate81(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.id === undefined && (missing0 = "id")) ||
        (data.username === undefined && (missing0 = "username"))
      ) {
        validate81.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema66.required,
            parentSchema: schema66,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate81.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema66.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate81.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema66.properties.url.type,
                    parentSchema: schema66.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate81.errors = [
                {
                  instancePath: instancePath + "/id",
                  schemaPath: "#/properties/id/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema66.properties.id.type,
                  parentSchema: schema66.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== "string") {
                validate81.errors = [
                  {
                    instancePath: instancePath + "/username",
                    schemaPath: "#/properties/username/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema66.properties.username.type,
                    parentSchema: schema66.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate81.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema66.type,
          parentSchema: schema66,
          data,
        },
      ];
      return false;
    }
  }
  validate81.errors = vErrors;
  return errors === 0;
}
export const validatePatchUsersByUserIdRequestBodyRequest = validate82;
const schema67 = {
  title: "User Update",
  type: "object",
  properties: {password: {type: "string", writeOnly: true}},
  required: ["password"],
  "x-standalone": false,
  "x-name": "patchUsersByUserIdRequestBodyRequest",
  "x-location":
    "#/paths//users/{user_id}/patch/requestBody/content/application/json/schema_request",
  "x-schema-type": "request",
};
function validate82(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = "password")) {
        validate82.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema67.required,
            parentSchema: schema67,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== "string") {
            validate82.errors = [
              {
                instancePath: instancePath + "/password",
                schemaPath: "#/properties/password/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema67.properties.password.type,
                parentSchema: schema67.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate82.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema67.type,
          parentSchema: schema67,
          data,
        },
      ];
      return false;
    }
  }
  validate82.errors = vErrors;
  return errors === 0;
}
export const validatePatchUsersByUserIdRequestBodyResponse = validate83;
const schema68 = {
  title: "User Update",
  type: "object",
  properties: {},
  required: [],
  "x-standalone": false,
  "x-name": "patchUsersByUserIdRequestBodyResponse",
  "x-location":
    "#/paths//users/{user_id}/patch/requestBody/content/application/json/schema_response",
  "x-schema-type": "response",
};
function validate83(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (!(data && typeof data == "object" && !Array.isArray(data))) {
      validate83.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema68.type,
          parentSchema: schema68,
          data,
        },
      ];
      return false;
    }
  }
  validate83.errors = vErrors;
  return errors === 0;
}
export const validatePatchUsersByUserIdResponse200Request = validate84;
const schema69 = {
  title: "User",
  type: "object",
  properties: {username: {type: "string"}, password: {type: "string", writeOnly: true}},
  required: ["username", "password"],
  "x-standalone": false,
  "x-name": "patchUsersByUserIdResponse200Request",
  "x-location":
    "#/paths//users/{user_id}/patch/responses/200/content/application/json/schema_request",
  "x-schema-type": "request",
};
function validate84(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate84.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema69.required,
            parentSchema: schema69,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== "string") {
            validate84.errors = [
              {
                instancePath: instancePath + "/username",
                schemaPath: "#/properties/username/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema69.properties.username.type,
                parentSchema: schema69.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate84.errors = [
                {
                  instancePath: instancePath + "/password",
                  schemaPath: "#/properties/password/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema69.properties.password.type,
                  parentSchema: schema69.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate84.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema69.type,
          parentSchema: schema69,
          data,
        },
      ];
      return false;
    }
  }
  validate84.errors = vErrors;
  return errors === 0;
}
export const validatePatchUsersByUserIdResponse200Response = validate85;
const schema70 = {
  title: "User",
  type: "object",
  properties: {
    url: {type: "string", format: "uri", readOnly: true},
    id: {type: "string", readOnly: true},
    username: {type: "string"},
  },
  required: ["url", "id", "username"],
  "x-standalone": false,
  "x-name": "patchUsersByUserIdResponse200Response",
  "x-location":
    "#/paths//users/{user_id}/patch/responses/200/content/application/json/schema_response",
  "x-schema-type": "response",
};
function validate85(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.id === undefined && (missing0 = "id")) ||
        (data.username === undefined && (missing0 = "username"))
      ) {
        validate85.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema70.required,
            parentSchema: schema70,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate85.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema70.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate85.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema70.properties.url.type,
                    parentSchema: schema70.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate85.errors = [
                {
                  instancePath: instancePath + "/id",
                  schemaPath: "#/properties/id/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema70.properties.id.type,
                  parentSchema: schema70.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== "string") {
                validate85.errors = [
                  {
                    instancePath: instancePath + "/username",
                    schemaPath: "#/properties/username/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema70.properties.username.type,
                    parentSchema: schema70.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate85.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema70.type,
          parentSchema: schema70,
          data,
        },
      ];
      return false;
    }
  }
  validate85.errors = vErrors;
  return errors === 0;
}
export const validateGetIdentityResponse200Request = validate86;
const schema71 = {
  title: "User",
  type: "object",
  properties: {username: {type: "string"}, password: {type: "string", writeOnly: true}},
  required: ["username", "password"],
  "x-standalone": false,
  "x-name": "getIdentityResponse200Request",
  "x-location":
    "#/paths//identity/get/responses/200/content/application/json/schema_request",
  "x-schema-type": "request",
};
function validate86(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate86.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema71.required,
            parentSchema: schema71,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== "string") {
            validate86.errors = [
              {
                instancePath: instancePath + "/username",
                schemaPath: "#/properties/username/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema71.properties.username.type,
                parentSchema: schema71.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate86.errors = [
                {
                  instancePath: instancePath + "/password",
                  schemaPath: "#/properties/password/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema71.properties.password.type,
                  parentSchema: schema71.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate86.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema71.type,
          parentSchema: schema71,
          data,
        },
      ];
      return false;
    }
  }
  validate86.errors = vErrors;
  return errors === 0;
}
export const validateGetIdentityResponse200Response = validate87;
const schema72 = {
  title: "User",
  type: "object",
  properties: {
    url: {type: "string", format: "uri", readOnly: true},
    id: {type: "string", readOnly: true},
    username: {type: "string"},
  },
  required: ["url", "id", "username"],
  "x-standalone": false,
  "x-name": "getIdentityResponse200Response",
  "x-location":
    "#/paths//identity/get/responses/200/content/application/json/schema_response",
  "x-schema-type": "response",
};
function validate87(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.id === undefined && (missing0 = "id")) ||
        (data.username === undefined && (missing0 = "username"))
      ) {
        validate87.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema72.required,
            parentSchema: schema72,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate87.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema72.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate87.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema72.properties.url.type,
                    parentSchema: schema72.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate87.errors = [
                {
                  instancePath: instancePath + "/id",
                  schemaPath: "#/properties/id/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema72.properties.id.type,
                  parentSchema: schema72.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== "string") {
                validate87.errors = [
                  {
                    instancePath: instancePath + "/username",
                    schemaPath: "#/properties/username/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema72.properties.username.type,
                    parentSchema: schema72.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate87.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema72.type,
          parentSchema: schema72,
          data,
        },
      ];
      return false;
    }
  }
  validate87.errors = vErrors;
  return errors === 0;
}
export const validatePatchIdentityRequestBodyRequest = validate88;
const schema73 = {
  title: "User Update",
  type: "object",
  properties: {password: {type: "string", writeOnly: true}},
  required: ["password"],
  "x-standalone": false,
  "x-name": "patchIdentityRequestBodyRequest",
  "x-location":
    "#/paths//identity/patch/requestBody/content/application/json/schema_request",
  "x-schema-type": "request",
};
function validate88(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.password === undefined && (missing0 = "password")) {
        validate88.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema73.required,
            parentSchema: schema73,
            data,
          },
        ];
        return false;
      } else {
        if (data.password !== undefined) {
          let data0 = data.password;
          if (typeof data0 !== "string") {
            validate88.errors = [
              {
                instancePath: instancePath + "/password",
                schemaPath: "#/properties/password/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema73.properties.password.type,
                parentSchema: schema73.properties.password,
                data: data0,
              },
            ];
            return false;
          }
        }
      }
    } else {
      validate88.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema73.type,
          parentSchema: schema73,
          data,
        },
      ];
      return false;
    }
  }
  validate88.errors = vErrors;
  return errors === 0;
}
export const validatePatchIdentityRequestBodyResponse = validate89;
const schema74 = {
  title: "User Update",
  type: "object",
  properties: {},
  required: [],
  "x-standalone": false,
  "x-name": "patchIdentityRequestBodyResponse",
  "x-location":
    "#/paths//identity/patch/requestBody/content/application/json/schema_response",
  "x-schema-type": "response",
};
function validate89(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (!(data && typeof data == "object" && !Array.isArray(data))) {
      validate89.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema74.type,
          parentSchema: schema74,
          data,
        },
      ];
      return false;
    }
  }
  validate89.errors = vErrors;
  return errors === 0;
}
export const validatePatchIdentityResponse200Request = validate90;
const schema75 = {
  title: "User",
  type: "object",
  properties: {username: {type: "string"}, password: {type: "string", writeOnly: true}},
  required: ["username", "password"],
  "x-standalone": false,
  "x-name": "patchIdentityResponse200Request",
  "x-location":
    "#/paths//identity/patch/responses/200/content/application/json/schema_request",
  "x-schema-type": "request",
};
function validate90(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.username === undefined && (missing0 = "username")) ||
        (data.password === undefined && (missing0 = "password"))
      ) {
        validate90.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema75.required,
            parentSchema: schema75,
            data,
          },
        ];
        return false;
      } else {
        if (data.username !== undefined) {
          let data0 = data.username;
          const _errs1 = errors;
          if (typeof data0 !== "string") {
            validate90.errors = [
              {
                instancePath: instancePath + "/username",
                schemaPath: "#/properties/username/type",
                keyword: "type",
                params: {type: "string"},
                message: "must be string",
                schema: schema75.properties.username.type,
                parentSchema: schema75.properties.username,
                data: data0,
              },
            ];
            return false;
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.password !== undefined) {
            let data1 = data.password;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate90.errors = [
                {
                  instancePath: instancePath + "/password",
                  schemaPath: "#/properties/password/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema75.properties.password.type,
                  parentSchema: schema75.properties.password,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate90.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema75.type,
          parentSchema: schema75,
          data,
        },
      ];
      return false;
    }
  }
  validate90.errors = vErrors;
  return errors === 0;
}
export const validatePatchIdentityResponse200Response = validate91;
const schema76 = {
  title: "User",
  type: "object",
  properties: {
    url: {type: "string", format: "uri", readOnly: true},
    id: {type: "string", readOnly: true},
    username: {type: "string"},
  },
  required: ["url", "id", "username"],
  "x-standalone": false,
  "x-name": "patchIdentityResponse200Response",
  "x-location":
    "#/paths//identity/patch/responses/200/content/application/json/schema_response",
  "x-schema-type": "response",
};
function validate91(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (
        (data.url === undefined && (missing0 = "url")) ||
        (data.id === undefined && (missing0 = "id")) ||
        (data.username === undefined && (missing0 = "username"))
      ) {
        validate91.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: {missingProperty: missing0},
            message: "must have required property '" + missing0 + "'",
            schema: schema76.required,
            parentSchema: schema76,
            data,
          },
        ];
        return false;
      } else {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0(data0)) {
                  validate91.errors = [
                    {
                      instancePath: instancePath + "/url",
                      schemaPath: "#/properties/url/format",
                      keyword: "format",
                      params: {format: "uri"},
                      message: 'must match format "' + "uri" + '"',
                      schema: "uri",
                      parentSchema: schema76.properties.url,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate91.errors = [
                  {
                    instancePath: instancePath + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema76.properties.url.type,
                    parentSchema: schema76.properties.url,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.id !== undefined) {
            let data1 = data.id;
            const _errs3 = errors;
            if (typeof data1 !== "string") {
              validate91.errors = [
                {
                  instancePath: instancePath + "/id",
                  schemaPath: "#/properties/id/type",
                  keyword: "type",
                  params: {type: "string"},
                  message: "must be string",
                  schema: schema76.properties.id.type,
                  parentSchema: schema76.properties.id,
                  data: data1,
                },
              ];
              return false;
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.username !== undefined) {
              let data2 = data.username;
              const _errs5 = errors;
              if (typeof data2 !== "string") {
                validate91.errors = [
                  {
                    instancePath: instancePath + "/username",
                    schemaPath: "#/properties/username/type",
                    keyword: "type",
                    params: {type: "string"},
                    message: "must be string",
                    schema: schema76.properties.username.type,
                    parentSchema: schema76.properties.username,
                    data: data2,
                  },
                ];
                return false;
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate91.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema76.type,
          parentSchema: schema76,
          data,
        },
      ];
      return false;
    }
  }
  validate91.errors = vErrors;
  return errors === 0;
}
export const validatePostTokenRequestBodyRequest = validate92;
const schema77 = {
  type: "object",
  properties: {
    username: {type: "string", description: "The username of the user."},
    claims: {
      type: "object",
      description:
        "The claims that will be added to the token. If left empty, the token will have the full scope of the user.\n",
    },
  },
  "x-standalone": false,
  "x-name": "postTokenRequestBodyRequest",
  "x-location": "#/paths//token/post/requestBody/content/application/json/schema_request",
  "x-schema-type": "request",
};
function validate92(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.username !== undefined) {
        let data0 = data.username;
        const _errs1 = errors;
        if (typeof data0 !== "string") {
          validate92.errors = [
            {
              instancePath: instancePath + "/username",
              schemaPath: "#/properties/username/type",
              keyword: "type",
              params: {type: "string"},
              message: "must be string",
              schema: schema77.properties.username.type,
              parentSchema: schema77.properties.username,
              data: data0,
            },
          ];
          return false;
        }
        var valid0 = _errs1 === errors;
      } else {
        var valid0 = true;
      }
      if (valid0) {
        if (data.claims !== undefined) {
          let data1 = data.claims;
          const _errs3 = errors;
          if (!(data1 && typeof data1 == "object" && !Array.isArray(data1))) {
            validate92.errors = [
              {
                instancePath: instancePath + "/claims",
                schemaPath: "#/properties/claims/type",
                keyword: "type",
                params: {type: "object"},
                message: "must be object",
                schema: schema77.properties.claims.type,
                parentSchema: schema77.properties.claims,
                data: data1,
              },
            ];
            return false;
          }
          var valid0 = _errs3 === errors;
        } else {
          var valid0 = true;
        }
      }
    } else {
      validate92.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema77.type,
          parentSchema: schema77,
          data,
        },
      ];
      return false;
    }
  }
  validate92.errors = vErrors;
  return errors === 0;
}
export const validatePostTokenRequestBodyResponse = validate93;
const schema78 = {
  type: "object",
  properties: {
    username: {type: "string", description: "The username of the user."},
    claims: {
      type: "object",
      description:
        "The claims that will be added to the token. If left empty, the token will have the full scope of the user.\n",
    },
  },
  "x-standalone": false,
  "x-name": "postTokenRequestBodyResponse",
  "x-location":
    "#/paths//token/post/requestBody/content/application/json/schema_response",
  "x-schema-type": "response",
};
function validate93(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.username !== undefined) {
        let data0 = data.username;
        const _errs1 = errors;
        if (typeof data0 !== "string") {
          validate93.errors = [
            {
              instancePath: instancePath + "/username",
              schemaPath: "#/properties/username/type",
              keyword: "type",
              params: {type: "string"},
              message: "must be string",
              schema: schema78.properties.username.type,
              parentSchema: schema78.properties.username,
              data: data0,
            },
          ];
          return false;
        }
        var valid0 = _errs1 === errors;
      } else {
        var valid0 = true;
      }
      if (valid0) {
        if (data.claims !== undefined) {
          let data1 = data.claims;
          const _errs3 = errors;
          if (!(data1 && typeof data1 == "object" && !Array.isArray(data1))) {
            validate93.errors = [
              {
                instancePath: instancePath + "/claims",
                schemaPath: "#/properties/claims/type",
                keyword: "type",
                params: {type: "object"},
                message: "must be object",
                schema: schema78.properties.claims.type,
                parentSchema: schema78.properties.claims,
                data: data1,
              },
            ];
            return false;
          }
          var valid0 = _errs3 === errors;
        } else {
          var valid0 = true;
        }
      }
    } else {
      validate93.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: {type: "object"},
          message: "must be object",
          schema: schema78.type,
          parentSchema: schema78,
          data,
        },
      ];
      return false;
    }
  }
  validate93.errors = vErrors;
  return errors === 0;
}
export const validatePostTokenResponse201Request = validate94;
const schema79 = {
  type: "string",
  "x-standalone": false,
  "x-name": "postTokenResponse201Request",
  "x-location":
    "#/paths//token/post/responses/201/content/application/json/schema_request",
  "x-schema-type": "request",
};
function validate94(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate94.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema79.type,
        parentSchema: schema79,
        data,
      },
    ];
    return false;
  }
  validate94.errors = vErrors;
  return errors === 0;
}
export const validatePostTokenResponse201Response = validate95;
const schema80 = {
  type: "string",
  "x-standalone": false,
  "x-name": "postTokenResponse201Response",
  "x-location":
    "#/paths//token/post/responses/201/content/application/json/schema_response",
  "x-schema-type": "response",
};
function validate95(
  data,
  {instancePath = "", parentData, parentDataProperty, rootData = data} = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== "string") {
    validate95.errors = [
      {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {type: "string"},
        message: "must be string",
        schema: schema80.type,
        parentSchema: schema80,
        data,
      },
    ];
    return false;
  }
  validate95.errors = vErrors;
  return errors === 0;
}
