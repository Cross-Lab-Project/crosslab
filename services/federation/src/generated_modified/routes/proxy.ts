// tslint:disable
// @ts-nocheck
/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */
import express from "express"
import { checkJWT } from "../../security"
import * as proxy from "../../services/proxy"
import {} from "../types"
import {
    validateInputGetProxy,
    validateInputPostProxy,
    validateInputPatchProxy,
    validateInputDeleteProxy,
    validateInputOptionsProxy,
    validateInputHeadProxy,
    validateInputTraceProxy,
    validateInputPutProxy,
} from "../validation/proxy"

export const router = express.Router()
router.get("/", async (req, res) => {
    if (!checkJWT(req)) {
        return res.status(401).send()
    }
    const parameters: {
        URL: string
    } = {
        URL: req.query["URL"],
    }
    const body = {}
    if (!validateInputGetProxy(parameters)) {
        return res.status(400).send()
    }
    try {
        const user = { username: "testUser" }
        const result = await proxy.getProxy(parameters, body, user)
        return res.status(result.status || 200).send(result.data)
    } catch (err) {
        return res.status(500).send({
            status: 500,
            error: "Server Error",
        })
    }
})

router.post("/", async (req, res) => {
    if (!checkJWT(req)) {
        return res.status(401).send()
    }
    const parameters: {
        URL: string
    } = {
        URL: req.query["URL"],
    }
    const body = {}
    if (!validateInputPostProxy(parameters)) {
        return res.status(400).send()
    }
    try {
        const user = { username: "testUser" }
        const result = await proxy.postProxy(parameters, body, user)
        return res.status(result.status || 200).send(result.data)
    } catch (err) {
        return res.status(500).send({
            status: 500,
            error: "Server Error",
        })
    }
})

router.patch("/", async (req, res) => {
    if (!checkJWT(req)) {
        return res.status(401).send()
    }
    const parameters: {
        URL: string
    } = {
        URL: req.query["URL"],
    }
    const body = {}
    if (!validateInputPatchProxy(parameters)) {
        return res.status(400).send()
    }
    try {
        const user = { username: "testUser" }
        const result = await proxy.patchProxy(parameters, body, user)
        return res.status(result.status || 200).send(result.data)
    } catch (err) {
        return res.status(500).send({
            status: 500,
            error: "Server Error",
        })
    }
})

router.delete("/", async (req, res) => {
    if (!checkJWT(req)) {
        return res.status(401).send()
    }
    const parameters: {
        URL: string
    } = {
        URL: req.query["URL"],
    }
    const body = {}
    if (!validateInputDeleteProxy(parameters)) {
        return res.status(400).send()
    }
    try {
        const user = { username: "testUser" }
        const result = await proxy.deleteProxy(parameters, body, user)
        return res.status(result.status || 200).send(result.data)
    } catch (err) {
        return res.status(500).send({
            status: 500,
            error: "Server Error",
        })
    }
})

router.options("/", async (req, res) => {
    if (!checkJWT(req)) {
        return res.status(401).send()
    }
    const parameters: {
        URL: string
    } = {
        URL: req.query["URL"],
    }
    const body = {}
    if (!validateInputOptionsProxy(parameters)) {
        return res.status(400).send()
    }
    try {
        const user = { username: "testUser" }
        const result = await proxy.optionsProxy(parameters, body, user)
        return res.status(result.status || 200).send(result.data)
    } catch (err) {
        return res.status(500).send({
            status: 500,
            error: "Server Error",
        })
    }
})

router.head("/", async (req, res) => {
    if (!checkJWT(req)) {
        return res.status(401).send()
    }
    const parameters: {
        URL: string
    } = {
        URL: req.query["URL"],
    }
    const body = {}
    if (!validateInputHeadProxy(parameters)) {
        return res.status(400).send()
    }
    try {
        const user = { username: "testUser" }
        const result = await proxy.headProxy(parameters, body, user)
        return res.status(result.status || 200).send(result.data)
    } catch (err) {
        return res.status(500).send({
            status: 500,
            error: "Server Error",
        })
    }
})

router.trace("/", async (req, res) => {
    if (!checkJWT(req)) {
        return res.status(401).send()
    }
    const parameters: {
        URL: string
    } = {
        URL: req.query["URL"],
    }
    const body = {}
    if (!validateInputTraceProxy(parameters)) {
        return res.status(400).send()
    }
    try {
        const user = { username: "testUser" }
        const result = await proxy.traceProxy(parameters, body, user)
        return res.status(result.status || 200).send(result.data)
    } catch (err) {
        return res.status(500).send({
            status: 500,
            error: "Server Error",
        })
    }
})

router.put("/", async (req, res) => {
    if (!checkJWT(req)) {
        return res.status(401).send()
    }
    const parameters: {
        URL: string
    } = {
        URL: req.query["URL"],
    }
    const body = {}
    if (!validateInputPutProxy(parameters)) {
        return res.status(400).send()
    }
    try {
        const user = { username: "testUser" }
        const result = await proxy.putProxy(parameters, body, user)
        return res.status(result.status || 200).send(result.data)
    } catch (err) {
        return res.status(500).send({
            status: 500,
            error: "Server Error",
        })
    }
})
