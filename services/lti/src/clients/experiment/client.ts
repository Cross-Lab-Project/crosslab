


    

    

    



    

    

    


/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */

/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-ts-comment */

import fetch, { RequestInfo, RequestInit, Response } from "node-fetch";

import * as RequestValidation from './requestValidation.js';
import * as Signatures from './signatures.js';
import * as Types from './types.js';
// @ts-ignore
import { type Require } from "./types.js"

/**
 * This error class should be used if an error occurs during validation of a request/response.
 * @category Errors
 */
export class ValidationError extends Error {
    public errors: unknown

    constructor(message: string, errors: unknown) {
        super(message)
        this.name = "ValidationError"
        this.errors = errors
    }
}

/**
 * This error class should be used if an error occurs while fetching a request.
 * @category Errors
 */
export class FetchError extends Error {
    constructor(message: string) {
        super(message)
        this.name = "FetchError"
    }
}

/**
 * This error class should be used if the response of the server has a status 
 * greater than or equal to 400. This error should contain the validated response.
 * @category Errors
 */
export class UnsuccessfulRequestError extends Error {
    public response: Types.ResponseData

    constructor(message: string, response: Types.ResponseData) {
        super(message)
        this.response = response
        this.name = 'UnsuccessfulRequestError'
    }
}

/**
 * This error class should be used if the validation of an url fails.
 * @category Errors
 */
export class InvalidUrlError extends Error {
    constructor(message: string) {
        super(message)
        this.name = 'InvalidUrlError'
    }
}

/**
 * This function attempts to parse a Response as ResponseData.
 */
async function parseResponse(response: Response): Promise<Types.ResponseData> {
    let text = null
    try {
        text = await response.text()
        const json = JSON.parse(text)
        return { status: response.status, body: json }
    } catch {
        return { status: response.status, body: text }
    }
}

/**
 * This function checks if a string is a valid http url.
 * @param string The string to be checked.
 * @returns True if the string is a valid http url.
 */
function isValidHttpUrl(string: string) {
    let url

    try {
        url = new URL(string)
    } catch (_) {
        return false
    }

    return url.protocol === 'http:' || url.protocol === 'https:'
}

/**
 * This function takes an url and a pattern for the requested endpoint and parses the contained path parameters.
 * @param url The url to be parsed.
 * @param endpoint Pattern of the requested endpoint.
 * @throws {InvalidUrlError} Thrown if the provided url does not end with the provided endpoint.
 * @returns An array containing all parsed path parameters in order of appearance.
 * @example
 * // returns ["username", "role_name"]
 * parsePathParameters("https://api.example.com/users/username/roles/role_name", "/users/{}/roles/{}")
 */
function parsePathParameters(url: string, endpoint: string): string[] {
    const parameterRegex = '([^\/]+)'
    const regex = new RegExp(
        endpoint.replaceAll('{}', parameterRegex) + '(?:.(?!\\\\))?$'
    )
    const matches = url.match(regex)

    if (!matches) throw new InvalidUrlError('Url does not end with the provided endpoint')

    return matches.slice(1)
}

/**
 * This function validates a given http url and parses its path parameters.
 * @param url The url to be validated.
 * @param endpoint Pattern of the requested endpoint.
 * @throws {InvalidUrlError} Thrown if the validation of the provided url fails.
 * @returns An array containing all parsed path parameters in order of appearance (see {@link parsePathParameters}).
 * @example
 * // returns ["username", "role_name"]
 * validateUrl("https://api.example.com/users/username/roles/role_name", "/users/{}/roles/{}")
 */
function validateUrl(url: string, endpoint: string): string[] {
    if (!isValidHttpUrl(url)) throw new InvalidUrlError('Provided url is not a valid http url')
    return parsePathParameters(url, endpoint)
}

/**
 * This function appends a given endpoint to an url.
 * @param url The url to append the endpoint to.
 * @param endpoint The endpoint to be appended.
 * @example
 * // returns "https://api.example.com/devices/device_id/token"
 * appendToUrl("https://api.example.com/devices/device_id", "/token")
 * @example
 * // returns "https://api.example.com/devices/device_id/token"
 * appendToUrl("https://api.example.com/devices/device_id/", "/token")
 * @returns The url with the appended endpoint.
 */
function appendToUrl(url: string, endpoint: string) {
    return url.endsWith('/') ? `${url.slice(0, -1)}${endpoint}` : `${url}${endpoint}`
}

/**
 * Client for the use of the Crosslab API
 * @category Client
 */
export class Client {
    public readonly baseUrl: string;
    public readonly serviceUrl: string;
    public accessToken: string;
    private fixedHeaders: [string, string][]
    private fetch = async (url: RequestInfo | URL, init: RequestInit) => {
        let raw_response;
        const parsedUrl = new URL(url.toString())
        try {
            if (
                parsedUrl.toString().startsWith(this.baseUrl) ||
                parsedUrl.toString().startsWith(this.serviceUrl)
            ) {
                raw_response = await fetch(url, init);
            } else {
                raw_response = await fetch(
                appendToUrl(
                    this.baseUrl,
                    '/proxy?' + new URLSearchParams([['URL', url.toString()]]).toString(),
                ),
                init,
                );
            }
        } catch (error) {
            if (error instanceof Error) {
                throw new FetchError(error.message);
            } else if (typeof error === 'string') {
                throw new FetchError(error);
            } else {
                throw new FetchError('Something went wrong while trying to fetch the request');
            }
        }
        return await parseResponse(raw_response);
    };

    /**
     * @category Constructors
     */
    constructor(
        baseUrl: string,
        options: { serviceUrl?: string; accessToken?: string, fixedHeaders?: [string, string][] },
    ) {
        this.baseUrl = new URL(baseUrl).toString().slice(0, -1);
        this.serviceUrl = new URL(options.serviceUrl ?? this.baseUrl).toString().slice(0, -1);
        this.accessToken = options.accessToken ?? '';
        this.fixedHeaders = options.fixedHeaders ?? [];
    }

    /**
     * List experiments 
	 * 
	 * @param options.experimentStatus
	 * Only retrieve experiments with this status.
	 * @param options.url
	 * Url of the  to be used.
     *
     * @throws {@link FetchError | FetchError } 
     * Thrown if fetch fails.
     * @throws {@link ValidationError | ValidationError } 
     * Thrown if the request/response validation fails.
     * @throws {@link InvalidUrlError | InvalidUrlError } 
     * Thrown if the provided url is not valid for this request.
     * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError } 
     * Thrown if response is validated but has status greater than or equal to 400.
     * 
     * @returns
	 * The list of all experiments.
     */
    public async listExperiments(
            options?: {
                headers?: [string, string][],experimentStatus?: string,url?: string}): Promise<Signatures.ListExperimentsSuccessResponse["body"]> {
            const url = appendToUrl(options?.url ?? this.baseUrl, "/experiments")
        console.log("trying to fetch url:", url);

        

        
        const parameters = {
            experimentStatus: options?.experimentStatus,
        }

            const query: [string,string][] = []
            
                if (parameters["experimentStatus"]) 
                    query.push(["experimentStatus", parameters["experimentStatus"].toString()])

        if (!RequestValidation.validateListExperimentsInput(parameters))
            throw new ValidationError(
                'Request validation failed!', 
                (RequestValidation.validateListExperimentsInput as Types.FunctionWithErrors).errors
            )

        const authorization: string = `Bearer ${this.accessToken}`

        console.log("trying to fetch url:", new URL(url).toString().replace(this.baseUrl, this.serviceUrl) + '?' + new URLSearchParams(query));
        const response = await this.fetch(new URL(url).toString().replace(this.baseUrl, this.serviceUrl) + '?' + new URLSearchParams(query), {
            method: "GET", 
            headers: [
                ["Content-Type", "application/json"],
                ["Authorization", authorization],
                ...this.fixedHeaders,
                ...(options?.headers ?? [])
            ]
        })

        if (!RequestValidation.validateListExperimentsOutput(response))
            throw new ValidationError(
                'Response validation failed!', 
                (RequestValidation.validateListExperimentsOutput as Types.FunctionWithErrors).errors
            )

        if (Types.isErrorResponse(response)) 
            throw new UnsuccessfulRequestError(
                `Server returned response with status ${response.status}`, 
                response
            )
        
        

            return response.body
    }

    /**
     * Create a new experiment 
	 * 
	 * @param experiment
	 * The experiment to be created.
	 * @param options.changedURL
	 * An URL that will be called when the experiment status changes.
	 * @param options.url
	 * Url of the  to be used.
     *
     * @throws {@link FetchError | FetchError } 
     * Thrown if fetch fails.
     * @throws {@link ValidationError | ValidationError } 
     * Thrown if the request/response validation fails.
     * @throws {@link InvalidUrlError | InvalidUrlError } 
     * Thrown if the provided url is not valid for this request.
     * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError } 
     * Thrown if response is validated but has status greater than or equal to 400.
     * 
     * @returns
	 * 201: The experiment was created. A JSON representation of the new experiment is returned.
	 * 202: The experiment was created and will be set to running eventually. A JSON representation of the new experiment is returned.
     */
    public async createExperiment(experiment: Types.Experiment<"request">,
            options?: {
                headers?: [string, string][],changedURL?: string,url?: string}): Promise<Signatures.CreateExperimentSuccessResponse["body"]> {
            const url = appendToUrl(options?.url ?? this.baseUrl, "/experiments")
        console.log("trying to fetch url:", url);

        const body = experiment

        
        const parameters = {
            changedURL: options?.changedURL,
        }

            const query: [string,string][] = []
            
                if (parameters["changedURL"]) 
                    query.push(["changedURL", parameters["changedURL"].toString()])

        if (!RequestValidation.validateCreateExperimentInput(parameters, body))
            throw new ValidationError(
                'Request validation failed!', 
                (RequestValidation.validateCreateExperimentInput as Types.FunctionWithErrors).errors
            )

        const authorization: string = `Bearer ${this.accessToken}`

        console.log("trying to fetch url:", new URL(url).toString().replace(this.baseUrl, this.serviceUrl) + '?' + new URLSearchParams(query));
        const response = await this.fetch(new URL(url).toString().replace(this.baseUrl, this.serviceUrl) + '?' + new URLSearchParams(query), {
            method: "POST", 
            headers: [
                ["Content-Type", "application/json"],
                ["Authorization", authorization],
                ...this.fixedHeaders,
                ...(options?.headers ?? [])
            ], 
            body: JSON.stringify(body)
        })

        if (!RequestValidation.validateCreateExperimentOutput(response))
            throw new ValidationError(
                'Response validation failed!', 
                (RequestValidation.validateCreateExperimentOutput as Types.FunctionWithErrors).errors
            )

        if (Types.isErrorResponse(response)) 
            throw new UnsuccessfulRequestError(
                `Server returned response with status ${response.status}`, 
                response
            )
        
        

            return response.body
    }

    /**
     * View an experiment. 
	 * 
	 * @param url
	 * Url of the resource to be accessed.
     *
     * @throws {@link FetchError | FetchError } 
     * Thrown if fetch fails.
     * @throws {@link ValidationError | ValidationError } 
     * Thrown if the request/response validation fails.
     * @throws {@link InvalidUrlError | InvalidUrlError } 
     * Thrown if the provided url is not valid for this request.
     * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError } 
     * Thrown if response is validated but has status greater than or equal to 400.
     * 
     * @returns
	 * The JSON Representation of the experiment
     */
    public async getExperiment(url: string,
            options?: {
                headers?: [string, string][],}): Promise<Signatures.GetExperimentSuccessResponse["body"]> {
                const urlSuffix = '/experiments/{}'.split('{}').at(-1) ?? ''
                if (urlSuffix && !url.endsWith(urlSuffix)) url = appendToUrl(url, urlSuffix)
                const [experiment_id,] = validateUrl(new URL(url).toString(), '/experiments/{}')
        console.log("trying to fetch url:", url);

        

        
        const parameters = {
            experiment_id: experiment_id,
        }

        if (!RequestValidation.validateGetExperimentInput(parameters))
            throw new ValidationError(
                'Request validation failed!', 
                (RequestValidation.validateGetExperimentInput as Types.FunctionWithErrors).errors
            )

        const authorization: string = `Bearer ${this.accessToken}`

        console.log("trying to fetch url:", new URL(url).toString().replace(this.baseUrl, this.serviceUrl) );
        const response = await this.fetch(new URL(url).toString().replace(this.baseUrl, this.serviceUrl) , {
            method: "GET", 
            headers: [
                ["Content-Type", "application/json"],
                ["Authorization", authorization],
                ...this.fixedHeaders,
                ...(options?.headers ?? [])
            ]
        })

        if (!RequestValidation.validateGetExperimentOutput(response))
            throw new ValidationError(
                'Response validation failed!', 
                (RequestValidation.validateGetExperimentOutput as Types.FunctionWithErrors).errors
            )

        if (Types.isErrorResponse(response)) 
            throw new UnsuccessfulRequestError(
                `Server returned response with status ${response.status}`, 
                response
            )
        
        

            return response.body
    }

    /**
     * Update an existing experiment. 
	 * 
	 * @param url
	 * Url of the resource to be accessed.
	 * @param experimentUpdate
	 * Update the experiment
	 * @param options.changedURL
	 * An URL that will be called when the experiment status changes.
     *
     * @throws {@link FetchError | FetchError } 
     * Thrown if fetch fails.
     * @throws {@link ValidationError | ValidationError } 
     * Thrown if the request/response validation fails.
     * @throws {@link InvalidUrlError | InvalidUrlError } 
     * Thrown if the provided url is not valid for this request.
     * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError } 
     * Thrown if response is validated but has status greater than or equal to 400.
     * 
     * @returns
	 * 200: The JSON Representation of the changed experiment
	 * 202: The JSON Representation of the changed experiment, that will be set to running eventually
     */
    public async updateExperiment(url: string,experimentUpdate: Types.ExperimentUpdate<"request"> | undefined,
            options?: {
                headers?: [string, string][],changedURL?: string,}): Promise<Signatures.UpdateExperimentSuccessResponse["body"]> {
                const urlSuffix = '/experiments/{}'.split('{}').at(-1) ?? ''
                if (urlSuffix && !url.endsWith(urlSuffix)) url = appendToUrl(url, urlSuffix)
                const [experiment_id,] = validateUrl(new URL(url).toString(), '/experiments/{}')
        console.log("trying to fetch url:", url);

        const body = experimentUpdate

        
        const parameters = {
            experiment_id: experiment_id,
            changedURL: options?.changedURL,
        }

            const query: [string,string][] = []
            
                if (parameters["changedURL"]) 
                    query.push(["changedURL", parameters["changedURL"].toString()])

        if (!RequestValidation.validateUpdateExperimentInput(parameters, body))
            throw new ValidationError(
                'Request validation failed!', 
                (RequestValidation.validateUpdateExperimentInput as Types.FunctionWithErrors).errors
            )

        const authorization: string = `Bearer ${this.accessToken}`

        console.log("trying to fetch url:", new URL(url).toString().replace(this.baseUrl, this.serviceUrl) + '?' + new URLSearchParams(query));
        const response = await this.fetch(new URL(url).toString().replace(this.baseUrl, this.serviceUrl) + '?' + new URLSearchParams(query), {
            method: "PATCH", 
            headers: [
                ["Content-Type", "application/json"],
                ["Authorization", authorization],
                ...this.fixedHeaders,
                ...(options?.headers ?? [])
            ], 
            body: JSON.stringify(body)
        })

        if (!RequestValidation.validateUpdateExperimentOutput(response))
            throw new ValidationError(
                'Response validation failed!', 
                (RequestValidation.validateUpdateExperimentOutput as Types.FunctionWithErrors).errors
            )

        if (Types.isErrorResponse(response)) 
            throw new UnsuccessfulRequestError(
                `Server returned response with status ${response.status}`, 
                response
            )
        
        

            return response.body
    }

    /**
     * Delete an experiment 
	 * 
	 * @param url
	 * Url of the resource to be accessed.
     *
     * @throws {@link FetchError | FetchError } 
     * Thrown if fetch fails.
     * @throws {@link ValidationError | ValidationError } 
     * Thrown if the request/response validation fails.
     * @throws {@link InvalidUrlError | InvalidUrlError } 
     * Thrown if the provided url is not valid for this request.
     * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError } 
     * Thrown if response is validated but has status greater than or equal to 400.
     * 
     * @returns
	 * The experiment was deleted.
     */
    public async deleteExperiment(url: string,
            options?: {
                headers?: [string, string][],}): Promise<void> {
                const urlSuffix = '/experiments/{}'.split('{}').at(-1) ?? ''
                if (urlSuffix && !url.endsWith(urlSuffix)) url = appendToUrl(url, urlSuffix)
                const [experiment_id,] = validateUrl(new URL(url).toString(), '/experiments/{}')
        console.log("trying to fetch url:", url);

        

        
        const parameters = {
            experiment_id: experiment_id,
        }

        if (!RequestValidation.validateDeleteExperimentInput(parameters))
            throw new ValidationError(
                'Request validation failed!', 
                (RequestValidation.validateDeleteExperimentInput as Types.FunctionWithErrors).errors
            )

        const authorization: string = `Bearer ${this.accessToken}`

        console.log("trying to fetch url:", new URL(url).toString().replace(this.baseUrl, this.serviceUrl) );
        const response = await this.fetch(new URL(url).toString().replace(this.baseUrl, this.serviceUrl) , {
            method: "DELETE", 
            headers: [
                ["Content-Type", "application/json"],
                ["Authorization", authorization],
                ...this.fixedHeaders,
                ...(options?.headers ?? [])
            ]
        })

        if (!RequestValidation.validateDeleteExperimentOutput(response))
            throw new ValidationError(
                'Response validation failed!', 
                (RequestValidation.validateDeleteExperimentOutput as Types.FunctionWithErrors).errors
            )

        if (Types.isErrorResponse(response)) 
            throw new UnsuccessfulRequestError(
                `Server returned response with status ${response.status}`, 
                response
            )
        
        
    }

    /**
     * List templates 
	 * 
	 * @param options.url
	 * Url of the  to be used.
     *
     * @throws {@link FetchError | FetchError } 
     * Thrown if fetch fails.
     * @throws {@link ValidationError | ValidationError } 
     * Thrown if the request/response validation fails.
     * @throws {@link InvalidUrlError | InvalidUrlError } 
     * Thrown if the provided url is not valid for this request.
     * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError } 
     * Thrown if response is validated but has status greater than or equal to 400.
     * 
     * @returns
	 * The list of all templates.
     */
    public async listTemplate(
            options?: {
                headers?: [string, string][],url?: string}): Promise<Signatures.ListTemplateSuccessResponse["body"]> {
            const url = appendToUrl(options?.url ?? this.baseUrl, "/templates")
        console.log("trying to fetch url:", url);

        

        

        if (!RequestValidation.validateListTemplateInput())
            throw new ValidationError(
                'Request validation failed!', 
                (RequestValidation.validateListTemplateInput as Types.FunctionWithErrors).errors
            )

        const authorization: string = `Bearer ${this.accessToken}`

        console.log("trying to fetch url:", new URL(url).toString().replace(this.baseUrl, this.serviceUrl) );
        const response = await this.fetch(new URL(url).toString().replace(this.baseUrl, this.serviceUrl) , {
            method: "GET", 
            headers: [
                ["Content-Type", "application/json"],
                ["Authorization", authorization],
                ...this.fixedHeaders,
                ...(options?.headers ?? [])
            ]
        })

        if (!RequestValidation.validateListTemplateOutput(response))
            throw new ValidationError(
                'Response validation failed!', 
                (RequestValidation.validateListTemplateOutput as Types.FunctionWithErrors).errors
            )

        if (Types.isErrorResponse(response)) 
            throw new UnsuccessfulRequestError(
                `Server returned response with status ${response.status}`, 
                response
            )
        
        

            return response.body
    }

    /**
     * Create a new template 
	 * 
	 * @param template
	 * The template to be created.
	 * @param options.url
	 * Url of the  to be used.
     *
     * @throws {@link FetchError | FetchError } 
     * Thrown if fetch fails.
     * @throws {@link ValidationError | ValidationError } 
     * Thrown if the request/response validation fails.
     * @throws {@link InvalidUrlError | InvalidUrlError } 
     * Thrown if the provided url is not valid for this request.
     * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError } 
     * Thrown if response is validated but has status greater than or equal to 400.
     * 
     * @returns
	 * 201: The template was created. A JSON representation of the new template is returned.
	 * 202: The template was created and will be set to running eventually. A JSON representation of the new template is returned.
     */
    public async createTemplate(template: Types.Template<"request">,
            options?: {
                headers?: [string, string][],url?: string}): Promise<Signatures.CreateTemplateSuccessResponse["body"]> {
            const url = appendToUrl(options?.url ?? this.baseUrl, "/templates")
        console.log("trying to fetch url:", url);

        const body = template

        

        if (!RequestValidation.validateCreateTemplateInput(body))
            throw new ValidationError(
                'Request validation failed!', 
                (RequestValidation.validateCreateTemplateInput as Types.FunctionWithErrors).errors
            )

        const authorization: string = `Bearer ${this.accessToken}`

        console.log("trying to fetch url:", new URL(url).toString().replace(this.baseUrl, this.serviceUrl) );
        const response = await this.fetch(new URL(url).toString().replace(this.baseUrl, this.serviceUrl) , {
            method: "POST", 
            headers: [
                ["Content-Type", "application/json"],
                ["Authorization", authorization],
                ...this.fixedHeaders,
                ...(options?.headers ?? [])
            ], 
            body: JSON.stringify(body)
        })

        if (!RequestValidation.validateCreateTemplateOutput(response))
            throw new ValidationError(
                'Response validation failed!', 
                (RequestValidation.validateCreateTemplateOutput as Types.FunctionWithErrors).errors
            )

        if (Types.isErrorResponse(response)) 
            throw new UnsuccessfulRequestError(
                `Server returned response with status ${response.status}`, 
                response
            )
        
        

            return response.body
    }

    /**
     * View an template. 
	 * 
	 * @param url
	 * Url of the resource to be accessed.
     *
     * @throws {@link FetchError | FetchError } 
     * Thrown if fetch fails.
     * @throws {@link ValidationError | ValidationError } 
     * Thrown if the request/response validation fails.
     * @throws {@link InvalidUrlError | InvalidUrlError } 
     * Thrown if the provided url is not valid for this request.
     * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError } 
     * Thrown if response is validated but has status greater than or equal to 400.
     * 
     * @returns
	 * The JSON Representation of the template
     */
    public async getTemplate(url: string,
            options?: {
                headers?: [string, string][],}): Promise<Signatures.GetTemplateSuccessResponse["body"]> {
                const urlSuffix = '/templates/{}'.split('{}').at(-1) ?? ''
                if (urlSuffix && !url.endsWith(urlSuffix)) url = appendToUrl(url, urlSuffix)
                const [template_id,] = validateUrl(new URL(url).toString(), '/templates/{}')
        console.log("trying to fetch url:", url);

        

        
        const parameters = {
            template_id: template_id,
        }

        if (!RequestValidation.validateGetTemplateInput(parameters))
            throw new ValidationError(
                'Request validation failed!', 
                (RequestValidation.validateGetTemplateInput as Types.FunctionWithErrors).errors
            )

        const authorization: string = `Bearer ${this.accessToken}`

        console.log("trying to fetch url:", new URL(url).toString().replace(this.baseUrl, this.serviceUrl) );
        const response = await this.fetch(new URL(url).toString().replace(this.baseUrl, this.serviceUrl) , {
            method: "GET", 
            headers: [
                ["Content-Type", "application/json"],
                ["Authorization", authorization],
                ...this.fixedHeaders,
                ...(options?.headers ?? [])
            ]
        })

        if (!RequestValidation.validateGetTemplateOutput(response))
            throw new ValidationError(
                'Response validation failed!', 
                (RequestValidation.validateGetTemplateOutput as Types.FunctionWithErrors).errors
            )

        if (Types.isErrorResponse(response)) 
            throw new UnsuccessfulRequestError(
                `Server returned response with status ${response.status}`, 
                response
            )
        
        

            return response.body
    }

    /**
     * Update an existing template. 
	 * 
	 * @param url
	 * Url of the resource to be accessed.
	 * @param templateUpdate
	 * Update the template
     *
     * @throws {@link FetchError | FetchError } 
     * Thrown if fetch fails.
     * @throws {@link ValidationError | ValidationError } 
     * Thrown if the request/response validation fails.
     * @throws {@link InvalidUrlError | InvalidUrlError } 
     * Thrown if the provided url is not valid for this request.
     * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError } 
     * Thrown if response is validated but has status greater than or equal to 400.
     * 
     * @returns
	 * 200: The JSON Representation of the changed template
	 * 202: The JSON Representation of the changed template, that will be set to running eventually
     */
    public async updateTemplate(url: string,templateUpdate: Types.TemplateUpdate<"request">,
            options?: {
                headers?: [string, string][],}): Promise<Signatures.UpdateTemplateSuccessResponse["body"]> {
                const urlSuffix = '/templates/{}'.split('{}').at(-1) ?? ''
                if (urlSuffix && !url.endsWith(urlSuffix)) url = appendToUrl(url, urlSuffix)
                const [template_id,] = validateUrl(new URL(url).toString(), '/templates/{}')
        console.log("trying to fetch url:", url);

        const body = templateUpdate

        
        const parameters = {
            template_id: template_id,
        }

        if (!RequestValidation.validateUpdateTemplateInput(parameters, body))
            throw new ValidationError(
                'Request validation failed!', 
                (RequestValidation.validateUpdateTemplateInput as Types.FunctionWithErrors).errors
            )

        const authorization: string = `Bearer ${this.accessToken}`

        console.log("trying to fetch url:", new URL(url).toString().replace(this.baseUrl, this.serviceUrl) );
        const response = await this.fetch(new URL(url).toString().replace(this.baseUrl, this.serviceUrl) , {
            method: "PATCH", 
            headers: [
                ["Content-Type", "application/json"],
                ["Authorization", authorization],
                ...this.fixedHeaders,
                ...(options?.headers ?? [])
            ], 
            body: JSON.stringify(body)
        })

        if (!RequestValidation.validateUpdateTemplateOutput(response))
            throw new ValidationError(
                'Response validation failed!', 
                (RequestValidation.validateUpdateTemplateOutput as Types.FunctionWithErrors).errors
            )

        if (Types.isErrorResponse(response)) 
            throw new UnsuccessfulRequestError(
                `Server returned response with status ${response.status}`, 
                response
            )
        
        

            return response.body
    }

    /**
     * Delete an template 
	 * 
	 * @param url
	 * Url of the resource to be accessed.
     *
     * @throws {@link FetchError | FetchError } 
     * Thrown if fetch fails.
     * @throws {@link ValidationError | ValidationError } 
     * Thrown if the request/response validation fails.
     * @throws {@link InvalidUrlError | InvalidUrlError } 
     * Thrown if the provided url is not valid for this request.
     * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError } 
     * Thrown if response is validated but has status greater than or equal to 400.
     * 
     * @returns
	 * The template was deleted.
     */
    public async deleteTemplate(url: string,
            options?: {
                headers?: [string, string][],}): Promise<void> {
                const urlSuffix = '/templates/{}'.split('{}').at(-1) ?? ''
                if (urlSuffix && !url.endsWith(urlSuffix)) url = appendToUrl(url, urlSuffix)
                const [template_id,] = validateUrl(new URL(url).toString(), '/templates/{}')
        console.log("trying to fetch url:", url);

        

        
        const parameters = {
            template_id: template_id,
        }

        if (!RequestValidation.validateDeleteTemplateInput(parameters))
            throw new ValidationError(
                'Request validation failed!', 
                (RequestValidation.validateDeleteTemplateInput as Types.FunctionWithErrors).errors
            )

        const authorization: string = `Bearer ${this.accessToken}`

        console.log("trying to fetch url:", new URL(url).toString().replace(this.baseUrl, this.serviceUrl) );
        const response = await this.fetch(new URL(url).toString().replace(this.baseUrl, this.serviceUrl) , {
            method: "DELETE", 
            headers: [
                ["Content-Type", "application/json"],
                ["Authorization", authorization],
                ...this.fixedHeaders,
                ...(options?.headers ?? [])
            ]
        })

        if (!RequestValidation.validateDeleteTemplateOutput(response))
            throw new ValidationError(
                'Response validation failed!', 
                (RequestValidation.validateDeleteTemplateOutput as Types.FunctionWithErrors).errors
            )

        if (Types.isErrorResponse(response)) 
            throw new UnsuccessfulRequestError(
                `Server returned response with status ${response.status}`, 
                response
            )
        
        
    }

    
}