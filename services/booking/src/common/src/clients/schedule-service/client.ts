/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */

/* eslint-disable @typescript-eslint/no-unused-vars */

/* eslint-disable @typescript-eslint/ban-ts-comment */
import fetch, { RequestInfo, RequestInit, Response } from 'node-fetch';

import * as RequestValidation from './requestValidation.js';
import * as Signatures from './signatures.js';
import * as Types from './types.js';
// @ts-ignore
import { type Require } from './types.js';

/**
 * This error class should be used if an error occurs during validation of a request/response.
 * @category Errors
 */
export class ValidationError extends Error {
  public errors: unknown;

  constructor(message: string, errors: unknown) {
    super(message);
    this.name = 'ValidationError';
    this.errors = errors;
  }
}

/**
 * This error class should be used if an error occurs while fetching a request.
 * @category Errors
 */
export class FetchError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'FetchError';
  }
}

/**
 * This error class should be used if the response of the server has a status
 * greater than or equal to 400. This error should contain the validated response.
 * @category Errors
 */
export class UnsuccessfulRequestError extends Error {
  public response: Types.ResponseData;

  constructor(message: string, response: Types.ResponseData) {
    super(message);
    this.response = response;
    this.name = 'UnsuccessfulRequestError';
  }
}

/**
 * This error class should be used if the validation of an url fails.
 * @category Errors
 */
export class InvalidUrlError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InvalidUrlError';
  }
}

/**
 * This function attempts to parse a Response as ResponseData.
 */
async function parseResponse(response: Response): Promise<Types.ResponseData> {
  let text = null;
  try {
    text = await response.text();
    const json = JSON.parse(text);
    return { status: response.status, body: json };
  } catch {
    return { status: response.status, body: text };
  }
}

/**
 * This function checks if a string is a valid http url.
 * @param string The string to be checked.
 * @returns True if the string is a valid http url.
 */
function isValidHttpUrl(string: string) {
  let url;

  try {
    url = new URL(string);
  } catch (_) {
    return false;
  }

  return url.protocol === 'http:' || url.protocol === 'https:';
}

/**
 * This function takes an url and a pattern for the requested endpoint and parses the contained path parameters.
 * @param url The url to be parsed.
 * @param endpoint Pattern of the requested endpoint.
 * @throws {InvalidUrlError} Thrown if the provided url does not end with the provided endpoint.
 * @returns An array containing all parsed path parameters in order of appearance.
 * @example
 * // returns ["username", "role_name"]
 * parsePathParameters("https://api.example.com/users/username/roles/role_name", "/users/{}/roles/{}")
 */
function parsePathParameters(url: string, endpoint: string): string[] {
  const parameterRegex = '([a-zA-Z0-9-:]+)';
  const regex = new RegExp(endpoint.replaceAll('{}', parameterRegex) + '(?:.(?!\\\\))?$');
  const matches = url.match(regex);

  if (!matches) throw new InvalidUrlError('Url does not end with the provided endpoint');

  return matches.slice(1);
}

/**
 * This function validates a given http url and parses its path parameters.
 * @param url The url to be validated.
 * @param endpoint Pattern of the requested endpoint.
 * @throws {InvalidUrlError} Thrown if the validation of the provided url fails.
 * @returns An array containing all parsed path parameters in order of appearance (see {@link parsePathParameters}).
 * @example
 * // returns ["username", "role_name"]
 * validateUrl("https://api.example.com/users/username/roles/role_name", "/users/{}/roles/{}")
 */
function validateUrl(url: string, baseUrl: string, endpoint: string): string[] {
  if (!isValidHttpUrl(url))
    throw new InvalidUrlError(`Provided url "${url}" is not a valid http url`);
  if (!url.startsWith(baseUrl))
    throw new InvalidUrlError(
      `Provided url "${url}" does not start with the provided base url "${baseUrl}"`,
    );
  const pathParameters = parsePathParameters(url, endpoint);

  let extendedBaseUrl = baseUrl + endpoint;

  pathParameters.forEach(pathParameter => {
    extendedBaseUrl = extendedBaseUrl.replace('{}', pathParameter);
  });

  if (url !== extendedBaseUrl)
    throw new InvalidUrlError(
      `Provided url "${url}" does not match extended base url "${extendedBaseUrl}"`,
    );

  return pathParameters;
}

/**
 * This function appends a given endpoint to an url.
 * @param url The url to append the endpoint to.
 * @param endpoint The endpoint to be appended.
 * @example
 * // returns "https://api.example.com/devices/device_id/token"
 * appendToUrl("https://api.example.com/devices/device_id", "/token")
 * @example
 * // returns "https://api.example.com/devices/device_id/token"
 * appendToUrl("https://api.example.com/devices/device_id/", "/token")
 * @returns The url with the appended endpoint.
 */
function appendToUrl(url: string, endpoint: string) {
  return url.endsWith('/') ? `${url.slice(0, -1)}${endpoint}` : `${url}${endpoint}`;
}

/**
 * Client for the use of the Crosslab API
 * @category Client
 */
export class Client {
  public readonly baseUrl: string;
  public readonly serviceUrl: string;
  public accessToken: string;
  private fixedHeaders: [string, string][];
  private fetch = async (url: RequestInfo | URL, init: RequestInit) => {
    let raw_response;
    const parsedUrl = new URL(url.toString());
    try {
      if (
        parsedUrl.toString().startsWith(this.baseUrl) ||
        parsedUrl.toString().startsWith(this.serviceUrl)
      ) {
        raw_response = await fetch(url, init);
      } else {
        raw_response = await fetch(
          appendToUrl(
            this.baseUrl,
            '/proxy?' + new URLSearchParams([['URL', url.toString()]]).toString(),
          ),
          init,
        );
      }
    } catch (error) {
      if (error instanceof Error) {
        throw new FetchError(error.message);
      } else if (typeof error === 'string') {
        throw new FetchError(error);
      } else {
        throw new FetchError('Something went wrong while trying to fetch the request');
      }
    }
    return await parseResponse(raw_response);
  };

  /**
   * @category Constructors
   */
  constructor(
    baseUrl: string,
    options: {
      serviceUrl?: string;
      accessToken?: string;
      fixedHeaders?: [string, string][];
    },
  ) {
    this.baseUrl = new URL(baseUrl).toString().slice(0, -1);
    this.serviceUrl = new URL(options.serviceUrl ?? this.baseUrl).toString().slice(0, -1);
    this.accessToken = options.accessToken ?? '';
    this.fixedHeaders = options.fixedHeaders ?? [];
  }

  /**
   * Returns the free / booked times for given experiment.
   *
   * @param body
   * @param options.url
   * Url of the  to be used.
   *
   * @throws {@link FetchError | FetchError }
   * Thrown if fetch fails.
   * @throws {@link ValidationError | ValidationError }
   * Thrown if the request/response validation fails.
   * @throws {@link InvalidUrlError | InvalidUrlError }
   * Thrown if the provided url is not valid for this request.
   * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError }
   * Thrown if response is validated but has status greater than or equal to 400.
   *
   * @returns
   * Timetable of free/booked time. If 'Combined' is set to true, an array with only one entry is returned containing the combined timetable.
   */
  public async schedule(
    body:
      | {
          /**
           * An experiment describes a set of devices and how they should be connected (potentially among other metadata).
           */
          Experiment: Types.Experiment<'request'>;
          /**
           * A time slot represents a slice of time used for bookings.
           */
          Time: Types.Timeslot<'request'>;
          /**
           * If true, show only one timetable per device instead of one for all available physical devices.
           */
          Combined?: boolean;
          /**
           * (private) Show only devices of this institution. Give an error if a device of an other institution is requested.
           */
          onlyOwn?: boolean;
          [k: string]: unknown;
        }
      | undefined,
    options?: {
      headers?: [string, string][];
      url?: string;
    },
  ): Promise<Signatures.ScheduleSuccessResponse['body']> {
    const url = appendToUrl(options?.url ?? this.baseUrl, '/schedule');
    console.log('trying to fetch url:', url);

    if (!RequestValidation.validateScheduleInput(body))
      throw new ValidationError(
        'Request validation failed!',
        (RequestValidation.validateScheduleInput as Types.FunctionWithErrors).errors,
      );

    const authorization: string = `Bearer ${this.accessToken}`;

    console.log(
      'trying to fetch url:',
      new URL(url).toString().replace(this.baseUrl, this.serviceUrl),
    );
    const response = await this.fetch(
      new URL(url).toString().replace(this.baseUrl, this.serviceUrl),
      {
        method: 'POST',
        headers: [
          ['Content-Type', 'application/json'],
          ['Authorization', authorization],
          ...this.fixedHeaders,
          ...(options?.headers ?? []),
        ],
        body: JSON.stringify(body),
      },
    );

    if (!RequestValidation.validateScheduleOutput(response))
      throw new ValidationError(
        'Response validation failed!',
        (RequestValidation.validateScheduleOutput as Types.FunctionWithErrors).errors,
      );

    if (Types.isErrorResponse(response))
      throw new UnsuccessfulRequestError(
        `Server returned response with status ${response.status}`,
        response,
      );

    return response.body;
  }
}
