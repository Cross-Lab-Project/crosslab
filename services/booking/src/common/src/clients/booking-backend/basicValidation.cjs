/* eslint-disable */
//@ts-nocheck
/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */
'use strict';
exports.validateBooking = validate21;
const schema6 = {
  title: 'Booking',
  description: 'A booking in the booking system.',
  type: 'object',
  required: ['ID', 'Time', 'Devices', 'Status', 'You', 'External'],
  properties: {
    ID: { type: 'string', format: 'uri', description: 'Unique ID of the booking.' },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Devices: { type: 'array', items: { type: 'string', format: 'uri' } },
    Type: {
      description:
        "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
      type: 'string',
      enum: ['normal'],
    },
    Status: {
      description:
        "Current status of the booking. While the booking is pending, it can not be used. Will change automatically and can not be set by user. 'rejected' is set when the initial booking failed, 'cancelled' when the booking was deleted / cancelled after it was once active. The 'active-*' will be used when a device was added after the booking was locked.\n",
      type: 'string',
      enum: [
        'pending',
        'booked',
        'rejected',
        'cancelled',
        'active',
        'active-pending',
        'active-rejected',
      ],
    },
    You: { type: 'boolean', description: 'If true, this booking was done by you.' },
    External: {
      type: 'boolean',
      description: 'Shows whether the booking was done by an external institution.',
    },
    Message: {
      type: 'string',
      description:
        'User readable notes about the status of the booking (e.g. if devices are unknown).',
    },
  },
  'x-standalone': true,
  'x-name': 'Booking',
  'x-location': '#/components/schemas/Booking',
  'x-schema-type': 'all',
};
const formats0 = require('ajv-formats/dist/formats').fullFormats.uri;
const formats2 = require('ajv-formats/dist/formats').fullFormats['date-time'];
function validate21(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.ID === undefined && (missing0 = 'ID')) ||
        (data.Time === undefined && (missing0 = 'Time')) ||
        (data.Devices === undefined && (missing0 = 'Devices')) ||
        (data.Status === undefined && (missing0 = 'Status')) ||
        (data.You === undefined && (missing0 = 'You')) ||
        (data.External === undefined && (missing0 = 'External'))
      ) {
        validate21.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema6.required,
            parentSchema: schema6,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema6.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate21.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema6.properties.ID.type,
                    parentSchema: schema6.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data1 = data.Time;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                let missing1;
                if (
                  (data1.Start === undefined && (missing1 = 'Start')) ||
                  (data1.End === undefined && (missing1 = 'End'))
                ) {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing1 },
                      message: "must have required property '" + missing1 + "'",
                      schema: schema6.properties.Time.required,
                      parentSchema: schema6.properties.Time,
                      data: data1,
                    },
                  ];
                  return false;
                } else {
                  if (data1.Start !== undefined) {
                    let data2 = data1.Start;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (errors === _errs5) {
                        if (typeof data2 === 'string') {
                          if (!formats2.validate(data2)) {
                            validate21.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema6.properties.Time.properties.Start,
                                data: data2,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate21.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema6.properties.Time.properties.Start.type,
                              parentSchema: schema6.properties.Time.properties.Start,
                              data: data2,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data1.End !== undefined) {
                      let data3 = data1.End;
                      const _errs7 = errors;
                      if (errors === _errs7) {
                        if (errors === _errs7) {
                          if (typeof data3 === 'string') {
                            if (!formats2.validate(data3)) {
                              validate21.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema6.properties.Time.properties.End,
                                  data: data3,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate21.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema6.properties.Time.properties.End.type,
                                parentSchema: schema6.properties.Time.properties.End,
                                data: data3,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid1 = _errs7 === errors;
                    } else {
                      var valid1 = true;
                    }
                  }
                }
              } else {
                validate21.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema6.properties.Time.type,
                    parentSchema: schema6.properties.Time,
                    data: data1,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Devices !== undefined) {
              let data4 = data.Devices;
              const _errs9 = errors;
              if (errors === _errs9) {
                if (Array.isArray(data4)) {
                  var valid2 = true;
                  const len0 = data4.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data5 = data4[i0];
                    const _errs11 = errors;
                    if (errors === _errs11) {
                      if (errors === _errs11) {
                        if (typeof data5 === 'string') {
                          if (!formats0(data5)) {
                            validate21.errors = [
                              {
                                instancePath: instancePath + '/Devices/' + i0,
                                schemaPath: '#/properties/Devices/items/format',
                                keyword: 'format',
                                params: { format: 'uri' },
                                message: 'must match format "' + 'uri' + '"',
                                schema: 'uri',
                                parentSchema: schema6.properties.Devices.items,
                                data: data5,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate21.errors = [
                            {
                              instancePath: instancePath + '/Devices/' + i0,
                              schemaPath: '#/properties/Devices/items/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema6.properties.Devices.items.type,
                              parentSchema: schema6.properties.Devices.items,
                              data: data5,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid2 = _errs11 === errors;
                    if (!valid2) {
                      break;
                    }
                  }
                } else {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/Devices',
                      schemaPath: '#/properties/Devices/type',
                      keyword: 'type',
                      params: { type: 'array' },
                      message: 'must be array',
                      schema: schema6.properties.Devices.type,
                      parentSchema: schema6.properties.Devices,
                      data: data4,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs9 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.Type !== undefined) {
                let data6 = data.Type;
                const _errs13 = errors;
                if (typeof data6 !== 'string') {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema6.properties.Type.type,
                      parentSchema: schema6.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                if (!(data6 === 'normal')) {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/enum',
                      keyword: 'enum',
                      params: { allowedValues: schema6.properties.Type.enum },
                      message: 'must be equal to one of the allowed values',
                      schema: schema6.properties.Type.enum,
                      parentSchema: schema6.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs13 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.Status !== undefined) {
                  let data7 = data.Status;
                  const _errs15 = errors;
                  if (typeof data7 !== 'string') {
                    validate21.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/type',
                        keyword: 'type',
                        params: { type: 'string' },
                        message: 'must be string',
                        schema: schema6.properties.Status.type,
                        parentSchema: schema6.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  if (
                    !(
                      data7 === 'pending' ||
                      data7 === 'booked' ||
                      data7 === 'rejected' ||
                      data7 === 'cancelled' ||
                      data7 === 'active' ||
                      data7 === 'active-pending' ||
                      data7 === 'active-rejected'
                    )
                  ) {
                    validate21.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/enum',
                        keyword: 'enum',
                        params: { allowedValues: schema6.properties.Status.enum },
                        message: 'must be equal to one of the allowed values',
                        schema: schema6.properties.Status.enum,
                        parentSchema: schema6.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  var valid0 = _errs15 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.You !== undefined) {
                    let data8 = data.You;
                    const _errs17 = errors;
                    if (typeof data8 !== 'boolean') {
                      validate21.errors = [
                        {
                          instancePath: instancePath + '/You',
                          schemaPath: '#/properties/You/type',
                          keyword: 'type',
                          params: { type: 'boolean' },
                          message: 'must be boolean',
                          schema: schema6.properties.You.type,
                          parentSchema: schema6.properties.You,
                          data: data8,
                        },
                      ];
                      return false;
                    }
                    var valid0 = _errs17 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.External !== undefined) {
                      let data9 = data.External;
                      const _errs19 = errors;
                      if (typeof data9 !== 'boolean') {
                        validate21.errors = [
                          {
                            instancePath: instancePath + '/External',
                            schemaPath: '#/properties/External/type',
                            keyword: 'type',
                            params: { type: 'boolean' },
                            message: 'must be boolean',
                            schema: schema6.properties.External.type,
                            parentSchema: schema6.properties.External,
                            data: data9,
                          },
                        ];
                        return false;
                      }
                      var valid0 = _errs19 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.Message !== undefined) {
                        let data10 = data.Message;
                        const _errs21 = errors;
                        if (typeof data10 !== 'string') {
                          validate21.errors = [
                            {
                              instancePath: instancePath + '/Message',
                              schemaPath: '#/properties/Message/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema6.properties.Message.type,
                              parentSchema: schema6.properties.Message,
                              data: data10,
                            },
                          ];
                          return false;
                        }
                        var valid0 = _errs21 === errors;
                      } else {
                        var valid0 = true;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate21.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema6.type,
          parentSchema: schema6,
          data,
        },
      ];
      return false;
    }
  }
  validate21.errors = vErrors;
  return errors === 0;
}
exports.validateDevice = validate22;
const schema7 = {
  title: 'Device',
  description: 'A device might either be a physical/virtual device or a group of device.',
  type: 'object',
  required: ['ID'],
  properties: {
    ID: {
      type: 'string',
      description:
        'Unique ID of the device. Contains the institution (by having an end point at that institution)',
      format: 'uri',
    },
  },
  'x-standalone': true,
  'x-name': 'Device',
  'x-location': '#/components/schemas/Device',
  'x-schema-type': 'all',
};
function validate22(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.ID === undefined && (missing0 = 'ID')) {
        validate22.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema7.required,
            parentSchema: schema7,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate22.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema7.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate22.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema7.properties.ID.type,
                    parentSchema: schema7.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate22.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema7.type,
          parentSchema: schema7,
          data,
        },
      ];
      return false;
    }
  }
  validate22.errors = vErrors;
  return errors === 0;
}
exports.validateExperiment = validate23;
const schema8 = {
  title: 'Experiment',
  description:
    'An experiment describes a set of devices and how they should be connected (potentially among other metadata).',
  type: 'object',
  required: ['Devices'],
  properties: {
    Devices: {
      type: 'array',
      description: 'List of devices used in experiment.',
      items: {
        title: 'Device',
        description:
          'A device might either be a physical/virtual device or a group of device.',
        type: 'object',
        required: ['ID'],
        properties: {
          ID: {
            type: 'string',
            description:
              'Unique ID of the device. Contains the institution (by having an end point at that institution)',
            format: 'uri',
          },
        },
      },
    },
    Description: {
      type: 'string',
      description:
        'User provided description, for example might be a reason for the booking (e.g. maintenance) or a link to the experiment. Might be empty or missing.\n',
    },
  },
  'x-standalone': true,
  'x-name': 'Experiment',
  'x-location': '#/components/schemas/Experiment',
  'x-schema-type': 'all',
};
function validate23(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.Devices === undefined && (missing0 = 'Devices')) {
        validate23.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema8.required,
            parentSchema: schema8,
            data,
          },
        ];
        return false;
      } else {
        if (data.Devices !== undefined) {
          let data0 = data.Devices;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (Array.isArray(data0)) {
              var valid1 = true;
              const len0 = data0.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data1 = data0[i0];
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                    let missing1;
                    if (data1.ID === undefined && (missing1 = 'ID')) {
                      validate23.errors = [
                        {
                          instancePath: instancePath + '/Devices/' + i0,
                          schemaPath: '#/properties/Devices/items/required',
                          keyword: 'required',
                          params: { missingProperty: missing1 },
                          message: "must have required property '" + missing1 + "'",
                          schema: schema8.properties.Devices.items.required,
                          parentSchema: schema8.properties.Devices.items,
                          data: data1,
                        },
                      ];
                      return false;
                    } else {
                      if (data1.ID !== undefined) {
                        let data2 = data1.ID;
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (errors === _errs5) {
                            if (typeof data2 === 'string') {
                              if (!formats0(data2)) {
                                validate23.errors = [
                                  {
                                    instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                    schemaPath:
                                      '#/properties/Devices/items/properties/ID/format',
                                    keyword: 'format',
                                    params: { format: 'uri' },
                                    message: 'must match format "' + 'uri' + '"',
                                    schema: 'uri',
                                    parentSchema:
                                      schema8.properties.Devices.items.properties.ID,
                                    data: data2,
                                  },
                                ];
                                return false;
                              }
                            } else {
                              validate23.errors = [
                                {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/properties/Devices/items/properties/ID/type',
                                  keyword: 'type',
                                  params: { type: 'string' },
                                  message: 'must be string',
                                  schema:
                                    schema8.properties.Devices.items.properties.ID.type,
                                  parentSchema:
                                    schema8.properties.Devices.items.properties.ID,
                                  data: data2,
                                },
                              ];
                              return false;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate23.errors = [
                      {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/properties/Devices/items/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                        schema: schema8.properties.Devices.items.type,
                        parentSchema: schema8.properties.Devices.items,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                }
                var valid1 = _errs3 === errors;
                if (!valid1) {
                  break;
                }
              }
            } else {
              validate23.errors = [
                {
                  instancePath: instancePath + '/Devices',
                  schemaPath: '#/properties/Devices/type',
                  keyword: 'type',
                  params: { type: 'array' },
                  message: 'must be array',
                  schema: schema8.properties.Devices.type,
                  parentSchema: schema8.properties.Devices,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Description !== undefined) {
            let data3 = data.Description;
            const _errs7 = errors;
            if (typeof data3 !== 'string') {
              validate23.errors = [
                {
                  instancePath: instancePath + '/Description',
                  schemaPath: '#/properties/Description/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema8.properties.Description.type,
                  parentSchema: schema8.properties.Description,
                  data: data3,
                },
              ];
              return false;
            }
            var valid0 = _errs7 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate23.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema8.type,
          parentSchema: schema8,
          data,
        },
      ];
      return false;
    }
  }
  validate23.errors = vErrors;
  return errors === 0;
}
exports.validateTimeslot = validate24;
const schema9 = {
  title: 'Timeslot',
  description: 'A time slot represents a slice of time used for bookings.',
  type: 'object',
  required: ['Start', 'End'],
  properties: {
    Start: {
      type: 'string',
      description: 'Start time of the booking.',
      format: 'date-time',
    },
    End: { type: 'string', description: 'End time of the booking.', format: 'date-time' },
  },
  'x-standalone': true,
  'x-name': 'Timeslot',
  'x-location': '#/components/schemas/Timeslot',
  'x-schema-type': 'all',
};
function validate24(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Start === undefined && (missing0 = 'Start')) ||
        (data.End === undefined && (missing0 = 'End'))
      ) {
        validate24.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema9.required,
            parentSchema: schema9,
            data,
          },
        ];
        return false;
      } else {
        if (data.Start !== undefined) {
          let data0 = data.Start;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats2.validate(data0)) {
                  validate24.errors = [
                    {
                      instancePath: instancePath + '/Start',
                      schemaPath: '#/properties/Start/format',
                      keyword: 'format',
                      params: { format: 'date-time' },
                      message: 'must match format "' + 'date-time' + '"',
                      schema: 'date-time',
                      parentSchema: schema9.properties.Start,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate24.errors = [
                  {
                    instancePath: instancePath + '/Start',
                    schemaPath: '#/properties/Start/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema9.properties.Start.type,
                    parentSchema: schema9.properties.Start,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.End !== undefined) {
            let data1 = data.End;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (errors === _errs3) {
                if (typeof data1 === 'string') {
                  if (!formats2.validate(data1)) {
                    validate24.errors = [
                      {
                        instancePath: instancePath + '/End',
                        schemaPath: '#/properties/End/format',
                        keyword: 'format',
                        params: { format: 'date-time' },
                        message: 'must match format "' + 'date-time' + '"',
                        schema: 'date-time',
                        parentSchema: schema9.properties.End,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                } else {
                  validate24.errors = [
                    {
                      instancePath: instancePath + '/End',
                      schemaPath: '#/properties/End/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema9.properties.End.type,
                      parentSchema: schema9.properties.End,
                      data: data1,
                    },
                  ];
                  return false;
                }
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate24.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema9.type,
          parentSchema: schema9,
          data,
        },
      ];
      return false;
    }
  }
  validate24.errors = vErrors;
  return errors === 0;
}
exports.validateID = validate25;
const schema10 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'ID',
  'x-location': '#/components/parameters/ID/schema',
  'x-schema-type': 'all',
};
function validate25(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate25.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema10.type,
        parentSchema: schema10,
        data,
      },
    ];
    return false;
  }
  validate25.errors = vErrors;
  return errors === 0;
}
exports.validateLockBookingResponse200 = validate26;
const schema11 = {
  type: 'array',
  description:
    'The list of booked devices and selected real devices. Order is guaranteed to be the same as in the booking.',
  items: {
    type: 'object',
    required: ['Requested', 'Selected'],
    properties: {
      Requested: { type: 'string', format: 'uri' },
      Selected: { type: 'string', format: 'uri' },
    },
  },
  'x-standalone': false,
  'x-name': 'lockBookingResponse200',
  'x-location':
    '#/paths//booking/{ID}/lock/put/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate26(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.Requested === undefined && (missing0 = 'Requested')) ||
              (data0.Selected === undefined && (missing0 = 'Selected'))
            ) {
              validate26.errors = [
                {
                  instancePath: instancePath + '/' + i0,
                  schemaPath: '#/items/required',
                  keyword: 'required',
                  params: { missingProperty: missing0 },
                  message: "must have required property '" + missing0 + "'",
                  schema: schema11.items.required,
                  parentSchema: schema11.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.Requested !== undefined) {
                let data1 = data0.Requested;
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (errors === _errs3) {
                    if (typeof data1 === 'string') {
                      if (!formats0(data1)) {
                        validate26.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/Requested',
                            schemaPath: '#/items/properties/Requested/format',
                            keyword: 'format',
                            params: { format: 'uri' },
                            message: 'must match format "' + 'uri' + '"',
                            schema: 'uri',
                            parentSchema: schema11.items.properties.Requested,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    } else {
                      validate26.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/Requested',
                          schemaPath: '#/items/properties/Requested/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema11.items.properties.Requested.type,
                          parentSchema: schema11.items.properties.Requested,
                          data: data1,
                        },
                      ];
                      return false;
                    }
                  }
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.Selected !== undefined) {
                  let data2 = data0.Selected;
                  const _errs5 = errors;
                  if (errors === _errs5) {
                    if (errors === _errs5) {
                      if (typeof data2 === 'string') {
                        if (!formats0(data2)) {
                          validate26.errors = [
                            {
                              instancePath: instancePath + '/' + i0 + '/Selected',
                              schemaPath: '#/items/properties/Selected/format',
                              keyword: 'format',
                              params: { format: 'uri' },
                              message: 'must match format "' + 'uri' + '"',
                              schema: 'uri',
                              parentSchema: schema11.items.properties.Selected,
                              data: data2,
                            },
                          ];
                          return false;
                        }
                      } else {
                        validate26.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/Selected',
                            schemaPath: '#/items/properties/Selected/type',
                            keyword: 'type',
                            params: { type: 'string' },
                            message: 'must be string',
                            schema: schema11.items.properties.Selected.type,
                            parentSchema: schema11.items.properties.Selected,
                            data: data2,
                          },
                        ];
                        return false;
                      }
                    }
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
              }
            }
          } else {
            validate26.errors = [
              {
                instancePath: instancePath + '/' + i0,
                schemaPath: '#/items/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema11.items.type,
                parentSchema: schema11.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate26.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
          schema: schema11.type,
          parentSchema: schema11,
          data,
        },
      ];
      return false;
    }
  }
  validate26.errors = vErrors;
  return errors === 0;
}
exports.validateLockBookingResponse500 = validate27;
const schema12 = {
  type: 'string',
  description: 'Error string',
  'x-standalone': false,
  'x-name': 'lockBookingResponse500',
  'x-location':
    '#/paths//booking/{ID}/lock/put/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate27(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate27.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema12.type,
        parentSchema: schema12,
        data,
      },
    ];
    return false;
  }
  validate27.errors = vErrors;
  return errors === 0;
}
exports.validateUnlockBookingResponse500 = validate28;
const schema13 = {
  type: 'string',
  description: 'Error description.',
  'x-standalone': false,
  'x-name': 'unlockBookingResponse500',
  'x-location':
    '#/paths//booking/{ID}/lock/delete/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate28(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate28.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema13.type,
        parentSchema: schema13,
        data,
      },
    ];
    return false;
  }
  validate28.errors = vErrors;
  return errors === 0;
}
exports.validateBookingCallbackResponse500 = validate29;
const schema14 = {
  type: 'string',
  description: 'Error description.',
  'x-standalone': false,
  'x-name': 'bookingCallbackResponse500',
  'x-location':
    '#/paths//booking_callback/{ID}/post/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate29(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate29.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema14.type,
        parentSchema: schema14,
        data,
      },
    ];
    return false;
  }
  validate29.errors = vErrors;
  return errors === 0;
}
exports.validateBookingRequest = validate30;
const schema15 = {
  title: 'Booking',
  description: 'A booking in the booking system.',
  type: 'object',
  required: ['ID', 'Time', 'Devices', 'Status', 'You', 'External'],
  properties: {
    ID: { type: 'string', format: 'uri', description: 'Unique ID of the booking.' },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Devices: { type: 'array', items: { type: 'string', format: 'uri' } },
    Type: {
      description:
        "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
      type: 'string',
      enum: ['normal'],
    },
    Status: {
      description:
        "Current status of the booking. While the booking is pending, it can not be used. Will change automatically and can not be set by user. 'rejected' is set when the initial booking failed, 'cancelled' when the booking was deleted / cancelled after it was once active. The 'active-*' will be used when a device was added after the booking was locked.\n",
      type: 'string',
      enum: [
        'pending',
        'booked',
        'rejected',
        'cancelled',
        'active',
        'active-pending',
        'active-rejected',
      ],
    },
    You: { type: 'boolean', description: 'If true, this booking was done by you.' },
    External: {
      type: 'boolean',
      description: 'Shows whether the booking was done by an external institution.',
    },
    Message: {
      type: 'string',
      description:
        'User readable notes about the status of the booking (e.g. if devices are unknown).',
    },
  },
  'x-standalone': true,
  'x-name': 'BookingRequest',
  'x-location': '#/components/schemas/Booking_request',
  'x-schema-type': 'request',
};
function validate30(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.ID === undefined && (missing0 = 'ID')) ||
        (data.Time === undefined && (missing0 = 'Time')) ||
        (data.Devices === undefined && (missing0 = 'Devices')) ||
        (data.Status === undefined && (missing0 = 'Status')) ||
        (data.You === undefined && (missing0 = 'You')) ||
        (data.External === undefined && (missing0 = 'External'))
      ) {
        validate30.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema15.required,
            parentSchema: schema15,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate30.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema15.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate30.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema15.properties.ID.type,
                    parentSchema: schema15.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data1 = data.Time;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                let missing1;
                if (
                  (data1.Start === undefined && (missing1 = 'Start')) ||
                  (data1.End === undefined && (missing1 = 'End'))
                ) {
                  validate30.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing1 },
                      message: "must have required property '" + missing1 + "'",
                      schema: schema15.properties.Time.required,
                      parentSchema: schema15.properties.Time,
                      data: data1,
                    },
                  ];
                  return false;
                } else {
                  if (data1.Start !== undefined) {
                    let data2 = data1.Start;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (errors === _errs5) {
                        if (typeof data2 === 'string') {
                          if (!formats2.validate(data2)) {
                            validate30.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema15.properties.Time.properties.Start,
                                data: data2,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate30.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema15.properties.Time.properties.Start.type,
                              parentSchema: schema15.properties.Time.properties.Start,
                              data: data2,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data1.End !== undefined) {
                      let data3 = data1.End;
                      const _errs7 = errors;
                      if (errors === _errs7) {
                        if (errors === _errs7) {
                          if (typeof data3 === 'string') {
                            if (!formats2.validate(data3)) {
                              validate30.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema15.properties.Time.properties.End,
                                  data: data3,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate30.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema15.properties.Time.properties.End.type,
                                parentSchema: schema15.properties.Time.properties.End,
                                data: data3,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid1 = _errs7 === errors;
                    } else {
                      var valid1 = true;
                    }
                  }
                }
              } else {
                validate30.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema15.properties.Time.type,
                    parentSchema: schema15.properties.Time,
                    data: data1,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Devices !== undefined) {
              let data4 = data.Devices;
              const _errs9 = errors;
              if (errors === _errs9) {
                if (Array.isArray(data4)) {
                  var valid2 = true;
                  const len0 = data4.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data5 = data4[i0];
                    const _errs11 = errors;
                    if (errors === _errs11) {
                      if (errors === _errs11) {
                        if (typeof data5 === 'string') {
                          if (!formats0(data5)) {
                            validate30.errors = [
                              {
                                instancePath: instancePath + '/Devices/' + i0,
                                schemaPath: '#/properties/Devices/items/format',
                                keyword: 'format',
                                params: { format: 'uri' },
                                message: 'must match format "' + 'uri' + '"',
                                schema: 'uri',
                                parentSchema: schema15.properties.Devices.items,
                                data: data5,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate30.errors = [
                            {
                              instancePath: instancePath + '/Devices/' + i0,
                              schemaPath: '#/properties/Devices/items/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema15.properties.Devices.items.type,
                              parentSchema: schema15.properties.Devices.items,
                              data: data5,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid2 = _errs11 === errors;
                    if (!valid2) {
                      break;
                    }
                  }
                } else {
                  validate30.errors = [
                    {
                      instancePath: instancePath + '/Devices',
                      schemaPath: '#/properties/Devices/type',
                      keyword: 'type',
                      params: { type: 'array' },
                      message: 'must be array',
                      schema: schema15.properties.Devices.type,
                      parentSchema: schema15.properties.Devices,
                      data: data4,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs9 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.Type !== undefined) {
                let data6 = data.Type;
                const _errs13 = errors;
                if (typeof data6 !== 'string') {
                  validate30.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema15.properties.Type.type,
                      parentSchema: schema15.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                if (!(data6 === 'normal')) {
                  validate30.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/enum',
                      keyword: 'enum',
                      params: { allowedValues: schema15.properties.Type.enum },
                      message: 'must be equal to one of the allowed values',
                      schema: schema15.properties.Type.enum,
                      parentSchema: schema15.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs13 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.Status !== undefined) {
                  let data7 = data.Status;
                  const _errs15 = errors;
                  if (typeof data7 !== 'string') {
                    validate30.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/type',
                        keyword: 'type',
                        params: { type: 'string' },
                        message: 'must be string',
                        schema: schema15.properties.Status.type,
                        parentSchema: schema15.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  if (
                    !(
                      data7 === 'pending' ||
                      data7 === 'booked' ||
                      data7 === 'rejected' ||
                      data7 === 'cancelled' ||
                      data7 === 'active' ||
                      data7 === 'active-pending' ||
                      data7 === 'active-rejected'
                    )
                  ) {
                    validate30.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/enum',
                        keyword: 'enum',
                        params: { allowedValues: schema15.properties.Status.enum },
                        message: 'must be equal to one of the allowed values',
                        schema: schema15.properties.Status.enum,
                        parentSchema: schema15.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  var valid0 = _errs15 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.You !== undefined) {
                    let data8 = data.You;
                    const _errs17 = errors;
                    if (typeof data8 !== 'boolean') {
                      validate30.errors = [
                        {
                          instancePath: instancePath + '/You',
                          schemaPath: '#/properties/You/type',
                          keyword: 'type',
                          params: { type: 'boolean' },
                          message: 'must be boolean',
                          schema: schema15.properties.You.type,
                          parentSchema: schema15.properties.You,
                          data: data8,
                        },
                      ];
                      return false;
                    }
                    var valid0 = _errs17 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.External !== undefined) {
                      let data9 = data.External;
                      const _errs19 = errors;
                      if (typeof data9 !== 'boolean') {
                        validate30.errors = [
                          {
                            instancePath: instancePath + '/External',
                            schemaPath: '#/properties/External/type',
                            keyword: 'type',
                            params: { type: 'boolean' },
                            message: 'must be boolean',
                            schema: schema15.properties.External.type,
                            parentSchema: schema15.properties.External,
                            data: data9,
                          },
                        ];
                        return false;
                      }
                      var valid0 = _errs19 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.Message !== undefined) {
                        let data10 = data.Message;
                        const _errs21 = errors;
                        if (typeof data10 !== 'string') {
                          validate30.errors = [
                            {
                              instancePath: instancePath + '/Message',
                              schemaPath: '#/properties/Message/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema15.properties.Message.type,
                              parentSchema: schema15.properties.Message,
                              data: data10,
                            },
                          ];
                          return false;
                        }
                        var valid0 = _errs21 === errors;
                      } else {
                        var valid0 = true;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate30.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema15.type,
          parentSchema: schema15,
          data,
        },
      ];
      return false;
    }
  }
  validate30.errors = vErrors;
  return errors === 0;
}
exports.validateBookingResponse = validate31;
const schema16 = {
  title: 'Booking',
  description: 'A booking in the booking system.',
  type: 'object',
  required: ['ID', 'Time', 'Devices', 'Status', 'You', 'External'],
  properties: {
    ID: { type: 'string', format: 'uri', description: 'Unique ID of the booking.' },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Devices: { type: 'array', items: { type: 'string', format: 'uri' } },
    Type: {
      description:
        "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
      type: 'string',
      enum: ['normal'],
    },
    Status: {
      description:
        "Current status of the booking. While the booking is pending, it can not be used. Will change automatically and can not be set by user. 'rejected' is set when the initial booking failed, 'cancelled' when the booking was deleted / cancelled after it was once active. The 'active-*' will be used when a device was added after the booking was locked.\n",
      type: 'string',
      enum: [
        'pending',
        'booked',
        'rejected',
        'cancelled',
        'active',
        'active-pending',
        'active-rejected',
      ],
    },
    You: { type: 'boolean', description: 'If true, this booking was done by you.' },
    External: {
      type: 'boolean',
      description: 'Shows whether the booking was done by an external institution.',
    },
    Message: {
      type: 'string',
      description:
        'User readable notes about the status of the booking (e.g. if devices are unknown).',
    },
  },
  'x-standalone': true,
  'x-name': 'BookingResponse',
  'x-location': '#/components/schemas/Booking_response',
  'x-schema-type': 'response',
};
function validate31(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.ID === undefined && (missing0 = 'ID')) ||
        (data.Time === undefined && (missing0 = 'Time')) ||
        (data.Devices === undefined && (missing0 = 'Devices')) ||
        (data.Status === undefined && (missing0 = 'Status')) ||
        (data.You === undefined && (missing0 = 'You')) ||
        (data.External === undefined && (missing0 = 'External'))
      ) {
        validate31.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema16.required,
            parentSchema: schema16,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate31.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema16.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate31.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema16.properties.ID.type,
                    parentSchema: schema16.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data1 = data.Time;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                let missing1;
                if (
                  (data1.Start === undefined && (missing1 = 'Start')) ||
                  (data1.End === undefined && (missing1 = 'End'))
                ) {
                  validate31.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing1 },
                      message: "must have required property '" + missing1 + "'",
                      schema: schema16.properties.Time.required,
                      parentSchema: schema16.properties.Time,
                      data: data1,
                    },
                  ];
                  return false;
                } else {
                  if (data1.Start !== undefined) {
                    let data2 = data1.Start;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (errors === _errs5) {
                        if (typeof data2 === 'string') {
                          if (!formats2.validate(data2)) {
                            validate31.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema16.properties.Time.properties.Start,
                                data: data2,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate31.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema16.properties.Time.properties.Start.type,
                              parentSchema: schema16.properties.Time.properties.Start,
                              data: data2,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data1.End !== undefined) {
                      let data3 = data1.End;
                      const _errs7 = errors;
                      if (errors === _errs7) {
                        if (errors === _errs7) {
                          if (typeof data3 === 'string') {
                            if (!formats2.validate(data3)) {
                              validate31.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema16.properties.Time.properties.End,
                                  data: data3,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate31.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema16.properties.Time.properties.End.type,
                                parentSchema: schema16.properties.Time.properties.End,
                                data: data3,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid1 = _errs7 === errors;
                    } else {
                      var valid1 = true;
                    }
                  }
                }
              } else {
                validate31.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema16.properties.Time.type,
                    parentSchema: schema16.properties.Time,
                    data: data1,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Devices !== undefined) {
              let data4 = data.Devices;
              const _errs9 = errors;
              if (errors === _errs9) {
                if (Array.isArray(data4)) {
                  var valid2 = true;
                  const len0 = data4.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data5 = data4[i0];
                    const _errs11 = errors;
                    if (errors === _errs11) {
                      if (errors === _errs11) {
                        if (typeof data5 === 'string') {
                          if (!formats0(data5)) {
                            validate31.errors = [
                              {
                                instancePath: instancePath + '/Devices/' + i0,
                                schemaPath: '#/properties/Devices/items/format',
                                keyword: 'format',
                                params: { format: 'uri' },
                                message: 'must match format "' + 'uri' + '"',
                                schema: 'uri',
                                parentSchema: schema16.properties.Devices.items,
                                data: data5,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate31.errors = [
                            {
                              instancePath: instancePath + '/Devices/' + i0,
                              schemaPath: '#/properties/Devices/items/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema16.properties.Devices.items.type,
                              parentSchema: schema16.properties.Devices.items,
                              data: data5,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid2 = _errs11 === errors;
                    if (!valid2) {
                      break;
                    }
                  }
                } else {
                  validate31.errors = [
                    {
                      instancePath: instancePath + '/Devices',
                      schemaPath: '#/properties/Devices/type',
                      keyword: 'type',
                      params: { type: 'array' },
                      message: 'must be array',
                      schema: schema16.properties.Devices.type,
                      parentSchema: schema16.properties.Devices,
                      data: data4,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs9 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.Type !== undefined) {
                let data6 = data.Type;
                const _errs13 = errors;
                if (typeof data6 !== 'string') {
                  validate31.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema16.properties.Type.type,
                      parentSchema: schema16.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                if (!(data6 === 'normal')) {
                  validate31.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/enum',
                      keyword: 'enum',
                      params: { allowedValues: schema16.properties.Type.enum },
                      message: 'must be equal to one of the allowed values',
                      schema: schema16.properties.Type.enum,
                      parentSchema: schema16.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs13 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.Status !== undefined) {
                  let data7 = data.Status;
                  const _errs15 = errors;
                  if (typeof data7 !== 'string') {
                    validate31.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/type',
                        keyword: 'type',
                        params: { type: 'string' },
                        message: 'must be string',
                        schema: schema16.properties.Status.type,
                        parentSchema: schema16.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  if (
                    !(
                      data7 === 'pending' ||
                      data7 === 'booked' ||
                      data7 === 'rejected' ||
                      data7 === 'cancelled' ||
                      data7 === 'active' ||
                      data7 === 'active-pending' ||
                      data7 === 'active-rejected'
                    )
                  ) {
                    validate31.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/enum',
                        keyword: 'enum',
                        params: { allowedValues: schema16.properties.Status.enum },
                        message: 'must be equal to one of the allowed values',
                        schema: schema16.properties.Status.enum,
                        parentSchema: schema16.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  var valid0 = _errs15 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.You !== undefined) {
                    let data8 = data.You;
                    const _errs17 = errors;
                    if (typeof data8 !== 'boolean') {
                      validate31.errors = [
                        {
                          instancePath: instancePath + '/You',
                          schemaPath: '#/properties/You/type',
                          keyword: 'type',
                          params: { type: 'boolean' },
                          message: 'must be boolean',
                          schema: schema16.properties.You.type,
                          parentSchema: schema16.properties.You,
                          data: data8,
                        },
                      ];
                      return false;
                    }
                    var valid0 = _errs17 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.External !== undefined) {
                      let data9 = data.External;
                      const _errs19 = errors;
                      if (typeof data9 !== 'boolean') {
                        validate31.errors = [
                          {
                            instancePath: instancePath + '/External',
                            schemaPath: '#/properties/External/type',
                            keyword: 'type',
                            params: { type: 'boolean' },
                            message: 'must be boolean',
                            schema: schema16.properties.External.type,
                            parentSchema: schema16.properties.External,
                            data: data9,
                          },
                        ];
                        return false;
                      }
                      var valid0 = _errs19 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.Message !== undefined) {
                        let data10 = data.Message;
                        const _errs21 = errors;
                        if (typeof data10 !== 'string') {
                          validate31.errors = [
                            {
                              instancePath: instancePath + '/Message',
                              schemaPath: '#/properties/Message/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema16.properties.Message.type,
                              parentSchema: schema16.properties.Message,
                              data: data10,
                            },
                          ];
                          return false;
                        }
                        var valid0 = _errs21 === errors;
                      } else {
                        var valid0 = true;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate31.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema16.type,
          parentSchema: schema16,
          data,
        },
      ];
      return false;
    }
  }
  validate31.errors = vErrors;
  return errors === 0;
}
exports.validateDeviceRequest = validate32;
const schema17 = {
  title: 'Device',
  description: 'A device might either be a physical/virtual device or a group of device.',
  type: 'object',
  required: ['ID'],
  properties: {
    ID: {
      type: 'string',
      description:
        'Unique ID of the device. Contains the institution (by having an end point at that institution)',
      format: 'uri',
    },
  },
  'x-standalone': true,
  'x-name': 'DeviceRequest',
  'x-location': '#/components/schemas/Device_request',
  'x-schema-type': 'request',
};
function validate32(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.ID === undefined && (missing0 = 'ID')) {
        validate32.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema17.required,
            parentSchema: schema17,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate32.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema17.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate32.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema17.properties.ID.type,
                    parentSchema: schema17.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate32.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema17.type,
          parentSchema: schema17,
          data,
        },
      ];
      return false;
    }
  }
  validate32.errors = vErrors;
  return errors === 0;
}
exports.validateDeviceResponse = validate33;
const schema18 = {
  title: 'Device',
  description: 'A device might either be a physical/virtual device or a group of device.',
  type: 'object',
  required: ['ID'],
  properties: {
    ID: {
      type: 'string',
      description:
        'Unique ID of the device. Contains the institution (by having an end point at that institution)',
      format: 'uri',
    },
  },
  'x-standalone': true,
  'x-name': 'DeviceResponse',
  'x-location': '#/components/schemas/Device_response',
  'x-schema-type': 'response',
};
function validate33(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.ID === undefined && (missing0 = 'ID')) {
        validate33.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema18.required,
            parentSchema: schema18,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate33.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema18.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate33.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema18.properties.ID.type,
                    parentSchema: schema18.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate33.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema18.type,
          parentSchema: schema18,
          data,
        },
      ];
      return false;
    }
  }
  validate33.errors = vErrors;
  return errors === 0;
}
exports.validateExperimentRequest = validate34;
const schema19 = {
  title: 'Experiment',
  description:
    'An experiment describes a set of devices and how they should be connected (potentially among other metadata).',
  type: 'object',
  required: ['Devices'],
  properties: {
    Devices: {
      type: 'array',
      description: 'List of devices used in experiment.',
      items: {
        title: 'Device',
        description:
          'A device might either be a physical/virtual device or a group of device.',
        type: 'object',
        required: ['ID'],
        properties: {
          ID: {
            type: 'string',
            description:
              'Unique ID of the device. Contains the institution (by having an end point at that institution)',
            format: 'uri',
          },
        },
      },
    },
    Description: {
      type: 'string',
      description:
        'User provided description, for example might be a reason for the booking (e.g. maintenance) or a link to the experiment. Might be empty or missing.\n',
    },
  },
  'x-standalone': true,
  'x-name': 'ExperimentRequest',
  'x-location': '#/components/schemas/Experiment_request',
  'x-schema-type': 'request',
};
function validate34(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.Devices === undefined && (missing0 = 'Devices')) {
        validate34.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema19.required,
            parentSchema: schema19,
            data,
          },
        ];
        return false;
      } else {
        if (data.Devices !== undefined) {
          let data0 = data.Devices;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (Array.isArray(data0)) {
              var valid1 = true;
              const len0 = data0.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data1 = data0[i0];
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                    let missing1;
                    if (data1.ID === undefined && (missing1 = 'ID')) {
                      validate34.errors = [
                        {
                          instancePath: instancePath + '/Devices/' + i0,
                          schemaPath: '#/properties/Devices/items/required',
                          keyword: 'required',
                          params: { missingProperty: missing1 },
                          message: "must have required property '" + missing1 + "'",
                          schema: schema19.properties.Devices.items.required,
                          parentSchema: schema19.properties.Devices.items,
                          data: data1,
                        },
                      ];
                      return false;
                    } else {
                      if (data1.ID !== undefined) {
                        let data2 = data1.ID;
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (errors === _errs5) {
                            if (typeof data2 === 'string') {
                              if (!formats0(data2)) {
                                validate34.errors = [
                                  {
                                    instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                    schemaPath:
                                      '#/properties/Devices/items/properties/ID/format',
                                    keyword: 'format',
                                    params: { format: 'uri' },
                                    message: 'must match format "' + 'uri' + '"',
                                    schema: 'uri',
                                    parentSchema:
                                      schema19.properties.Devices.items.properties.ID,
                                    data: data2,
                                  },
                                ];
                                return false;
                              }
                            } else {
                              validate34.errors = [
                                {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/properties/Devices/items/properties/ID/type',
                                  keyword: 'type',
                                  params: { type: 'string' },
                                  message: 'must be string',
                                  schema:
                                    schema19.properties.Devices.items.properties.ID.type,
                                  parentSchema:
                                    schema19.properties.Devices.items.properties.ID,
                                  data: data2,
                                },
                              ];
                              return false;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate34.errors = [
                      {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/properties/Devices/items/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                        schema: schema19.properties.Devices.items.type,
                        parentSchema: schema19.properties.Devices.items,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                }
                var valid1 = _errs3 === errors;
                if (!valid1) {
                  break;
                }
              }
            } else {
              validate34.errors = [
                {
                  instancePath: instancePath + '/Devices',
                  schemaPath: '#/properties/Devices/type',
                  keyword: 'type',
                  params: { type: 'array' },
                  message: 'must be array',
                  schema: schema19.properties.Devices.type,
                  parentSchema: schema19.properties.Devices,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Description !== undefined) {
            let data3 = data.Description;
            const _errs7 = errors;
            if (typeof data3 !== 'string') {
              validate34.errors = [
                {
                  instancePath: instancePath + '/Description',
                  schemaPath: '#/properties/Description/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema19.properties.Description.type,
                  parentSchema: schema19.properties.Description,
                  data: data3,
                },
              ];
              return false;
            }
            var valid0 = _errs7 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate34.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema19.type,
          parentSchema: schema19,
          data,
        },
      ];
      return false;
    }
  }
  validate34.errors = vErrors;
  return errors === 0;
}
exports.validateExperimentResponse = validate35;
const schema20 = {
  title: 'Experiment',
  description:
    'An experiment describes a set of devices and how they should be connected (potentially among other metadata).',
  type: 'object',
  required: ['Devices'],
  properties: {
    Devices: {
      type: 'array',
      description: 'List of devices used in experiment.',
      items: {
        title: 'Device',
        description:
          'A device might either be a physical/virtual device or a group of device.',
        type: 'object',
        required: ['ID'],
        properties: {
          ID: {
            type: 'string',
            description:
              'Unique ID of the device. Contains the institution (by having an end point at that institution)',
            format: 'uri',
          },
        },
      },
    },
    Description: {
      type: 'string',
      description:
        'User provided description, for example might be a reason for the booking (e.g. maintenance) or a link to the experiment. Might be empty or missing.\n',
    },
  },
  'x-standalone': true,
  'x-name': 'ExperimentResponse',
  'x-location': '#/components/schemas/Experiment_response',
  'x-schema-type': 'response',
};
function validate35(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.Devices === undefined && (missing0 = 'Devices')) {
        validate35.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema20.required,
            parentSchema: schema20,
            data,
          },
        ];
        return false;
      } else {
        if (data.Devices !== undefined) {
          let data0 = data.Devices;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (Array.isArray(data0)) {
              var valid1 = true;
              const len0 = data0.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data1 = data0[i0];
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                    let missing1;
                    if (data1.ID === undefined && (missing1 = 'ID')) {
                      validate35.errors = [
                        {
                          instancePath: instancePath + '/Devices/' + i0,
                          schemaPath: '#/properties/Devices/items/required',
                          keyword: 'required',
                          params: { missingProperty: missing1 },
                          message: "must have required property '" + missing1 + "'",
                          schema: schema20.properties.Devices.items.required,
                          parentSchema: schema20.properties.Devices.items,
                          data: data1,
                        },
                      ];
                      return false;
                    } else {
                      if (data1.ID !== undefined) {
                        let data2 = data1.ID;
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (errors === _errs5) {
                            if (typeof data2 === 'string') {
                              if (!formats0(data2)) {
                                validate35.errors = [
                                  {
                                    instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                    schemaPath:
                                      '#/properties/Devices/items/properties/ID/format',
                                    keyword: 'format',
                                    params: { format: 'uri' },
                                    message: 'must match format "' + 'uri' + '"',
                                    schema: 'uri',
                                    parentSchema:
                                      schema20.properties.Devices.items.properties.ID,
                                    data: data2,
                                  },
                                ];
                                return false;
                              }
                            } else {
                              validate35.errors = [
                                {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/properties/Devices/items/properties/ID/type',
                                  keyword: 'type',
                                  params: { type: 'string' },
                                  message: 'must be string',
                                  schema:
                                    schema20.properties.Devices.items.properties.ID.type,
                                  parentSchema:
                                    schema20.properties.Devices.items.properties.ID,
                                  data: data2,
                                },
                              ];
                              return false;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate35.errors = [
                      {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/properties/Devices/items/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                        schema: schema20.properties.Devices.items.type,
                        parentSchema: schema20.properties.Devices.items,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                }
                var valid1 = _errs3 === errors;
                if (!valid1) {
                  break;
                }
              }
            } else {
              validate35.errors = [
                {
                  instancePath: instancePath + '/Devices',
                  schemaPath: '#/properties/Devices/type',
                  keyword: 'type',
                  params: { type: 'array' },
                  message: 'must be array',
                  schema: schema20.properties.Devices.type,
                  parentSchema: schema20.properties.Devices,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Description !== undefined) {
            let data3 = data.Description;
            const _errs7 = errors;
            if (typeof data3 !== 'string') {
              validate35.errors = [
                {
                  instancePath: instancePath + '/Description',
                  schemaPath: '#/properties/Description/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema20.properties.Description.type,
                  parentSchema: schema20.properties.Description,
                  data: data3,
                },
              ];
              return false;
            }
            var valid0 = _errs7 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate35.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema20.type,
          parentSchema: schema20,
          data,
        },
      ];
      return false;
    }
  }
  validate35.errors = vErrors;
  return errors === 0;
}
exports.validateTimeslotRequest = validate36;
const schema21 = {
  title: 'Timeslot',
  description: 'A time slot represents a slice of time used for bookings.',
  type: 'object',
  required: ['Start', 'End'],
  properties: {
    Start: {
      type: 'string',
      description: 'Start time of the booking.',
      format: 'date-time',
    },
    End: { type: 'string', description: 'End time of the booking.', format: 'date-time' },
  },
  'x-standalone': true,
  'x-name': 'TimeslotRequest',
  'x-location': '#/components/schemas/Timeslot_request',
  'x-schema-type': 'request',
};
function validate36(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Start === undefined && (missing0 = 'Start')) ||
        (data.End === undefined && (missing0 = 'End'))
      ) {
        validate36.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema21.required,
            parentSchema: schema21,
            data,
          },
        ];
        return false;
      } else {
        if (data.Start !== undefined) {
          let data0 = data.Start;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats2.validate(data0)) {
                  validate36.errors = [
                    {
                      instancePath: instancePath + '/Start',
                      schemaPath: '#/properties/Start/format',
                      keyword: 'format',
                      params: { format: 'date-time' },
                      message: 'must match format "' + 'date-time' + '"',
                      schema: 'date-time',
                      parentSchema: schema21.properties.Start,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate36.errors = [
                  {
                    instancePath: instancePath + '/Start',
                    schemaPath: '#/properties/Start/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema21.properties.Start.type,
                    parentSchema: schema21.properties.Start,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.End !== undefined) {
            let data1 = data.End;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (errors === _errs3) {
                if (typeof data1 === 'string') {
                  if (!formats2.validate(data1)) {
                    validate36.errors = [
                      {
                        instancePath: instancePath + '/End',
                        schemaPath: '#/properties/End/format',
                        keyword: 'format',
                        params: { format: 'date-time' },
                        message: 'must match format "' + 'date-time' + '"',
                        schema: 'date-time',
                        parentSchema: schema21.properties.End,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                } else {
                  validate36.errors = [
                    {
                      instancePath: instancePath + '/End',
                      schemaPath: '#/properties/End/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema21.properties.End.type,
                      parentSchema: schema21.properties.End,
                      data: data1,
                    },
                  ];
                  return false;
                }
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate36.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema21.type,
          parentSchema: schema21,
          data,
        },
      ];
      return false;
    }
  }
  validate36.errors = vErrors;
  return errors === 0;
}
exports.validateTimeslotResponse = validate37;
const schema22 = {
  title: 'Timeslot',
  description: 'A time slot represents a slice of time used for bookings.',
  type: 'object',
  required: ['Start', 'End'],
  properties: {
    Start: {
      type: 'string',
      description: 'Start time of the booking.',
      format: 'date-time',
    },
    End: { type: 'string', description: 'End time of the booking.', format: 'date-time' },
  },
  'x-standalone': true,
  'x-name': 'TimeslotResponse',
  'x-location': '#/components/schemas/Timeslot_response',
  'x-schema-type': 'response',
};
function validate37(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Start === undefined && (missing0 = 'Start')) ||
        (data.End === undefined && (missing0 = 'End'))
      ) {
        validate37.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema22.required,
            parentSchema: schema22,
            data,
          },
        ];
        return false;
      } else {
        if (data.Start !== undefined) {
          let data0 = data.Start;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats2.validate(data0)) {
                  validate37.errors = [
                    {
                      instancePath: instancePath + '/Start',
                      schemaPath: '#/properties/Start/format',
                      keyword: 'format',
                      params: { format: 'date-time' },
                      message: 'must match format "' + 'date-time' + '"',
                      schema: 'date-time',
                      parentSchema: schema22.properties.Start,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate37.errors = [
                  {
                    instancePath: instancePath + '/Start',
                    schemaPath: '#/properties/Start/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema22.properties.Start.type,
                    parentSchema: schema22.properties.Start,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.End !== undefined) {
            let data1 = data.End;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (errors === _errs3) {
                if (typeof data1 === 'string') {
                  if (!formats2.validate(data1)) {
                    validate37.errors = [
                      {
                        instancePath: instancePath + '/End',
                        schemaPath: '#/properties/End/format',
                        keyword: 'format',
                        params: { format: 'date-time' },
                        message: 'must match format "' + 'date-time' + '"',
                        schema: 'date-time',
                        parentSchema: schema22.properties.End,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                } else {
                  validate37.errors = [
                    {
                      instancePath: instancePath + '/End',
                      schemaPath: '#/properties/End/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema22.properties.End.type,
                      parentSchema: schema22.properties.End,
                      data: data1,
                    },
                  ];
                  return false;
                }
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate37.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema22.type,
          parentSchema: schema22,
          data,
        },
      ];
      return false;
    }
  }
  validate37.errors = vErrors;
  return errors === 0;
}
exports.validateIDRequest = validate38;
const schema23 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'IDRequest',
  'x-location': '#/components/parameters/ID/schema_request',
  'x-schema-type': 'request',
};
function validate38(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate38.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema23.type,
        parentSchema: schema23,
        data,
      },
    ];
    return false;
  }
  validate38.errors = vErrors;
  return errors === 0;
}
exports.validateIDResponse = validate39;
const schema24 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'IDResponse',
  'x-location': '#/components/parameters/ID/schema_response',
  'x-schema-type': 'response',
};
function validate39(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate39.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema24.type,
        parentSchema: schema24,
        data,
      },
    ];
    return false;
  }
  validate39.errors = vErrors;
  return errors === 0;
}
exports.validateLockBookingResponse200Request = validate40;
const schema25 = {
  type: 'array',
  description:
    'The list of booked devices and selected real devices. Order is guaranteed to be the same as in the booking.',
  items: {
    type: 'object',
    required: ['Requested', 'Selected'],
    properties: {
      Requested: { type: 'string', format: 'uri' },
      Selected: { type: 'string', format: 'uri' },
    },
  },
  'x-standalone': false,
  'x-name': 'lockBookingResponse200Request',
  'x-location':
    '#/paths//booking/{ID}/lock/put/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate40(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.Requested === undefined && (missing0 = 'Requested')) ||
              (data0.Selected === undefined && (missing0 = 'Selected'))
            ) {
              validate40.errors = [
                {
                  instancePath: instancePath + '/' + i0,
                  schemaPath: '#/items/required',
                  keyword: 'required',
                  params: { missingProperty: missing0 },
                  message: "must have required property '" + missing0 + "'",
                  schema: schema25.items.required,
                  parentSchema: schema25.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.Requested !== undefined) {
                let data1 = data0.Requested;
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (errors === _errs3) {
                    if (typeof data1 === 'string') {
                      if (!formats0(data1)) {
                        validate40.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/Requested',
                            schemaPath: '#/items/properties/Requested/format',
                            keyword: 'format',
                            params: { format: 'uri' },
                            message: 'must match format "' + 'uri' + '"',
                            schema: 'uri',
                            parentSchema: schema25.items.properties.Requested,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    } else {
                      validate40.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/Requested',
                          schemaPath: '#/items/properties/Requested/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema25.items.properties.Requested.type,
                          parentSchema: schema25.items.properties.Requested,
                          data: data1,
                        },
                      ];
                      return false;
                    }
                  }
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.Selected !== undefined) {
                  let data2 = data0.Selected;
                  const _errs5 = errors;
                  if (errors === _errs5) {
                    if (errors === _errs5) {
                      if (typeof data2 === 'string') {
                        if (!formats0(data2)) {
                          validate40.errors = [
                            {
                              instancePath: instancePath + '/' + i0 + '/Selected',
                              schemaPath: '#/items/properties/Selected/format',
                              keyword: 'format',
                              params: { format: 'uri' },
                              message: 'must match format "' + 'uri' + '"',
                              schema: 'uri',
                              parentSchema: schema25.items.properties.Selected,
                              data: data2,
                            },
                          ];
                          return false;
                        }
                      } else {
                        validate40.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/Selected',
                            schemaPath: '#/items/properties/Selected/type',
                            keyword: 'type',
                            params: { type: 'string' },
                            message: 'must be string',
                            schema: schema25.items.properties.Selected.type,
                            parentSchema: schema25.items.properties.Selected,
                            data: data2,
                          },
                        ];
                        return false;
                      }
                    }
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
              }
            }
          } else {
            validate40.errors = [
              {
                instancePath: instancePath + '/' + i0,
                schemaPath: '#/items/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema25.items.type,
                parentSchema: schema25.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate40.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
          schema: schema25.type,
          parentSchema: schema25,
          data,
        },
      ];
      return false;
    }
  }
  validate40.errors = vErrors;
  return errors === 0;
}
exports.validateLockBookingResponse200Response = validate41;
const schema26 = {
  type: 'array',
  description:
    'The list of booked devices and selected real devices. Order is guaranteed to be the same as in the booking.',
  items: {
    type: 'object',
    required: ['Requested', 'Selected'],
    properties: {
      Requested: { type: 'string', format: 'uri' },
      Selected: { type: 'string', format: 'uri' },
    },
  },
  'x-standalone': false,
  'x-name': 'lockBookingResponse200Response',
  'x-location':
    '#/paths//booking/{ID}/lock/put/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate41(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      var valid0 = true;
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs1 = errors;
        if (errors === _errs1) {
          if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
            let missing0;
            if (
              (data0.Requested === undefined && (missing0 = 'Requested')) ||
              (data0.Selected === undefined && (missing0 = 'Selected'))
            ) {
              validate41.errors = [
                {
                  instancePath: instancePath + '/' + i0,
                  schemaPath: '#/items/required',
                  keyword: 'required',
                  params: { missingProperty: missing0 },
                  message: "must have required property '" + missing0 + "'",
                  schema: schema26.items.required,
                  parentSchema: schema26.items,
                  data: data0,
                },
              ];
              return false;
            } else {
              if (data0.Requested !== undefined) {
                let data1 = data0.Requested;
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (errors === _errs3) {
                    if (typeof data1 === 'string') {
                      if (!formats0(data1)) {
                        validate41.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/Requested',
                            schemaPath: '#/items/properties/Requested/format',
                            keyword: 'format',
                            params: { format: 'uri' },
                            message: 'must match format "' + 'uri' + '"',
                            schema: 'uri',
                            parentSchema: schema26.items.properties.Requested,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    } else {
                      validate41.errors = [
                        {
                          instancePath: instancePath + '/' + i0 + '/Requested',
                          schemaPath: '#/items/properties/Requested/type',
                          keyword: 'type',
                          params: { type: 'string' },
                          message: 'must be string',
                          schema: schema26.items.properties.Requested.type,
                          parentSchema: schema26.items.properties.Requested,
                          data: data1,
                        },
                      ];
                      return false;
                    }
                  }
                }
                var valid1 = _errs3 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data0.Selected !== undefined) {
                  let data2 = data0.Selected;
                  const _errs5 = errors;
                  if (errors === _errs5) {
                    if (errors === _errs5) {
                      if (typeof data2 === 'string') {
                        if (!formats0(data2)) {
                          validate41.errors = [
                            {
                              instancePath: instancePath + '/' + i0 + '/Selected',
                              schemaPath: '#/items/properties/Selected/format',
                              keyword: 'format',
                              params: { format: 'uri' },
                              message: 'must match format "' + 'uri' + '"',
                              schema: 'uri',
                              parentSchema: schema26.items.properties.Selected,
                              data: data2,
                            },
                          ];
                          return false;
                        }
                      } else {
                        validate41.errors = [
                          {
                            instancePath: instancePath + '/' + i0 + '/Selected',
                            schemaPath: '#/items/properties/Selected/type',
                            keyword: 'type',
                            params: { type: 'string' },
                            message: 'must be string',
                            schema: schema26.items.properties.Selected.type,
                            parentSchema: schema26.items.properties.Selected,
                            data: data2,
                          },
                        ];
                        return false;
                      }
                    }
                  }
                  var valid1 = _errs5 === errors;
                } else {
                  var valid1 = true;
                }
              }
            }
          } else {
            validate41.errors = [
              {
                instancePath: instancePath + '/' + i0,
                schemaPath: '#/items/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
                schema: schema26.items.type,
                parentSchema: schema26.items,
                data: data0,
              },
            ];
            return false;
          }
        }
        var valid0 = _errs1 === errors;
        if (!valid0) {
          break;
        }
      }
    } else {
      validate41.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
          schema: schema26.type,
          parentSchema: schema26,
          data,
        },
      ];
      return false;
    }
  }
  validate41.errors = vErrors;
  return errors === 0;
}
exports.validateLockBookingResponse500Request = validate42;
const schema27 = {
  type: 'string',
  description: 'Error string',
  'x-standalone': false,
  'x-name': 'lockBookingResponse500Request',
  'x-location':
    '#/paths//booking/{ID}/lock/put/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate42(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate42.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema27.type,
        parentSchema: schema27,
        data,
      },
    ];
    return false;
  }
  validate42.errors = vErrors;
  return errors === 0;
}
exports.validateLockBookingResponse500Response = validate43;
const schema28 = {
  type: 'string',
  description: 'Error string',
  'x-standalone': false,
  'x-name': 'lockBookingResponse500Response',
  'x-location':
    '#/paths//booking/{ID}/lock/put/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate43(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate43.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema28.type,
        parentSchema: schema28,
        data,
      },
    ];
    return false;
  }
  validate43.errors = vErrors;
  return errors === 0;
}
exports.validateUnlockBookingResponse500Request = validate44;
const schema29 = {
  type: 'string',
  description: 'Error description.',
  'x-standalone': false,
  'x-name': 'unlockBookingResponse500Request',
  'x-location':
    '#/paths//booking/{ID}/lock/delete/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate44(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate44.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema29.type,
        parentSchema: schema29,
        data,
      },
    ];
    return false;
  }
  validate44.errors = vErrors;
  return errors === 0;
}
exports.validateUnlockBookingResponse500Response = validate45;
const schema30 = {
  type: 'string',
  description: 'Error description.',
  'x-standalone': false,
  'x-name': 'unlockBookingResponse500Response',
  'x-location':
    '#/paths//booking/{ID}/lock/delete/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate45(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate45.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema30.type,
        parentSchema: schema30,
        data,
      },
    ];
    return false;
  }
  validate45.errors = vErrors;
  return errors === 0;
}
exports.validateBookingCallbackResponse500Request = validate46;
const schema31 = {
  type: 'string',
  description: 'Error description.',
  'x-standalone': false,
  'x-name': 'bookingCallbackResponse500Request',
  'x-location':
    '#/paths//booking_callback/{ID}/post/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate46(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate46.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema31.type,
        parentSchema: schema31,
        data,
      },
    ];
    return false;
  }
  validate46.errors = vErrors;
  return errors === 0;
}
exports.validateBookingCallbackResponse500Response = validate47;
const schema32 = {
  type: 'string',
  description: 'Error description.',
  'x-standalone': false,
  'x-name': 'bookingCallbackResponse500Response',
  'x-location':
    '#/paths//booking_callback/{ID}/post/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate47(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate47.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema32.type,
        parentSchema: schema32,
        data,
      },
    ];
    return false;
  }
  validate47.errors = vErrors;
  return errors === 0;
}
