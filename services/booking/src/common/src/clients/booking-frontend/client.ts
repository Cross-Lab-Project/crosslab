/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */

/* eslint-disable @typescript-eslint/no-unused-vars */

/* eslint-disable @typescript-eslint/ban-ts-comment */
import fetch, { RequestInfo, RequestInit, Response } from 'node-fetch';

import * as RequestValidation from './requestValidation.js';
import * as Signatures from './signatures.js';
import * as Types from './types.js';
// @ts-ignore
import { type Require } from './types.js';

/**
 * This error class should be used if an error occurs during validation of a request/response.
 * @category Errors
 */
export class ValidationError extends Error {
  public errors: unknown;

  constructor(message: string, errors: unknown) {
    super(message);
    this.name = 'ValidationError';
    this.errors = errors;
  }
}

/**
 * This error class should be used if an error occurs while fetching a request.
 * @category Errors
 */
export class FetchError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'FetchError';
  }
}

/**
 * This error class should be used if the response of the server has a status
 * greater than or equal to 400. This error should contain the validated response.
 * @category Errors
 */
export class UnsuccessfulRequestError extends Error {
  public response: Types.ResponseData;

  constructor(message: string, response: Types.ResponseData) {
    super(message);
    this.response = response;
    this.name = 'UnsuccessfulRequestError';
  }
}

/**
 * This error class should be used if the validation of an url fails.
 * @category Errors
 */
export class InvalidUrlError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InvalidUrlError';
  }
}

/**
 * This function attempts to parse a Response as ResponseData.
 */
async function parseResponse(response: Response): Promise<Types.ResponseData> {
  let text = null;
  try {
    text = await response.text();
    const json = JSON.parse(text);
    return { status: response.status, body: json };
  } catch {
    return { status: response.status, body: text };
  }
}

/**
 * This function checks if a string is a valid http url.
 * @param string The string to be checked.
 * @returns True if the string is a valid http url.
 */
function isValidHttpUrl(string: string) {
  let url;

  try {
    url = new URL(string);
  } catch (_) {
    return false;
  }

  return url.protocol === 'http:' || url.protocol === 'https:';
}

/**
 * This function takes an url and a pattern for the requested endpoint and parses the contained path parameters.
 * @param url The url to be parsed.
 * @param endpoint Pattern of the requested endpoint.
 * @throws {InvalidUrlError} Thrown if the provided url does not end with the provided endpoint.
 * @returns An array containing all parsed path parameters in order of appearance.
 * @example
 * // returns ["username", "role_name"]
 * parsePathParameters("https://api.example.com/users/username/roles/role_name", "/users/{}/roles/{}")
 */
function parsePathParameters(url: string, endpoint: string): string[] {
  const parameterRegex = '([a-zA-Z0-9-:]+)';
  const regex = new RegExp(endpoint.replaceAll('{}', parameterRegex) + '(?:.(?!\\\\))?$');
  const matches = url.match(regex);

  if (!matches) throw new InvalidUrlError('Url does not end with the provided endpoint');

  return matches.slice(1);
}

/**
 * This function validates a given http url and parses its path parameters.
 * @param url The url to be validated.
 * @param endpoint Pattern of the requested endpoint.
 * @throws {InvalidUrlError} Thrown if the validation of the provided url fails.
 * @returns An array containing all parsed path parameters in order of appearance (see {@link parsePathParameters}).
 * @example
 * // returns ["username", "role_name"]
 * validateUrl("https://api.example.com/users/username/roles/role_name", "/users/{}/roles/{}")
 */
function validateUrl(url: string, baseUrl: string, endpoint: string): string[] {
  if (!isValidHttpUrl(url))
    throw new InvalidUrlError(`Provided url "${url}" is not a valid http url`);
  if (!url.startsWith(baseUrl))
    throw new InvalidUrlError(
      `Provided url "${url}" does not start with the provided base url "${baseUrl}"`,
    );
  const pathParameters = parsePathParameters(url, endpoint);

  let extendedBaseUrl = baseUrl + endpoint;

  pathParameters.forEach(pathParameter => {
    extendedBaseUrl = extendedBaseUrl.replace('{}', pathParameter);
  });

  if (url !== extendedBaseUrl)
    throw new InvalidUrlError(
      `Provided url "${url}" does not match extended base url "${extendedBaseUrl}"`,
    );

  return pathParameters;
}

/**
 * This function appends a given endpoint to an url.
 * @param url The url to append the endpoint to.
 * @param endpoint The endpoint to be appended.
 * @example
 * // returns "https://api.example.com/devices/device_id/token"
 * appendToUrl("https://api.example.com/devices/device_id", "/token")
 * @example
 * // returns "https://api.example.com/devices/device_id/token"
 * appendToUrl("https://api.example.com/devices/device_id/", "/token")
 * @returns The url with the appended endpoint.
 */
function appendToUrl(url: string, endpoint: string) {
  return url.endsWith('/') ? `${url.slice(0, -1)}${endpoint}` : `${url}${endpoint}`;
}

/**
 * Client for the use of the Crosslab API
 * @category Client
 */
export class Client {
  public readonly baseUrl: string;
  public readonly serviceUrl: string;
  public accessToken: string;
  private fixedHeaders: [string, string][];
  private fetch = async (url: RequestInfo | URL, init: RequestInit) => {
    let raw_response;
    const parsedUrl = new URL(url.toString());
    try {
      if (
        parsedUrl.toString().startsWith(this.baseUrl) ||
        parsedUrl.toString().startsWith(this.serviceUrl)
      ) {
        raw_response = await fetch(url, init);
      } else {
        raw_response = await fetch(
          appendToUrl(
            this.baseUrl,
            '/proxy?' + new URLSearchParams([['URL', url.toString()]]).toString(),
          ),
          init,
        );
      }
    } catch (error) {
      if (error instanceof Error) {
        throw new FetchError(error.message);
      } else if (typeof error === 'string') {
        throw new FetchError(error);
      } else {
        throw new FetchError('Something went wrong while trying to fetch the request');
      }
    }
    return await parseResponse(raw_response);
  };

  /**
   * @category Constructors
   */
  constructor(
    baseUrl: string,
    options: {
      serviceUrl?: string;
      accessToken?: string;
      fixedHeaders?: [string, string][];
    },
  ) {
    this.baseUrl = new URL(baseUrl).toString().slice(0, -1);
    this.serviceUrl = new URL(options.serviceUrl ?? this.baseUrl).toString().slice(0, -1);
    this.accessToken = options.accessToken ?? '';
    this.fixedHeaders = options.fixedHeaders ?? [];
  }

  /**
   * Books an experiment.
   *
   * @param body
   * @param options.url
   * Url of the  to be used.
   *
   * @throws {@link FetchError | FetchError }
   * Thrown if fetch fails.
   * @throws {@link ValidationError | ValidationError }
   * Thrown if the request/response validation fails.
   * @throws {@link InvalidUrlError | InvalidUrlError }
   * Thrown if the provided url is not valid for this request.
   * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError }
   * Thrown if response is validated but has status greater than or equal to 400.
   *
   * @returns
   * The booking was accepted. The booking status will display whether the booking of all devices was successful.
   */
  public async newBooking(
    body: {
      /**
       * List of devices which should be added.
       */
      Devices: Types.Device<'request'>[];
      /**
       * A time slot represents a slice of time used for bookings.
       */
      Time: Types.Timeslot<'request'>;
      /**
       * Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.
       */
      Type?: 'normal';
      [k: string]: unknown;
    },
    options?: {
      headers?: [string, string][];
      url?: string;
    },
  ): Promise<Signatures.NewBookingSuccessResponse['body']> {
    const url = appendToUrl(options?.url ?? this.baseUrl, '/booking');
    console.log('trying to fetch url:', url);

    if (!RequestValidation.validateNewBookingInput(body))
      throw new ValidationError(
        'Request validation failed!',
        (RequestValidation.validateNewBookingInput as Types.FunctionWithErrors).errors,
      );

    const authorization: string = `Bearer ${this.accessToken}`;

    console.log(
      'trying to fetch url:',
      new URL(url).toString().replace(this.baseUrl, this.serviceUrl),
    );
    const response = await this.fetch(
      new URL(url).toString().replace(this.baseUrl, this.serviceUrl),
      {
        method: 'POST',
        headers: [
          ['Content-Type', 'application/json'],
          ['Authorization', authorization],
          ...this.fixedHeaders,
          ...(options?.headers ?? []),
        ],
        body: JSON.stringify(body),
      },
    );

    if (!RequestValidation.validateNewBookingOutput(response))
      throw new ValidationError(
        'Response validation failed!',
        (RequestValidation.validateNewBookingOutput as Types.FunctionWithErrors).errors,
      );

    if (Types.isErrorResponse(response))
      throw new UnsuccessfulRequestError(
        `Server returned response with status ${response.status}`,
        response,
      );

    return response.body;
  }

  /**
     * Allows the addition of devices to a booking (removing of devices is not supportet) or the registration of callbacks. For adding devices, the scope 'booking:use' is required.
 
	 * 
	 * @param url
	 * Url of the resource to be accessed.
	 * @param body
     *
     * @throws {@link FetchError | FetchError } 
     * Thrown if fetch fails.
     * @throws {@link ValidationError | ValidationError } 
     * Thrown if the request/response validation fails.
     * @throws {@link InvalidUrlError | InvalidUrlError } 
     * Thrown if the provided url is not valid for this request.
     * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError } 
     * Thrown if response is validated but has status greater than or equal to 400.
     * 
     * @returns
	 * The booking change was accepted. The booking status will display whether the booking of all devices was successful.
     */
  public async updateBooking(
    url: string,
    body:
      | {
          /**
           * Expresses whether the devices should be locked. Must match current status of booking. Is assumed to be false if not set.
           */
          Locked?: boolean;
          /**
           * List of devices which should be added.
           */
          Devices?: Types.Device<'request'>[];
          [k: string]: unknown;
        }
      | {
          /**
           * Callback which should be called at changes.
           */
          Callback?: string;
          [k: string]: unknown;
        },
    options?: {
      headers?: [string, string][];
    },
  ): Promise<Signatures.UpdateBookingSuccessResponse['body']> {
    const urlSuffix = '/booking/{}'.split('{}').at(-1) ?? '';
    if (urlSuffix && !url.endsWith(urlSuffix)) url = appendToUrl(url, urlSuffix);
    const [ID] = validateUrl(new URL(url).toString(), this.baseUrl, '/booking/{}');
    console.log('trying to fetch url:', url);

    const parameters = {
      ID: ID,
    };

    if (!RequestValidation.validateUpdateBookingInput(parameters, body))
      throw new ValidationError(
        'Request validation failed!',
        (RequestValidation.validateUpdateBookingInput as Types.FunctionWithErrors).errors,
      );

    const authorization: string = `Bearer ${this.accessToken}`;

    console.log(
      'trying to fetch url:',
      new URL(url).toString().replace(this.baseUrl, this.serviceUrl),
    );
    const response = await this.fetch(
      new URL(url).toString().replace(this.baseUrl, this.serviceUrl),
      {
        method: 'PATCH',
        headers: [
          ['Content-Type', 'application/json'],
          ['Authorization', authorization],
          ...this.fixedHeaders,
          ...(options?.headers ?? []),
        ],
        body: JSON.stringify(body),
      },
    );

    if (!RequestValidation.validateUpdateBookingOutput(response))
      throw new ValidationError(
        'Response validation failed!',
        (
          RequestValidation.validateUpdateBookingOutput as Types.FunctionWithErrors
        ).errors,
      );

    if (Types.isErrorResponse(response))
      throw new UnsuccessfulRequestError(
        `Server returned response with status ${response.status}`,
        response,
      );

    return response.body;
  }

  /**
   * Cancels a booking, as long as the booking was originally done by you.
   *
   * @param url
   * Url of the resource to be accessed.
   *
   * @throws {@link FetchError | FetchError }
   * Thrown if fetch fails.
   * @throws {@link ValidationError | ValidationError }
   * Thrown if the request/response validation fails.
   * @throws {@link InvalidUrlError | InvalidUrlError }
   * Thrown if the provided url is not valid for this request.
   * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError }
   * Thrown if response is validated but has status greater than or equal to 400.
   *
   * @returns
   * The booking was cancelled. All associated devices were released.
   */
  public async deleteBooking(
    url: string,
    options?: {
      headers?: [string, string][];
    },
  ): Promise<void> {
    const urlSuffix = '/booking/{}'.split('{}').at(-1) ?? '';
    if (urlSuffix && !url.endsWith(urlSuffix)) url = appendToUrl(url, urlSuffix);
    const [ID] = validateUrl(new URL(url).toString(), this.baseUrl, '/booking/{}');
    console.log('trying to fetch url:', url);

    const parameters = {
      ID: ID,
    };

    if (!RequestValidation.validateDeleteBookingInput(parameters))
      throw new ValidationError(
        'Request validation failed!',
        (RequestValidation.validateDeleteBookingInput as Types.FunctionWithErrors).errors,
      );

    const authorization: string = `Bearer ${this.accessToken}`;

    console.log(
      'trying to fetch url:',
      new URL(url).toString().replace(this.baseUrl, this.serviceUrl),
    );
    const response = await this.fetch(
      new URL(url).toString().replace(this.baseUrl, this.serviceUrl),
      {
        method: 'DELETE',
        headers: [
          ['Content-Type', 'application/json'],
          ['Authorization', authorization],
          ...this.fixedHeaders,
          ...(options?.headers ?? []),
        ],
      },
    );

    if (!RequestValidation.validateDeleteBookingOutput(response))
      throw new ValidationError(
        'Response validation failed!',
        (
          RequestValidation.validateDeleteBookingOutput as Types.FunctionWithErrors
        ).errors,
      );

    if (Types.isErrorResponse(response))
      throw new UnsuccessfulRequestError(
        `Server returned response with status ${response.status}`,
        response,
      );
  }

  /**
   * Returns whether a list of devices is currently booked for a user.
   *
   * @param url
   * Url of the resource to be accessed.
   *
   * @throws {@link FetchError | FetchError }
   * Thrown if fetch fails.
   * @throws {@link ValidationError | ValidationError }
   * Thrown if the request/response validation fails.
   * @throws {@link InvalidUrlError | InvalidUrlError }
   * Thrown if the provided url is not valid for this request.
   * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError }
   * Thrown if response is validated but has status greater than or equal to 400.
   *
   * @returns
   * Returns the current booking.
   */
  public async getBooking(
    url: string,
    options?: {
      headers?: [string, string][];
    },
  ): Promise<Signatures.GetBookingSuccessResponse['body']> {
    const urlSuffix = '/booking/{}'.split('{}').at(-1) ?? '';
    if (urlSuffix && !url.endsWith(urlSuffix)) url = appendToUrl(url, urlSuffix);
    const [ID] = validateUrl(new URL(url).toString(), this.baseUrl, '/booking/{}');
    console.log('trying to fetch url:', url);

    const parameters = {
      ID: ID,
    };

    if (!RequestValidation.validateGetBookingInput(parameters))
      throw new ValidationError(
        'Request validation failed!',
        (RequestValidation.validateGetBookingInput as Types.FunctionWithErrors).errors,
      );

    const authorization: string = `Bearer ${this.accessToken}`;

    console.log(
      'trying to fetch url:',
      new URL(url).toString().replace(this.baseUrl, this.serviceUrl),
    );
    const response = await this.fetch(
      new URL(url).toString().replace(this.baseUrl, this.serviceUrl),
      {
        method: 'GET',
        headers: [
          ['Content-Type', 'application/json'],
          ['Authorization', authorization],
          ...this.fixedHeaders,
          ...(options?.headers ?? []),
        ],
      },
    );

    if (!RequestValidation.validateGetBookingOutput(response))
      throw new ValidationError(
        'Response validation failed!',
        (RequestValidation.validateGetBookingOutput as Types.FunctionWithErrors).errors,
      );

    if (Types.isErrorResponse(response))
      throw new UnsuccessfulRequestError(
        `Server returned response with status ${response.status}`,
        response,
      );

    return response.body;
  }

  /**
   * Allows selected persons (like lab manager) to remove a user booking. To avoid mistakes, this is a different path than normal delete.
   *
   * @param url
   * Url of the resource to be accessed.
   *
   * @throws {@link FetchError | FetchError }
   * Thrown if fetch fails.
   * @throws {@link ValidationError | ValidationError }
   * Thrown if the request/response validation fails.
   * @throws {@link InvalidUrlError | InvalidUrlError }
   * Thrown if the provided url is not valid for this request.
   * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError }
   * Thrown if response is validated but has status greater than or equal to 400.
   *
   * @returns
   * The booking was cancelled. All associated devices were released.
   */
  public async destroyBooking(
    url: string,
    options?: {
      headers?: [string, string][];
    },
  ): Promise<void> {
    const urlSuffix = '/booking/{}/destroy'.split('{}').at(-1) ?? '';
    if (urlSuffix && !url.endsWith(urlSuffix)) url = appendToUrl(url, urlSuffix);
    const [ID] = validateUrl(
      new URL(url).toString(),
      this.baseUrl,
      '/booking/{}/destroy',
    );
    console.log('trying to fetch url:', url);

    const parameters = {
      ID: ID,
    };

    if (!RequestValidation.validateDestroyBookingInput(parameters))
      throw new ValidationError(
        'Request validation failed!',
        (
          RequestValidation.validateDestroyBookingInput as Types.FunctionWithErrors
        ).errors,
      );

    const authorization: string = `Bearer ${this.accessToken}`;

    console.log(
      'trying to fetch url:',
      new URL(url).toString().replace(this.baseUrl, this.serviceUrl),
    );
    const response = await this.fetch(
      new URL(url).toString().replace(this.baseUrl, this.serviceUrl),
      {
        method: 'DELETE',
        headers: [
          ['Content-Type', 'application/json'],
          ['Authorization', authorization],
          ...this.fixedHeaders,
          ...(options?.headers ?? []),
        ],
      },
    );

    if (!RequestValidation.validateDestroyBookingOutput(response))
      throw new ValidationError(
        'Response validation failed!',
        (
          RequestValidation.validateDestroyBookingOutput as Types.FunctionWithErrors
        ).errors,
      );

    if (Types.isErrorResponse(response))
      throw new UnsuccessfulRequestError(
        `Server returned response with status ${response.status}`,
        response,
      );
  }
}
