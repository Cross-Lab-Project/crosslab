/* eslint-disable */
//@ts-nocheck
/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */
'use strict';
exports.validateBooking = validate21;
const schema6 = {
  title: 'Booking',
  description: 'A booking in the booking system.',
  type: 'object',
  required: ['ID', 'Time', 'Devices', 'Status', 'You', 'External'],
  properties: {
    ID: { type: 'string', format: 'uri', description: 'Unique ID of the booking.' },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Devices: { type: 'array', items: { type: 'string', format: 'uri' } },
    Type: {
      description:
        "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
      type: 'string',
      enum: ['normal'],
    },
    Status: {
      description:
        "Current status of the booking. While the booking is pending, it can not be used. Will change automatically and can not be set by user. 'rejected' is set when the initial booking failed, 'cancelled' when the booking was deleted / cancelled after it was once active. The 'active-*' will be used when a device was added after the booking was locked.",
      type: 'string',
      enum: [
        'pending',
        'booked',
        'rejected',
        'cancelled',
        'active',
        'active-pending',
        'active-rejected',
      ],
    },
    You: { type: 'boolean', description: 'If true, this booking was done by you.' },
    External: {
      type: 'boolean',
      description: 'Shows whether the booking was done by an external institution.',
    },
    Message: {
      type: 'string',
      description:
        'User readable notes about the status of the booking (e.g. if devices are unknown).',
    },
  },
  'x-standalone': true,
  'x-name': 'Booking',
  'x-location': '#/components/schemas/Booking',
  'x-schema-type': 'all',
};
const formats0 = require('ajv-formats/dist/formats').fullFormats.uri;
const formats2 = require('ajv-formats/dist/formats').fullFormats['date-time'];
function validate21(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.ID === undefined && (missing0 = 'ID')) ||
        (data.Time === undefined && (missing0 = 'Time')) ||
        (data.Devices === undefined && (missing0 = 'Devices')) ||
        (data.Status === undefined && (missing0 = 'Status')) ||
        (data.You === undefined && (missing0 = 'You')) ||
        (data.External === undefined && (missing0 = 'External'))
      ) {
        validate21.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema6.required,
            parentSchema: schema6,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema6.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate21.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema6.properties.ID.type,
                    parentSchema: schema6.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data1 = data.Time;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                let missing1;
                if (
                  (data1.Start === undefined && (missing1 = 'Start')) ||
                  (data1.End === undefined && (missing1 = 'End'))
                ) {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing1 },
                      message: "must have required property '" + missing1 + "'",
                      schema: schema6.properties.Time.required,
                      parentSchema: schema6.properties.Time,
                      data: data1,
                    },
                  ];
                  return false;
                } else {
                  if (data1.Start !== undefined) {
                    let data2 = data1.Start;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (errors === _errs5) {
                        if (typeof data2 === 'string') {
                          if (!formats2.validate(data2)) {
                            validate21.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema6.properties.Time.properties.Start,
                                data: data2,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate21.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema6.properties.Time.properties.Start.type,
                              parentSchema: schema6.properties.Time.properties.Start,
                              data: data2,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data1.End !== undefined) {
                      let data3 = data1.End;
                      const _errs7 = errors;
                      if (errors === _errs7) {
                        if (errors === _errs7) {
                          if (typeof data3 === 'string') {
                            if (!formats2.validate(data3)) {
                              validate21.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema6.properties.Time.properties.End,
                                  data: data3,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate21.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema6.properties.Time.properties.End.type,
                                parentSchema: schema6.properties.Time.properties.End,
                                data: data3,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid1 = _errs7 === errors;
                    } else {
                      var valid1 = true;
                    }
                  }
                }
              } else {
                validate21.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema6.properties.Time.type,
                    parentSchema: schema6.properties.Time,
                    data: data1,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Devices !== undefined) {
              let data4 = data.Devices;
              const _errs9 = errors;
              if (errors === _errs9) {
                if (Array.isArray(data4)) {
                  var valid2 = true;
                  const len0 = data4.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data5 = data4[i0];
                    const _errs11 = errors;
                    if (errors === _errs11) {
                      if (errors === _errs11) {
                        if (typeof data5 === 'string') {
                          if (!formats0(data5)) {
                            validate21.errors = [
                              {
                                instancePath: instancePath + '/Devices/' + i0,
                                schemaPath: '#/properties/Devices/items/format',
                                keyword: 'format',
                                params: { format: 'uri' },
                                message: 'must match format "' + 'uri' + '"',
                                schema: 'uri',
                                parentSchema: schema6.properties.Devices.items,
                                data: data5,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate21.errors = [
                            {
                              instancePath: instancePath + '/Devices/' + i0,
                              schemaPath: '#/properties/Devices/items/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema6.properties.Devices.items.type,
                              parentSchema: schema6.properties.Devices.items,
                              data: data5,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid2 = _errs11 === errors;
                    if (!valid2) {
                      break;
                    }
                  }
                } else {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/Devices',
                      schemaPath: '#/properties/Devices/type',
                      keyword: 'type',
                      params: { type: 'array' },
                      message: 'must be array',
                      schema: schema6.properties.Devices.type,
                      parentSchema: schema6.properties.Devices,
                      data: data4,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs9 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.Type !== undefined) {
                let data6 = data.Type;
                const _errs13 = errors;
                if (typeof data6 !== 'string') {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema6.properties.Type.type,
                      parentSchema: schema6.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                if (!(data6 === 'normal')) {
                  validate21.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/enum',
                      keyword: 'enum',
                      params: { allowedValues: schema6.properties.Type.enum },
                      message: 'must be equal to one of the allowed values',
                      schema: schema6.properties.Type.enum,
                      parentSchema: schema6.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs13 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.Status !== undefined) {
                  let data7 = data.Status;
                  const _errs15 = errors;
                  if (typeof data7 !== 'string') {
                    validate21.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/type',
                        keyword: 'type',
                        params: { type: 'string' },
                        message: 'must be string',
                        schema: schema6.properties.Status.type,
                        parentSchema: schema6.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  if (
                    !(
                      data7 === 'pending' ||
                      data7 === 'booked' ||
                      data7 === 'rejected' ||
                      data7 === 'cancelled' ||
                      data7 === 'active' ||
                      data7 === 'active-pending' ||
                      data7 === 'active-rejected'
                    )
                  ) {
                    validate21.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/enum',
                        keyword: 'enum',
                        params: { allowedValues: schema6.properties.Status.enum },
                        message: 'must be equal to one of the allowed values',
                        schema: schema6.properties.Status.enum,
                        parentSchema: schema6.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  var valid0 = _errs15 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.You !== undefined) {
                    let data8 = data.You;
                    const _errs17 = errors;
                    if (typeof data8 !== 'boolean') {
                      validate21.errors = [
                        {
                          instancePath: instancePath + '/You',
                          schemaPath: '#/properties/You/type',
                          keyword: 'type',
                          params: { type: 'boolean' },
                          message: 'must be boolean',
                          schema: schema6.properties.You.type,
                          parentSchema: schema6.properties.You,
                          data: data8,
                        },
                      ];
                      return false;
                    }
                    var valid0 = _errs17 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.External !== undefined) {
                      let data9 = data.External;
                      const _errs19 = errors;
                      if (typeof data9 !== 'boolean') {
                        validate21.errors = [
                          {
                            instancePath: instancePath + '/External',
                            schemaPath: '#/properties/External/type',
                            keyword: 'type',
                            params: { type: 'boolean' },
                            message: 'must be boolean',
                            schema: schema6.properties.External.type,
                            parentSchema: schema6.properties.External,
                            data: data9,
                          },
                        ];
                        return false;
                      }
                      var valid0 = _errs19 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.Message !== undefined) {
                        let data10 = data.Message;
                        const _errs21 = errors;
                        if (typeof data10 !== 'string') {
                          validate21.errors = [
                            {
                              instancePath: instancePath + '/Message',
                              schemaPath: '#/properties/Message/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema6.properties.Message.type,
                              parentSchema: schema6.properties.Message,
                              data: data10,
                            },
                          ];
                          return false;
                        }
                        var valid0 = _errs21 === errors;
                      } else {
                        var valid0 = true;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate21.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema6.type,
          parentSchema: schema6,
          data,
        },
      ];
      return false;
    }
  }
  validate21.errors = vErrors;
  return errors === 0;
}
exports.validateDevice = validate22;
const schema7 = {
  title: 'Device',
  description: 'A device might either be a physical/virtual device or a group of device.',
  type: 'object',
  required: ['ID'],
  properties: {
    ID: {
      type: 'string',
      description:
        'Unique ID of the device. Contains the institution (by having an end point at that institution)',
      format: 'uri',
    },
  },
  'x-standalone': true,
  'x-name': 'Device',
  'x-location': '#/components/schemas/Device',
  'x-schema-type': 'all',
};
function validate22(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.ID === undefined && (missing0 = 'ID')) {
        validate22.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema7.required,
            parentSchema: schema7,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate22.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema7.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate22.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema7.properties.ID.type,
                    parentSchema: schema7.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate22.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema7.type,
          parentSchema: schema7,
          data,
        },
      ];
      return false;
    }
  }
  validate22.errors = vErrors;
  return errors === 0;
}
exports.validateExperiment = validate23;
const schema8 = {
  title: 'Experiment',
  description:
    'An experiment describes a set of devices and how they should be connected (potentially among other metadata).',
  type: 'object',
  required: ['Devices'],
  properties: {
    Devices: {
      type: 'array',
      description: 'List of devices used in experiment.',
      items: {
        title: 'Device',
        description:
          'A device might either be a physical/virtual device or a group of device.',
        type: 'object',
        required: ['ID'],
        properties: {
          ID: {
            type: 'string',
            description:
              'Unique ID of the device. Contains the institution (by having an end point at that institution)',
            format: 'uri',
          },
        },
      },
    },
    Description: {
      type: 'string',
      description:
        'User provided description, for example might be a reason for the booking (e.g. maintenance) or a link to the experiment. Might be empty or missing.',
    },
  },
  'x-standalone': true,
  'x-name': 'Experiment',
  'x-location': '#/components/schemas/Experiment',
  'x-schema-type': 'all',
};
function validate23(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.Devices === undefined && (missing0 = 'Devices')) {
        validate23.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema8.required,
            parentSchema: schema8,
            data,
          },
        ];
        return false;
      } else {
        if (data.Devices !== undefined) {
          let data0 = data.Devices;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (Array.isArray(data0)) {
              var valid1 = true;
              const len0 = data0.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data1 = data0[i0];
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                    let missing1;
                    if (data1.ID === undefined && (missing1 = 'ID')) {
                      validate23.errors = [
                        {
                          instancePath: instancePath + '/Devices/' + i0,
                          schemaPath: '#/properties/Devices/items/required',
                          keyword: 'required',
                          params: { missingProperty: missing1 },
                          message: "must have required property '" + missing1 + "'",
                          schema: schema8.properties.Devices.items.required,
                          parentSchema: schema8.properties.Devices.items,
                          data: data1,
                        },
                      ];
                      return false;
                    } else {
                      if (data1.ID !== undefined) {
                        let data2 = data1.ID;
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (errors === _errs5) {
                            if (typeof data2 === 'string') {
                              if (!formats0(data2)) {
                                validate23.errors = [
                                  {
                                    instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                    schemaPath:
                                      '#/properties/Devices/items/properties/ID/format',
                                    keyword: 'format',
                                    params: { format: 'uri' },
                                    message: 'must match format "' + 'uri' + '"',
                                    schema: 'uri',
                                    parentSchema:
                                      schema8.properties.Devices.items.properties.ID,
                                    data: data2,
                                  },
                                ];
                                return false;
                              }
                            } else {
                              validate23.errors = [
                                {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/properties/Devices/items/properties/ID/type',
                                  keyword: 'type',
                                  params: { type: 'string' },
                                  message: 'must be string',
                                  schema:
                                    schema8.properties.Devices.items.properties.ID.type,
                                  parentSchema:
                                    schema8.properties.Devices.items.properties.ID,
                                  data: data2,
                                },
                              ];
                              return false;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate23.errors = [
                      {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/properties/Devices/items/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                        schema: schema8.properties.Devices.items.type,
                        parentSchema: schema8.properties.Devices.items,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                }
                var valid1 = _errs3 === errors;
                if (!valid1) {
                  break;
                }
              }
            } else {
              validate23.errors = [
                {
                  instancePath: instancePath + '/Devices',
                  schemaPath: '#/properties/Devices/type',
                  keyword: 'type',
                  params: { type: 'array' },
                  message: 'must be array',
                  schema: schema8.properties.Devices.type,
                  parentSchema: schema8.properties.Devices,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Description !== undefined) {
            let data3 = data.Description;
            const _errs7 = errors;
            if (typeof data3 !== 'string') {
              validate23.errors = [
                {
                  instancePath: instancePath + '/Description',
                  schemaPath: '#/properties/Description/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema8.properties.Description.type,
                  parentSchema: schema8.properties.Description,
                  data: data3,
                },
              ];
              return false;
            }
            var valid0 = _errs7 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate23.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema8.type,
          parentSchema: schema8,
          data,
        },
      ];
      return false;
    }
  }
  validate23.errors = vErrors;
  return errors === 0;
}
exports.validateTimeslot = validate24;
const schema9 = {
  title: 'Timeslot',
  description: 'A time slot represents a slice of time used for bookings.',
  type: 'object',
  required: ['Start', 'End'],
  properties: {
    Start: {
      type: 'string',
      description: 'Start time of the booking.',
      format: 'date-time',
    },
    End: { type: 'string', description: 'End time of the booking.', format: 'date-time' },
  },
  'x-standalone': true,
  'x-name': 'Timeslot',
  'x-location': '#/components/schemas/Timeslot',
  'x-schema-type': 'all',
};
function validate24(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Start === undefined && (missing0 = 'Start')) ||
        (data.End === undefined && (missing0 = 'End'))
      ) {
        validate24.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema9.required,
            parentSchema: schema9,
            data,
          },
        ];
        return false;
      } else {
        if (data.Start !== undefined) {
          let data0 = data.Start;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats2.validate(data0)) {
                  validate24.errors = [
                    {
                      instancePath: instancePath + '/Start',
                      schemaPath: '#/properties/Start/format',
                      keyword: 'format',
                      params: { format: 'date-time' },
                      message: 'must match format "' + 'date-time' + '"',
                      schema: 'date-time',
                      parentSchema: schema9.properties.Start,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate24.errors = [
                  {
                    instancePath: instancePath + '/Start',
                    schemaPath: '#/properties/Start/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema9.properties.Start.type,
                    parentSchema: schema9.properties.Start,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.End !== undefined) {
            let data1 = data.End;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (errors === _errs3) {
                if (typeof data1 === 'string') {
                  if (!formats2.validate(data1)) {
                    validate24.errors = [
                      {
                        instancePath: instancePath + '/End',
                        schemaPath: '#/properties/End/format',
                        keyword: 'format',
                        params: { format: 'date-time' },
                        message: 'must match format "' + 'date-time' + '"',
                        schema: 'date-time',
                        parentSchema: schema9.properties.End,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                } else {
                  validate24.errors = [
                    {
                      instancePath: instancePath + '/End',
                      schemaPath: '#/properties/End/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema9.properties.End.type,
                      parentSchema: schema9.properties.End,
                      data: data1,
                    },
                  ];
                  return false;
                }
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate24.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema9.type,
          parentSchema: schema9,
          data,
        },
      ];
      return false;
    }
  }
  validate24.errors = vErrors;
  return errors === 0;
}
exports.validateID = validate25;
const schema10 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'ID',
  'x-location': '#/components/parameters/ID/schema',
  'x-schema-type': 'all',
};
function validate25(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate25.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema10.type,
        parentSchema: schema10,
        data,
      },
    ];
    return false;
  }
  validate25.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingBody = validate26;
const schema11 = {
  type: 'object',
  required: ['Devices', 'Time'],
  properties: {
    Devices: {
      type: 'array',
      description: 'List of devices which should be added.',
      items: {
        title: 'Device',
        description:
          'A device might either be a physical/virtual device or a group of device.',
        type: 'object',
        required: ['ID'],
        properties: {
          ID: {
            type: 'string',
            description:
              'Unique ID of the device. Contains the institution (by having an end point at that institution)',
            format: 'uri',
          },
        },
      },
    },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Type: {
      description:
        "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
      type: 'string',
      enum: ['normal'],
    },
  },
  'x-standalone': false,
  'x-name': 'newBookingBody',
  'x-location': '#/paths//booking/post/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate26(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Devices === undefined && (missing0 = 'Devices')) ||
        (data.Time === undefined && (missing0 = 'Time'))
      ) {
        validate26.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema11.required,
            parentSchema: schema11,
            data,
          },
        ];
        return false;
      } else {
        if (data.Devices !== undefined) {
          let data0 = data.Devices;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (Array.isArray(data0)) {
              var valid1 = true;
              const len0 = data0.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data1 = data0[i0];
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                    let missing1;
                    if (data1.ID === undefined && (missing1 = 'ID')) {
                      validate26.errors = [
                        {
                          instancePath: instancePath + '/Devices/' + i0,
                          schemaPath: '#/properties/Devices/items/required',
                          keyword: 'required',
                          params: { missingProperty: missing1 },
                          message: "must have required property '" + missing1 + "'",
                          schema: schema11.properties.Devices.items.required,
                          parentSchema: schema11.properties.Devices.items,
                          data: data1,
                        },
                      ];
                      return false;
                    } else {
                      if (data1.ID !== undefined) {
                        let data2 = data1.ID;
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (errors === _errs5) {
                            if (typeof data2 === 'string') {
                              if (!formats0(data2)) {
                                validate26.errors = [
                                  {
                                    instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                    schemaPath:
                                      '#/properties/Devices/items/properties/ID/format',
                                    keyword: 'format',
                                    params: { format: 'uri' },
                                    message: 'must match format "' + 'uri' + '"',
                                    schema: 'uri',
                                    parentSchema:
                                      schema11.properties.Devices.items.properties.ID,
                                    data: data2,
                                  },
                                ];
                                return false;
                              }
                            } else {
                              validate26.errors = [
                                {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/properties/Devices/items/properties/ID/type',
                                  keyword: 'type',
                                  params: { type: 'string' },
                                  message: 'must be string',
                                  schema:
                                    schema11.properties.Devices.items.properties.ID.type,
                                  parentSchema:
                                    schema11.properties.Devices.items.properties.ID,
                                  data: data2,
                                },
                              ];
                              return false;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate26.errors = [
                      {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/properties/Devices/items/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                        schema: schema11.properties.Devices.items.type,
                        parentSchema: schema11.properties.Devices.items,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                }
                var valid1 = _errs3 === errors;
                if (!valid1) {
                  break;
                }
              }
            } else {
              validate26.errors = [
                {
                  instancePath: instancePath + '/Devices',
                  schemaPath: '#/properties/Devices/type',
                  keyword: 'type',
                  params: { type: 'array' },
                  message: 'must be array',
                  schema: schema11.properties.Devices.type,
                  parentSchema: schema11.properties.Devices,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data3 = data.Time;
            const _errs7 = errors;
            if (errors === _errs7) {
              if (data3 && typeof data3 == 'object' && !Array.isArray(data3)) {
                let missing2;
                if (
                  (data3.Start === undefined && (missing2 = 'Start')) ||
                  (data3.End === undefined && (missing2 = 'End'))
                ) {
                  validate26.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing2 },
                      message: "must have required property '" + missing2 + "'",
                      schema: schema11.properties.Time.required,
                      parentSchema: schema11.properties.Time,
                      data: data3,
                    },
                  ];
                  return false;
                } else {
                  if (data3.Start !== undefined) {
                    let data4 = data3.Start;
                    const _errs9 = errors;
                    if (errors === _errs9) {
                      if (errors === _errs9) {
                        if (typeof data4 === 'string') {
                          if (!formats2.validate(data4)) {
                            validate26.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema11.properties.Time.properties.Start,
                                data: data4,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate26.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema11.properties.Time.properties.Start.type,
                              parentSchema: schema11.properties.Time.properties.Start,
                              data: data4,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid3 = _errs9 === errors;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data3.End !== undefined) {
                      let data5 = data3.End;
                      const _errs11 = errors;
                      if (errors === _errs11) {
                        if (errors === _errs11) {
                          if (typeof data5 === 'string') {
                            if (!formats2.validate(data5)) {
                              validate26.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema11.properties.Time.properties.End,
                                  data: data5,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate26.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema11.properties.Time.properties.End.type,
                                parentSchema: schema11.properties.Time.properties.End,
                                data: data5,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid3 = _errs11 === errors;
                    } else {
                      var valid3 = true;
                    }
                  }
                }
              } else {
                validate26.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema11.properties.Time.type,
                    parentSchema: schema11.properties.Time,
                    data: data3,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs7 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Type !== undefined) {
              let data6 = data.Type;
              const _errs13 = errors;
              if (typeof data6 !== 'string') {
                validate26.errors = [
                  {
                    instancePath: instancePath + '/Type',
                    schemaPath: '#/properties/Type/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema11.properties.Type.type,
                    parentSchema: schema11.properties.Type,
                    data: data6,
                  },
                ];
                return false;
              }
              if (!(data6 === 'normal')) {
                validate26.errors = [
                  {
                    instancePath: instancePath + '/Type',
                    schemaPath: '#/properties/Type/enum',
                    keyword: 'enum',
                    params: { allowedValues: schema11.properties.Type.enum },
                    message: 'must be equal to one of the allowed values',
                    schema: schema11.properties.Type.enum,
                    parentSchema: schema11.properties.Type,
                    data: data6,
                  },
                ];
                return false;
              }
              var valid0 = _errs13 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate26.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema11.type,
          parentSchema: schema11,
          data,
        },
      ];
      return false;
    }
  }
  validate26.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingResponse200 = validate27;
const schema12 = {
  type: 'object',
  required: ['BookingID'],
  properties: {
    BookingID: {
      type: 'string',
      format: 'uri',
      description: 'ID at which the booking can be managed.',
    },
  },
  'x-standalone': false,
  'x-name': 'newBookingResponse200',
  'x-location': '#/paths//booking/post/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate27(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.BookingID === undefined && (missing0 = 'BookingID')) {
        validate27.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema12.required,
            parentSchema: schema12,
            data,
          },
        ];
        return false;
      } else {
        if (data.BookingID !== undefined) {
          let data0 = data.BookingID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate27.errors = [
                    {
                      instancePath: instancePath + '/BookingID',
                      schemaPath: '#/properties/BookingID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema12.properties.BookingID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate27.errors = [
                  {
                    instancePath: instancePath + '/BookingID',
                    schemaPath: '#/properties/BookingID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema12.properties.BookingID.type,
                    parentSchema: schema12.properties.BookingID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate27.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema12.type,
          parentSchema: schema12,
          data,
        },
      ];
      return false;
    }
  }
  validate27.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingResponse500 = validate28;
const schema13 = {
  description: 'Error description',
  type: 'string',
  'x-standalone': false,
  'x-name': 'newBookingResponse500',
  'x-location': '#/paths//booking/post/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate28(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate28.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema13.type,
        parentSchema: schema13,
        data,
      },
    ];
    return false;
  }
  validate28.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingBody = validate29;
const schema14 = {
  anyOf: [
    {
      type: 'object',
      description: 'Use this request for adding devices.',
      properties: {
        Locked: {
          type: 'boolean',
          description:
            'Expresses whether the devices should be locked. Must match current status of booking. Is assumed to be false if not set.',
        },
        Devices: {
          type: 'array',
          description: 'List of devices which should be added.',
          items: {
            title: 'Device',
            description:
              'A device might either be a physical/virtual device or a group of device.',
            type: 'object',
            required: ['ID'],
            properties: {
              ID: {
                type: 'string',
                description:
                  'Unique ID of the device. Contains the institution (by having an end point at that institution)',
                format: 'uri',
              },
            },
          },
        },
      },
    },
    {
      type: 'object',
      description: 'Use this request for adding callbacks.',
      properties: {
        Callback: {
          type: 'string',
          format: 'uri',
          description: 'Callback which should be called at changes.',
        },
      },
    },
  ],
  'x-standalone': false,
  'x-name': 'updateBookingBody',
  'x-location': '#/paths//booking/{ID}/patch/requestBody/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate29(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  let valid0 = false;
  const _errs1 = errors;
  if (errors === _errs1) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.Locked !== undefined) {
        let data0 = data.Locked;
        const _errs3 = errors;
        if (typeof data0 !== 'boolean') {
          const err0 = {
            instancePath: instancePath + '/Locked',
            schemaPath: '#/anyOf/0/properties/Locked/type',
            keyword: 'type',
            params: { type: 'boolean' },
            message: 'must be boolean',
            schema: schema14.anyOf[0].properties.Locked.type,
            parentSchema: schema14.anyOf[0].properties.Locked,
            data: data0,
          };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
        var valid1 = _errs3 === errors;
      } else {
        var valid1 = true;
      }
      if (valid1) {
        if (data.Devices !== undefined) {
          let data1 = data.Devices;
          const _errs5 = errors;
          if (errors === _errs5) {
            if (Array.isArray(data1)) {
              var valid2 = true;
              const len0 = data1.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data2 = data1[i0];
                const _errs7 = errors;
                if (errors === _errs7) {
                  if (data2 && typeof data2 == 'object' && !Array.isArray(data2)) {
                    let missing0;
                    if (data2.ID === undefined && (missing0 = 'ID')) {
                      const err1 = {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/anyOf/0/properties/Devices/items/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                        schema: schema14.anyOf[0].properties.Devices.items.required,
                        parentSchema: schema14.anyOf[0].properties.Devices.items,
                        data: data2,
                      };
                      if (vErrors === null) {
                        vErrors = [err1];
                      } else {
                        vErrors.push(err1);
                      }
                      errors++;
                    } else {
                      if (data2.ID !== undefined) {
                        let data3 = data2.ID;
                        const _errs9 = errors;
                        if (errors === _errs9) {
                          if (errors === _errs9) {
                            if (typeof data3 === 'string') {
                              if (!formats0(data3)) {
                                const err2 = {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/anyOf/0/properties/Devices/items/properties/ID/format',
                                  keyword: 'format',
                                  params: { format: 'uri' },
                                  message: 'must match format "' + 'uri' + '"',
                                  schema: 'uri',
                                  parentSchema:
                                    schema14.anyOf[0].properties.Devices.items.properties
                                      .ID,
                                  data: data3,
                                };
                                if (vErrors === null) {
                                  vErrors = [err2];
                                } else {
                                  vErrors.push(err2);
                                }
                                errors++;
                              }
                            } else {
                              const err3 = {
                                instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                schemaPath:
                                  '#/anyOf/0/properties/Devices/items/properties/ID/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema:
                                  schema14.anyOf[0].properties.Devices.items.properties.ID
                                    .type,
                                parentSchema:
                                  schema14.anyOf[0].properties.Devices.items.properties
                                    .ID,
                                data: data3,
                              };
                              if (vErrors === null) {
                                vErrors = [err3];
                              } else {
                                vErrors.push(err3);
                              }
                              errors++;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    const err4 = {
                      instancePath: instancePath + '/Devices/' + i0,
                      schemaPath: '#/anyOf/0/properties/Devices/items/type',
                      keyword: 'type',
                      params: { type: 'object' },
                      message: 'must be object',
                      schema: schema14.anyOf[0].properties.Devices.items.type,
                      parentSchema: schema14.anyOf[0].properties.Devices.items,
                      data: data2,
                    };
                    if (vErrors === null) {
                      vErrors = [err4];
                    } else {
                      vErrors.push(err4);
                    }
                    errors++;
                  }
                }
                var valid2 = _errs7 === errors;
                if (!valid2) {
                  break;
                }
              }
            } else {
              const err5 = {
                instancePath: instancePath + '/Devices',
                schemaPath: '#/anyOf/0/properties/Devices/type',
                keyword: 'type',
                params: { type: 'array' },
                message: 'must be array',
                schema: schema14.anyOf[0].properties.Devices.type,
                parentSchema: schema14.anyOf[0].properties.Devices,
                data: data1,
              };
              if (vErrors === null) {
                vErrors = [err5];
              } else {
                vErrors.push(err5);
              }
              errors++;
            }
          }
          var valid1 = _errs5 === errors;
        } else {
          var valid1 = true;
        }
      }
    } else {
      const err6 = {
        instancePath,
        schemaPath: '#/anyOf/0/type',
        keyword: 'type',
        params: { type: 'object' },
        message: 'must be object',
        schema: schema14.anyOf[0].type,
        parentSchema: schema14.anyOf[0],
        data,
      };
      if (vErrors === null) {
        vErrors = [err6];
      } else {
        vErrors.push(err6);
      }
      errors++;
    }
  }
  var _valid0 = _errs1 === errors;
  valid0 = valid0 || _valid0;
  if (!valid0) {
    const _errs11 = errors;
    if (errors === _errs11) {
      if (data && typeof data == 'object' && !Array.isArray(data)) {
        if (data.Callback !== undefined) {
          let data4 = data.Callback;
          const _errs13 = errors;
          if (errors === _errs13) {
            if (errors === _errs13) {
              if (typeof data4 === 'string') {
                if (!formats0(data4)) {
                  const err7 = {
                    instancePath: instancePath + '/Callback',
                    schemaPath: '#/anyOf/1/properties/Callback/format',
                    keyword: 'format',
                    params: { format: 'uri' },
                    message: 'must match format "' + 'uri' + '"',
                    schema: 'uri',
                    parentSchema: schema14.anyOf[1].properties.Callback,
                    data: data4,
                  };
                  if (vErrors === null) {
                    vErrors = [err7];
                  } else {
                    vErrors.push(err7);
                  }
                  errors++;
                }
              } else {
                const err8 = {
                  instancePath: instancePath + '/Callback',
                  schemaPath: '#/anyOf/1/properties/Callback/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema14.anyOf[1].properties.Callback.type,
                  parentSchema: schema14.anyOf[1].properties.Callback,
                  data: data4,
                };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors++;
              }
            }
          }
        }
      } else {
        const err9 = {
          instancePath,
          schemaPath: '#/anyOf/1/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema14.anyOf[1].type,
          parentSchema: schema14.anyOf[1],
          data,
        };
        if (vErrors === null) {
          vErrors = [err9];
        } else {
          vErrors.push(err9);
        }
        errors++;
      }
    }
    var _valid0 = _errs11 === errors;
    valid0 = valid0 || _valid0;
  }
  if (!valid0) {
    const err10 = {
      instancePath,
      schemaPath: '#/anyOf',
      keyword: 'anyOf',
      params: {},
      message: 'must match a schema in anyOf',
      schema: schema14.anyOf,
      parentSchema: schema14,
      data,
    };
    if (vErrors === null) {
      vErrors = [err10];
    } else {
      vErrors.push(err10);
    }
    errors++;
    validate29.errors = vErrors;
    return false;
  } else {
    errors = _errs0;
    if (vErrors !== null) {
      if (_errs0) {
        vErrors.length = _errs0;
      } else {
        vErrors = null;
      }
    }
  }
  validate29.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse200 = validate30;
const schema15 = {
  type: 'object',
  required: ['BookingID'],
  properties: { BookingID: { type: 'string', format: 'uri' } },
  'x-standalone': false,
  'x-name': 'updateBookingResponse200',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate30(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.BookingID === undefined && (missing0 = 'BookingID')) {
        validate30.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema15.required,
            parentSchema: schema15,
            data,
          },
        ];
        return false;
      } else {
        if (data.BookingID !== undefined) {
          let data0 = data.BookingID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate30.errors = [
                    {
                      instancePath: instancePath + '/BookingID',
                      schemaPath: '#/properties/BookingID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema15.properties.BookingID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate30.errors = [
                  {
                    instancePath: instancePath + '/BookingID',
                    schemaPath: '#/properties/BookingID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema15.properties.BookingID.type,
                    parentSchema: schema15.properties.BookingID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate30.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema15.type,
          parentSchema: schema15,
          data,
        },
      ];
      return false;
    }
  }
  validate30.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse400 = validate31;
const schema16 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'updateBookingResponse400',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/400/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate31(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate31.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema16.type,
        parentSchema: schema16,
        data,
      },
    ];
    return false;
  }
  validate31.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse500 = validate32;
const schema17 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'updateBookingResponse500',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate32(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate32.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema17.type,
        parentSchema: schema17,
        data,
      },
    ];
    return false;
  }
  validate32.errors = vErrors;
  return errors === 0;
}
exports.validateDeleteBookingResponse500 = validate33;
const schema18 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'deleteBookingResponse500',
  'x-location':
    '#/paths//booking/{ID}/delete/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate33(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate33.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema18.type,
        parentSchema: schema18,
        data,
      },
    ];
    return false;
  }
  validate33.errors = vErrors;
  return errors === 0;
}
exports.validateGetBookingResponse200 = validate34;
const schema19 = {
  type: 'object',
  required: ['Booking', 'Locked'],
  properties: {
    Booking: {
      title: 'Booking',
      description: 'A booking in the booking system.',
      type: 'object',
      required: ['ID', 'Time', 'Devices', 'Status', 'You', 'External'],
      properties: {
        ID: { type: 'string', format: 'uri', description: 'Unique ID of the booking.' },
        Time: {
          title: 'Timeslot',
          description: 'A time slot represents a slice of time used for bookings.',
          type: 'object',
          required: ['Start', 'End'],
          properties: {
            Start: {
              type: 'string',
              description: 'Start time of the booking.',
              format: 'date-time',
            },
            End: {
              type: 'string',
              description: 'End time of the booking.',
              format: 'date-time',
            },
          },
        },
        Devices: { type: 'array', items: { type: 'string', format: 'uri' } },
        Type: {
          description:
            "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
          type: 'string',
          enum: ['normal'],
        },
        Status: {
          description:
            "Current status of the booking. While the booking is pending, it can not be used. Will change automatically and can not be set by user. 'rejected' is set when the initial booking failed, 'cancelled' when the booking was deleted / cancelled after it was once active. The 'active-*' will be used when a device was added after the booking was locked.",
          type: 'string',
          enum: [
            'pending',
            'booked',
            'rejected',
            'cancelled',
            'active',
            'active-pending',
            'active-rejected',
          ],
        },
        You: { type: 'boolean', description: 'If true, this booking was done by you.' },
        External: {
          type: 'boolean',
          description: 'Shows whether the booking was done by an external institution.',
        },
        Message: {
          type: 'string',
          description:
            'User readable notes about the status of the booking (e.g. if devices are unknown).',
        },
      },
    },
    Locked: {
      type: 'boolean',
      description: 'Shows if the booking is in a locked status.',
    },
  },
  'x-standalone': false,
  'x-name': 'getBookingResponse200',
  'x-location': '#/paths//booking/{ID}/get/responses/200/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate34(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Booking === undefined && (missing0 = 'Booking')) ||
        (data.Locked === undefined && (missing0 = 'Locked'))
      ) {
        validate34.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema19.required,
            parentSchema: schema19,
            data,
          },
        ];
        return false;
      } else {
        if (data.Booking !== undefined) {
          let data0 = data.Booking;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
              let missing1;
              if (
                (data0.ID === undefined && (missing1 = 'ID')) ||
                (data0.Time === undefined && (missing1 = 'Time')) ||
                (data0.Devices === undefined && (missing1 = 'Devices')) ||
                (data0.Status === undefined && (missing1 = 'Status')) ||
                (data0.You === undefined && (missing1 = 'You')) ||
                (data0.External === undefined && (missing1 = 'External'))
              ) {
                validate34.errors = [
                  {
                    instancePath: instancePath + '/Booking',
                    schemaPath: '#/properties/Booking/required',
                    keyword: 'required',
                    params: { missingProperty: missing1 },
                    message: "must have required property '" + missing1 + "'",
                    schema: schema19.properties.Booking.required,
                    parentSchema: schema19.properties.Booking,
                    data: data0,
                  },
                ];
                return false;
              } else {
                if (data0.ID !== undefined) {
                  let data1 = data0.ID;
                  const _errs3 = errors;
                  if (errors === _errs3) {
                    if (errors === _errs3) {
                      if (typeof data1 === 'string') {
                        if (!formats0(data1)) {
                          validate34.errors = [
                            {
                              instancePath: instancePath + '/Booking/ID',
                              schemaPath: '#/properties/Booking/properties/ID/format',
                              keyword: 'format',
                              params: { format: 'uri' },
                              message: 'must match format "' + 'uri' + '"',
                              schema: 'uri',
                              parentSchema: schema19.properties.Booking.properties.ID,
                              data: data1,
                            },
                          ];
                          return false;
                        }
                      } else {
                        validate34.errors = [
                          {
                            instancePath: instancePath + '/Booking/ID',
                            schemaPath: '#/properties/Booking/properties/ID/type',
                            keyword: 'type',
                            params: { type: 'string' },
                            message: 'must be string',
                            schema: schema19.properties.Booking.properties.ID.type,
                            parentSchema: schema19.properties.Booking.properties.ID,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    }
                  }
                  var valid1 = _errs3 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.Time !== undefined) {
                    let data2 = data0.Time;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (data2 && typeof data2 == 'object' && !Array.isArray(data2)) {
                        let missing2;
                        if (
                          (data2.Start === undefined && (missing2 = 'Start')) ||
                          (data2.End === undefined && (missing2 = 'End'))
                        ) {
                          validate34.errors = [
                            {
                              instancePath: instancePath + '/Booking/Time',
                              schemaPath: '#/properties/Booking/properties/Time/required',
                              keyword: 'required',
                              params: { missingProperty: missing2 },
                              message: "must have required property '" + missing2 + "'",
                              schema:
                                schema19.properties.Booking.properties.Time.required,
                              parentSchema: schema19.properties.Booking.properties.Time,
                              data: data2,
                            },
                          ];
                          return false;
                        } else {
                          if (data2.Start !== undefined) {
                            let data3 = data2.Start;
                            const _errs7 = errors;
                            if (errors === _errs7) {
                              if (errors === _errs7) {
                                if (typeof data3 === 'string') {
                                  if (!formats2.validate(data3)) {
                                    validate34.errors = [
                                      {
                                        instancePath:
                                          instancePath + '/Booking/Time/Start',
                                        schemaPath:
                                          '#/properties/Booking/properties/Time/properties/Start/format',
                                        keyword: 'format',
                                        params: { format: 'date-time' },
                                        message:
                                          'must match format "' + 'date-time' + '"',
                                        schema: 'date-time',
                                        parentSchema:
                                          schema19.properties.Booking.properties.Time
                                            .properties.Start,
                                        data: data3,
                                      },
                                    ];
                                    return false;
                                  }
                                } else {
                                  validate34.errors = [
                                    {
                                      instancePath: instancePath + '/Booking/Time/Start',
                                      schemaPath:
                                        '#/properties/Booking/properties/Time/properties/Start/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema19.properties.Booking.properties.Time
                                          .properties.Start.type,
                                      parentSchema:
                                        schema19.properties.Booking.properties.Time
                                          .properties.Start,
                                      data: data3,
                                    },
                                  ];
                                  return false;
                                }
                              }
                            }
                            var valid2 = _errs7 === errors;
                          } else {
                            var valid2 = true;
                          }
                          if (valid2) {
                            if (data2.End !== undefined) {
                              let data4 = data2.End;
                              const _errs9 = errors;
                              if (errors === _errs9) {
                                if (errors === _errs9) {
                                  if (typeof data4 === 'string') {
                                    if (!formats2.validate(data4)) {
                                      validate34.errors = [
                                        {
                                          instancePath:
                                            instancePath + '/Booking/Time/End',
                                          schemaPath:
                                            '#/properties/Booking/properties/Time/properties/End/format',
                                          keyword: 'format',
                                          params: { format: 'date-time' },
                                          message:
                                            'must match format "' + 'date-time' + '"',
                                          schema: 'date-time',
                                          parentSchema:
                                            schema19.properties.Booking.properties.Time
                                              .properties.End,
                                          data: data4,
                                        },
                                      ];
                                      return false;
                                    }
                                  } else {
                                    validate34.errors = [
                                      {
                                        instancePath: instancePath + '/Booking/Time/End',
                                        schemaPath:
                                          '#/properties/Booking/properties/Time/properties/End/type',
                                        keyword: 'type',
                                        params: { type: 'string' },
                                        message: 'must be string',
                                        schema:
                                          schema19.properties.Booking.properties.Time
                                            .properties.End.type,
                                        parentSchema:
                                          schema19.properties.Booking.properties.Time
                                            .properties.End,
                                        data: data4,
                                      },
                                    ];
                                    return false;
                                  }
                                }
                              }
                              var valid2 = _errs9 === errors;
                            } else {
                              var valid2 = true;
                            }
                          }
                        }
                      } else {
                        validate34.errors = [
                          {
                            instancePath: instancePath + '/Booking/Time',
                            schemaPath: '#/properties/Booking/properties/Time/type',
                            keyword: 'type',
                            params: { type: 'object' },
                            message: 'must be object',
                            schema: schema19.properties.Booking.properties.Time.type,
                            parentSchema: schema19.properties.Booking.properties.Time,
                            data: data2,
                          },
                        ];
                        return false;
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data0.Devices !== undefined) {
                      let data5 = data0.Devices;
                      const _errs11 = errors;
                      if (errors === _errs11) {
                        if (Array.isArray(data5)) {
                          var valid3 = true;
                          const len0 = data5.length;
                          for (let i0 = 0; i0 < len0; i0++) {
                            let data6 = data5[i0];
                            const _errs13 = errors;
                            if (errors === _errs13) {
                              if (errors === _errs13) {
                                if (typeof data6 === 'string') {
                                  if (!formats0(data6)) {
                                    validate34.errors = [
                                      {
                                        instancePath:
                                          instancePath + '/Booking/Devices/' + i0,
                                        schemaPath:
                                          '#/properties/Booking/properties/Devices/items/format',
                                        keyword: 'format',
                                        params: { format: 'uri' },
                                        message: 'must match format "' + 'uri' + '"',
                                        schema: 'uri',
                                        parentSchema:
                                          schema19.properties.Booking.properties.Devices
                                            .items,
                                        data: data6,
                                      },
                                    ];
                                    return false;
                                  }
                                } else {
                                  validate34.errors = [
                                    {
                                      instancePath:
                                        instancePath + '/Booking/Devices/' + i0,
                                      schemaPath:
                                        '#/properties/Booking/properties/Devices/items/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema19.properties.Booking.properties.Devices
                                          .items.type,
                                      parentSchema:
                                        schema19.properties.Booking.properties.Devices
                                          .items,
                                      data: data6,
                                    },
                                  ];
                                  return false;
                                }
                              }
                            }
                            var valid3 = _errs13 === errors;
                            if (!valid3) {
                              break;
                            }
                          }
                        } else {
                          validate34.errors = [
                            {
                              instancePath: instancePath + '/Booking/Devices',
                              schemaPath: '#/properties/Booking/properties/Devices/type',
                              keyword: 'type',
                              params: { type: 'array' },
                              message: 'must be array',
                              schema: schema19.properties.Booking.properties.Devices.type,
                              parentSchema:
                                schema19.properties.Booking.properties.Devices,
                              data: data5,
                            },
                          ];
                          return false;
                        }
                      }
                      var valid1 = _errs11 === errors;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data0.Type !== undefined) {
                        let data7 = data0.Type;
                        const _errs15 = errors;
                        if (typeof data7 !== 'string') {
                          validate34.errors = [
                            {
                              instancePath: instancePath + '/Booking/Type',
                              schemaPath: '#/properties/Booking/properties/Type/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema19.properties.Booking.properties.Type.type,
                              parentSchema: schema19.properties.Booking.properties.Type,
                              data: data7,
                            },
                          ];
                          return false;
                        }
                        if (!(data7 === 'normal')) {
                          validate34.errors = [
                            {
                              instancePath: instancePath + '/Booking/Type',
                              schemaPath: '#/properties/Booking/properties/Type/enum',
                              keyword: 'enum',
                              params: {
                                allowedValues:
                                  schema19.properties.Booking.properties.Type.enum,
                              },
                              message: 'must be equal to one of the allowed values',
                              schema: schema19.properties.Booking.properties.Type.enum,
                              parentSchema: schema19.properties.Booking.properties.Type,
                              data: data7,
                            },
                          ];
                          return false;
                        }
                        var valid1 = _errs15 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data0.Status !== undefined) {
                          let data8 = data0.Status;
                          const _errs17 = errors;
                          if (typeof data8 !== 'string') {
                            validate34.errors = [
                              {
                                instancePath: instancePath + '/Booking/Status',
                                schemaPath: '#/properties/Booking/properties/Status/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema:
                                  schema19.properties.Booking.properties.Status.type,
                                parentSchema:
                                  schema19.properties.Booking.properties.Status,
                                data: data8,
                              },
                            ];
                            return false;
                          }
                          if (
                            !(
                              data8 === 'pending' ||
                              data8 === 'booked' ||
                              data8 === 'rejected' ||
                              data8 === 'cancelled' ||
                              data8 === 'active' ||
                              data8 === 'active-pending' ||
                              data8 === 'active-rejected'
                            )
                          ) {
                            validate34.errors = [
                              {
                                instancePath: instancePath + '/Booking/Status',
                                schemaPath: '#/properties/Booking/properties/Status/enum',
                                keyword: 'enum',
                                params: {
                                  allowedValues:
                                    schema19.properties.Booking.properties.Status.enum,
                                },
                                message: 'must be equal to one of the allowed values',
                                schema:
                                  schema19.properties.Booking.properties.Status.enum,
                                parentSchema:
                                  schema19.properties.Booking.properties.Status,
                                data: data8,
                              },
                            ];
                            return false;
                          }
                          var valid1 = _errs17 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data0.You !== undefined) {
                            let data9 = data0.You;
                            const _errs19 = errors;
                            if (typeof data9 !== 'boolean') {
                              validate34.errors = [
                                {
                                  instancePath: instancePath + '/Booking/You',
                                  schemaPath: '#/properties/Booking/properties/You/type',
                                  keyword: 'type',
                                  params: { type: 'boolean' },
                                  message: 'must be boolean',
                                  schema: schema19.properties.Booking.properties.You.type,
                                  parentSchema:
                                    schema19.properties.Booking.properties.You,
                                  data: data9,
                                },
                              ];
                              return false;
                            }
                            var valid1 = _errs19 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data0.External !== undefined) {
                              let data10 = data0.External;
                              const _errs21 = errors;
                              if (typeof data10 !== 'boolean') {
                                validate34.errors = [
                                  {
                                    instancePath: instancePath + '/Booking/External',
                                    schemaPath:
                                      '#/properties/Booking/properties/External/type',
                                    keyword: 'type',
                                    params: { type: 'boolean' },
                                    message: 'must be boolean',
                                    schema:
                                      schema19.properties.Booking.properties.External
                                        .type,
                                    parentSchema:
                                      schema19.properties.Booking.properties.External,
                                    data: data10,
                                  },
                                ];
                                return false;
                              }
                              var valid1 = _errs21 === errors;
                            } else {
                              var valid1 = true;
                            }
                            if (valid1) {
                              if (data0.Message !== undefined) {
                                let data11 = data0.Message;
                                const _errs23 = errors;
                                if (typeof data11 !== 'string') {
                                  validate34.errors = [
                                    {
                                      instancePath: instancePath + '/Booking/Message',
                                      schemaPath:
                                        '#/properties/Booking/properties/Message/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema19.properties.Booking.properties.Message
                                          .type,
                                      parentSchema:
                                        schema19.properties.Booking.properties.Message,
                                      data: data11,
                                    },
                                  ];
                                  return false;
                                }
                                var valid1 = _errs23 === errors;
                              } else {
                                var valid1 = true;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              validate34.errors = [
                {
                  instancePath: instancePath + '/Booking',
                  schemaPath: '#/properties/Booking/type',
                  keyword: 'type',
                  params: { type: 'object' },
                  message: 'must be object',
                  schema: schema19.properties.Booking.type,
                  parentSchema: schema19.properties.Booking,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Locked !== undefined) {
            let data12 = data.Locked;
            const _errs25 = errors;
            if (typeof data12 !== 'boolean') {
              validate34.errors = [
                {
                  instancePath: instancePath + '/Locked',
                  schemaPath: '#/properties/Locked/type',
                  keyword: 'type',
                  params: { type: 'boolean' },
                  message: 'must be boolean',
                  schema: schema19.properties.Locked.type,
                  parentSchema: schema19.properties.Locked,
                  data: data12,
                },
              ];
              return false;
            }
            var valid0 = _errs25 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate34.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema19.type,
          parentSchema: schema19,
          data,
        },
      ];
      return false;
    }
  }
  validate34.errors = vErrors;
  return errors === 0;
}
exports.validateGetBookingResponse500 = validate35;
const schema20 = {
  type: 'string',
  description: 'Error code',
  'x-standalone': false,
  'x-name': 'getBookingResponse500',
  'x-location': '#/paths//booking/{ID}/get/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate35(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate35.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema20.type,
        parentSchema: schema20,
        data,
      },
    ];
    return false;
  }
  validate35.errors = vErrors;
  return errors === 0;
}
exports.validateDestroyBookingResponse500 = validate36;
const schema21 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'destroyBookingResponse500',
  'x-location':
    '#/paths//booking/{ID}/destroy/delete/responses/500/content/application/json/schema',
  'x-schema-type': 'all',
};
function validate36(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate36.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema21.type,
        parentSchema: schema21,
        data,
      },
    ];
    return false;
  }
  validate36.errors = vErrors;
  return errors === 0;
}
exports.validateBookingRequest = validate37;
const schema22 = {
  title: 'Booking',
  description: 'A booking in the booking system.',
  type: 'object',
  required: ['ID', 'Time', 'Devices', 'Status', 'You', 'External'],
  properties: {
    ID: { type: 'string', format: 'uri', description: 'Unique ID of the booking.' },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Devices: { type: 'array', items: { type: 'string', format: 'uri' } },
    Type: {
      description:
        "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
      type: 'string',
      enum: ['normal'],
    },
    Status: {
      description:
        "Current status of the booking. While the booking is pending, it can not be used. Will change automatically and can not be set by user. 'rejected' is set when the initial booking failed, 'cancelled' when the booking was deleted / cancelled after it was once active. The 'active-*' will be used when a device was added after the booking was locked.",
      type: 'string',
      enum: [
        'pending',
        'booked',
        'rejected',
        'cancelled',
        'active',
        'active-pending',
        'active-rejected',
      ],
    },
    You: { type: 'boolean', description: 'If true, this booking was done by you.' },
    External: {
      type: 'boolean',
      description: 'Shows whether the booking was done by an external institution.',
    },
    Message: {
      type: 'string',
      description:
        'User readable notes about the status of the booking (e.g. if devices are unknown).',
    },
  },
  'x-standalone': true,
  'x-name': 'BookingRequest',
  'x-location': '#/components/schemas/Booking_request',
  'x-schema-type': 'request',
};
function validate37(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.ID === undefined && (missing0 = 'ID')) ||
        (data.Time === undefined && (missing0 = 'Time')) ||
        (data.Devices === undefined && (missing0 = 'Devices')) ||
        (data.Status === undefined && (missing0 = 'Status')) ||
        (data.You === undefined && (missing0 = 'You')) ||
        (data.External === undefined && (missing0 = 'External'))
      ) {
        validate37.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema22.required,
            parentSchema: schema22,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate37.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema22.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate37.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema22.properties.ID.type,
                    parentSchema: schema22.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data1 = data.Time;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                let missing1;
                if (
                  (data1.Start === undefined && (missing1 = 'Start')) ||
                  (data1.End === undefined && (missing1 = 'End'))
                ) {
                  validate37.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing1 },
                      message: "must have required property '" + missing1 + "'",
                      schema: schema22.properties.Time.required,
                      parentSchema: schema22.properties.Time,
                      data: data1,
                    },
                  ];
                  return false;
                } else {
                  if (data1.Start !== undefined) {
                    let data2 = data1.Start;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (errors === _errs5) {
                        if (typeof data2 === 'string') {
                          if (!formats2.validate(data2)) {
                            validate37.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema22.properties.Time.properties.Start,
                                data: data2,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate37.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema22.properties.Time.properties.Start.type,
                              parentSchema: schema22.properties.Time.properties.Start,
                              data: data2,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data1.End !== undefined) {
                      let data3 = data1.End;
                      const _errs7 = errors;
                      if (errors === _errs7) {
                        if (errors === _errs7) {
                          if (typeof data3 === 'string') {
                            if (!formats2.validate(data3)) {
                              validate37.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema22.properties.Time.properties.End,
                                  data: data3,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate37.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema22.properties.Time.properties.End.type,
                                parentSchema: schema22.properties.Time.properties.End,
                                data: data3,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid1 = _errs7 === errors;
                    } else {
                      var valid1 = true;
                    }
                  }
                }
              } else {
                validate37.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema22.properties.Time.type,
                    parentSchema: schema22.properties.Time,
                    data: data1,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Devices !== undefined) {
              let data4 = data.Devices;
              const _errs9 = errors;
              if (errors === _errs9) {
                if (Array.isArray(data4)) {
                  var valid2 = true;
                  const len0 = data4.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data5 = data4[i0];
                    const _errs11 = errors;
                    if (errors === _errs11) {
                      if (errors === _errs11) {
                        if (typeof data5 === 'string') {
                          if (!formats0(data5)) {
                            validate37.errors = [
                              {
                                instancePath: instancePath + '/Devices/' + i0,
                                schemaPath: '#/properties/Devices/items/format',
                                keyword: 'format',
                                params: { format: 'uri' },
                                message: 'must match format "' + 'uri' + '"',
                                schema: 'uri',
                                parentSchema: schema22.properties.Devices.items,
                                data: data5,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate37.errors = [
                            {
                              instancePath: instancePath + '/Devices/' + i0,
                              schemaPath: '#/properties/Devices/items/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema22.properties.Devices.items.type,
                              parentSchema: schema22.properties.Devices.items,
                              data: data5,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid2 = _errs11 === errors;
                    if (!valid2) {
                      break;
                    }
                  }
                } else {
                  validate37.errors = [
                    {
                      instancePath: instancePath + '/Devices',
                      schemaPath: '#/properties/Devices/type',
                      keyword: 'type',
                      params: { type: 'array' },
                      message: 'must be array',
                      schema: schema22.properties.Devices.type,
                      parentSchema: schema22.properties.Devices,
                      data: data4,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs9 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.Type !== undefined) {
                let data6 = data.Type;
                const _errs13 = errors;
                if (typeof data6 !== 'string') {
                  validate37.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema22.properties.Type.type,
                      parentSchema: schema22.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                if (!(data6 === 'normal')) {
                  validate37.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/enum',
                      keyword: 'enum',
                      params: { allowedValues: schema22.properties.Type.enum },
                      message: 'must be equal to one of the allowed values',
                      schema: schema22.properties.Type.enum,
                      parentSchema: schema22.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs13 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.Status !== undefined) {
                  let data7 = data.Status;
                  const _errs15 = errors;
                  if (typeof data7 !== 'string') {
                    validate37.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/type',
                        keyword: 'type',
                        params: { type: 'string' },
                        message: 'must be string',
                        schema: schema22.properties.Status.type,
                        parentSchema: schema22.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  if (
                    !(
                      data7 === 'pending' ||
                      data7 === 'booked' ||
                      data7 === 'rejected' ||
                      data7 === 'cancelled' ||
                      data7 === 'active' ||
                      data7 === 'active-pending' ||
                      data7 === 'active-rejected'
                    )
                  ) {
                    validate37.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/enum',
                        keyword: 'enum',
                        params: { allowedValues: schema22.properties.Status.enum },
                        message: 'must be equal to one of the allowed values',
                        schema: schema22.properties.Status.enum,
                        parentSchema: schema22.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  var valid0 = _errs15 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.You !== undefined) {
                    let data8 = data.You;
                    const _errs17 = errors;
                    if (typeof data8 !== 'boolean') {
                      validate37.errors = [
                        {
                          instancePath: instancePath + '/You',
                          schemaPath: '#/properties/You/type',
                          keyword: 'type',
                          params: { type: 'boolean' },
                          message: 'must be boolean',
                          schema: schema22.properties.You.type,
                          parentSchema: schema22.properties.You,
                          data: data8,
                        },
                      ];
                      return false;
                    }
                    var valid0 = _errs17 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.External !== undefined) {
                      let data9 = data.External;
                      const _errs19 = errors;
                      if (typeof data9 !== 'boolean') {
                        validate37.errors = [
                          {
                            instancePath: instancePath + '/External',
                            schemaPath: '#/properties/External/type',
                            keyword: 'type',
                            params: { type: 'boolean' },
                            message: 'must be boolean',
                            schema: schema22.properties.External.type,
                            parentSchema: schema22.properties.External,
                            data: data9,
                          },
                        ];
                        return false;
                      }
                      var valid0 = _errs19 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.Message !== undefined) {
                        let data10 = data.Message;
                        const _errs21 = errors;
                        if (typeof data10 !== 'string') {
                          validate37.errors = [
                            {
                              instancePath: instancePath + '/Message',
                              schemaPath: '#/properties/Message/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema22.properties.Message.type,
                              parentSchema: schema22.properties.Message,
                              data: data10,
                            },
                          ];
                          return false;
                        }
                        var valid0 = _errs21 === errors;
                      } else {
                        var valid0 = true;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate37.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema22.type,
          parentSchema: schema22,
          data,
        },
      ];
      return false;
    }
  }
  validate37.errors = vErrors;
  return errors === 0;
}
exports.validateBookingResponse = validate38;
const schema23 = {
  title: 'Booking',
  description: 'A booking in the booking system.',
  type: 'object',
  required: ['ID', 'Time', 'Devices', 'Status', 'You', 'External'],
  properties: {
    ID: { type: 'string', format: 'uri', description: 'Unique ID of the booking.' },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Devices: { type: 'array', items: { type: 'string', format: 'uri' } },
    Type: {
      description:
        "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
      type: 'string',
      enum: ['normal'],
    },
    Status: {
      description:
        "Current status of the booking. While the booking is pending, it can not be used. Will change automatically and can not be set by user. 'rejected' is set when the initial booking failed, 'cancelled' when the booking was deleted / cancelled after it was once active. The 'active-*' will be used when a device was added after the booking was locked.",
      type: 'string',
      enum: [
        'pending',
        'booked',
        'rejected',
        'cancelled',
        'active',
        'active-pending',
        'active-rejected',
      ],
    },
    You: { type: 'boolean', description: 'If true, this booking was done by you.' },
    External: {
      type: 'boolean',
      description: 'Shows whether the booking was done by an external institution.',
    },
    Message: {
      type: 'string',
      description:
        'User readable notes about the status of the booking (e.g. if devices are unknown).',
    },
  },
  'x-standalone': true,
  'x-name': 'BookingResponse',
  'x-location': '#/components/schemas/Booking_response',
  'x-schema-type': 'response',
};
function validate38(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.ID === undefined && (missing0 = 'ID')) ||
        (data.Time === undefined && (missing0 = 'Time')) ||
        (data.Devices === undefined && (missing0 = 'Devices')) ||
        (data.Status === undefined && (missing0 = 'Status')) ||
        (data.You === undefined && (missing0 = 'You')) ||
        (data.External === undefined && (missing0 = 'External'))
      ) {
        validate38.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema23.required,
            parentSchema: schema23,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate38.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema23.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate38.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema23.properties.ID.type,
                    parentSchema: schema23.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data1 = data.Time;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                let missing1;
                if (
                  (data1.Start === undefined && (missing1 = 'Start')) ||
                  (data1.End === undefined && (missing1 = 'End'))
                ) {
                  validate38.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing1 },
                      message: "must have required property '" + missing1 + "'",
                      schema: schema23.properties.Time.required,
                      parentSchema: schema23.properties.Time,
                      data: data1,
                    },
                  ];
                  return false;
                } else {
                  if (data1.Start !== undefined) {
                    let data2 = data1.Start;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (errors === _errs5) {
                        if (typeof data2 === 'string') {
                          if (!formats2.validate(data2)) {
                            validate38.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema23.properties.Time.properties.Start,
                                data: data2,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate38.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema23.properties.Time.properties.Start.type,
                              parentSchema: schema23.properties.Time.properties.Start,
                              data: data2,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data1.End !== undefined) {
                      let data3 = data1.End;
                      const _errs7 = errors;
                      if (errors === _errs7) {
                        if (errors === _errs7) {
                          if (typeof data3 === 'string') {
                            if (!formats2.validate(data3)) {
                              validate38.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema23.properties.Time.properties.End,
                                  data: data3,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate38.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema23.properties.Time.properties.End.type,
                                parentSchema: schema23.properties.Time.properties.End,
                                data: data3,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid1 = _errs7 === errors;
                    } else {
                      var valid1 = true;
                    }
                  }
                }
              } else {
                validate38.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema23.properties.Time.type,
                    parentSchema: schema23.properties.Time,
                    data: data1,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Devices !== undefined) {
              let data4 = data.Devices;
              const _errs9 = errors;
              if (errors === _errs9) {
                if (Array.isArray(data4)) {
                  var valid2 = true;
                  const len0 = data4.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data5 = data4[i0];
                    const _errs11 = errors;
                    if (errors === _errs11) {
                      if (errors === _errs11) {
                        if (typeof data5 === 'string') {
                          if (!formats0(data5)) {
                            validate38.errors = [
                              {
                                instancePath: instancePath + '/Devices/' + i0,
                                schemaPath: '#/properties/Devices/items/format',
                                keyword: 'format',
                                params: { format: 'uri' },
                                message: 'must match format "' + 'uri' + '"',
                                schema: 'uri',
                                parentSchema: schema23.properties.Devices.items,
                                data: data5,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate38.errors = [
                            {
                              instancePath: instancePath + '/Devices/' + i0,
                              schemaPath: '#/properties/Devices/items/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema23.properties.Devices.items.type,
                              parentSchema: schema23.properties.Devices.items,
                              data: data5,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid2 = _errs11 === errors;
                    if (!valid2) {
                      break;
                    }
                  }
                } else {
                  validate38.errors = [
                    {
                      instancePath: instancePath + '/Devices',
                      schemaPath: '#/properties/Devices/type',
                      keyword: 'type',
                      params: { type: 'array' },
                      message: 'must be array',
                      schema: schema23.properties.Devices.type,
                      parentSchema: schema23.properties.Devices,
                      data: data4,
                    },
                  ];
                  return false;
                }
              }
              var valid0 = _errs9 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.Type !== undefined) {
                let data6 = data.Type;
                const _errs13 = errors;
                if (typeof data6 !== 'string') {
                  validate38.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema23.properties.Type.type,
                      parentSchema: schema23.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                if (!(data6 === 'normal')) {
                  validate38.errors = [
                    {
                      instancePath: instancePath + '/Type',
                      schemaPath: '#/properties/Type/enum',
                      keyword: 'enum',
                      params: { allowedValues: schema23.properties.Type.enum },
                      message: 'must be equal to one of the allowed values',
                      schema: schema23.properties.Type.enum,
                      parentSchema: schema23.properties.Type,
                      data: data6,
                    },
                  ];
                  return false;
                }
                var valid0 = _errs13 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.Status !== undefined) {
                  let data7 = data.Status;
                  const _errs15 = errors;
                  if (typeof data7 !== 'string') {
                    validate38.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/type',
                        keyword: 'type',
                        params: { type: 'string' },
                        message: 'must be string',
                        schema: schema23.properties.Status.type,
                        parentSchema: schema23.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  if (
                    !(
                      data7 === 'pending' ||
                      data7 === 'booked' ||
                      data7 === 'rejected' ||
                      data7 === 'cancelled' ||
                      data7 === 'active' ||
                      data7 === 'active-pending' ||
                      data7 === 'active-rejected'
                    )
                  ) {
                    validate38.errors = [
                      {
                        instancePath: instancePath + '/Status',
                        schemaPath: '#/properties/Status/enum',
                        keyword: 'enum',
                        params: { allowedValues: schema23.properties.Status.enum },
                        message: 'must be equal to one of the allowed values',
                        schema: schema23.properties.Status.enum,
                        parentSchema: schema23.properties.Status,
                        data: data7,
                      },
                    ];
                    return false;
                  }
                  var valid0 = _errs15 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.You !== undefined) {
                    let data8 = data.You;
                    const _errs17 = errors;
                    if (typeof data8 !== 'boolean') {
                      validate38.errors = [
                        {
                          instancePath: instancePath + '/You',
                          schemaPath: '#/properties/You/type',
                          keyword: 'type',
                          params: { type: 'boolean' },
                          message: 'must be boolean',
                          schema: schema23.properties.You.type,
                          parentSchema: schema23.properties.You,
                          data: data8,
                        },
                      ];
                      return false;
                    }
                    var valid0 = _errs17 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.External !== undefined) {
                      let data9 = data.External;
                      const _errs19 = errors;
                      if (typeof data9 !== 'boolean') {
                        validate38.errors = [
                          {
                            instancePath: instancePath + '/External',
                            schemaPath: '#/properties/External/type',
                            keyword: 'type',
                            params: { type: 'boolean' },
                            message: 'must be boolean',
                            schema: schema23.properties.External.type,
                            parentSchema: schema23.properties.External,
                            data: data9,
                          },
                        ];
                        return false;
                      }
                      var valid0 = _errs19 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.Message !== undefined) {
                        let data10 = data.Message;
                        const _errs21 = errors;
                        if (typeof data10 !== 'string') {
                          validate38.errors = [
                            {
                              instancePath: instancePath + '/Message',
                              schemaPath: '#/properties/Message/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema23.properties.Message.type,
                              parentSchema: schema23.properties.Message,
                              data: data10,
                            },
                          ];
                          return false;
                        }
                        var valid0 = _errs21 === errors;
                      } else {
                        var valid0 = true;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate38.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema23.type,
          parentSchema: schema23,
          data,
        },
      ];
      return false;
    }
  }
  validate38.errors = vErrors;
  return errors === 0;
}
exports.validateDeviceRequest = validate39;
const schema24 = {
  title: 'Device',
  description: 'A device might either be a physical/virtual device or a group of device.',
  type: 'object',
  required: ['ID'],
  properties: {
    ID: {
      type: 'string',
      description:
        'Unique ID of the device. Contains the institution (by having an end point at that institution)',
      format: 'uri',
    },
  },
  'x-standalone': true,
  'x-name': 'DeviceRequest',
  'x-location': '#/components/schemas/Device_request',
  'x-schema-type': 'request',
};
function validate39(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.ID === undefined && (missing0 = 'ID')) {
        validate39.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema24.required,
            parentSchema: schema24,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate39.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema24.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate39.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema24.properties.ID.type,
                    parentSchema: schema24.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate39.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema24.type,
          parentSchema: schema24,
          data,
        },
      ];
      return false;
    }
  }
  validate39.errors = vErrors;
  return errors === 0;
}
exports.validateDeviceResponse = validate40;
const schema25 = {
  title: 'Device',
  description: 'A device might either be a physical/virtual device or a group of device.',
  type: 'object',
  required: ['ID'],
  properties: {
    ID: {
      type: 'string',
      description:
        'Unique ID of the device. Contains the institution (by having an end point at that institution)',
      format: 'uri',
    },
  },
  'x-standalone': true,
  'x-name': 'DeviceResponse',
  'x-location': '#/components/schemas/Device_response',
  'x-schema-type': 'response',
};
function validate40(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.ID === undefined && (missing0 = 'ID')) {
        validate40.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema25.required,
            parentSchema: schema25,
            data,
          },
        ];
        return false;
      } else {
        if (data.ID !== undefined) {
          let data0 = data.ID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate40.errors = [
                    {
                      instancePath: instancePath + '/ID',
                      schemaPath: '#/properties/ID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema25.properties.ID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate40.errors = [
                  {
                    instancePath: instancePath + '/ID',
                    schemaPath: '#/properties/ID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema25.properties.ID.type,
                    parentSchema: schema25.properties.ID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate40.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema25.type,
          parentSchema: schema25,
          data,
        },
      ];
      return false;
    }
  }
  validate40.errors = vErrors;
  return errors === 0;
}
exports.validateExperimentRequest = validate41;
const schema26 = {
  title: 'Experiment',
  description:
    'An experiment describes a set of devices and how they should be connected (potentially among other metadata).',
  type: 'object',
  required: ['Devices'],
  properties: {
    Devices: {
      type: 'array',
      description: 'List of devices used in experiment.',
      items: {
        title: 'Device',
        description:
          'A device might either be a physical/virtual device or a group of device.',
        type: 'object',
        required: ['ID'],
        properties: {
          ID: {
            type: 'string',
            description:
              'Unique ID of the device. Contains the institution (by having an end point at that institution)',
            format: 'uri',
          },
        },
      },
    },
    Description: {
      type: 'string',
      description:
        'User provided description, for example might be a reason for the booking (e.g. maintenance) or a link to the experiment. Might be empty or missing.',
    },
  },
  'x-standalone': true,
  'x-name': 'ExperimentRequest',
  'x-location': '#/components/schemas/Experiment_request',
  'x-schema-type': 'request',
};
function validate41(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.Devices === undefined && (missing0 = 'Devices')) {
        validate41.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema26.required,
            parentSchema: schema26,
            data,
          },
        ];
        return false;
      } else {
        if (data.Devices !== undefined) {
          let data0 = data.Devices;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (Array.isArray(data0)) {
              var valid1 = true;
              const len0 = data0.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data1 = data0[i0];
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                    let missing1;
                    if (data1.ID === undefined && (missing1 = 'ID')) {
                      validate41.errors = [
                        {
                          instancePath: instancePath + '/Devices/' + i0,
                          schemaPath: '#/properties/Devices/items/required',
                          keyword: 'required',
                          params: { missingProperty: missing1 },
                          message: "must have required property '" + missing1 + "'",
                          schema: schema26.properties.Devices.items.required,
                          parentSchema: schema26.properties.Devices.items,
                          data: data1,
                        },
                      ];
                      return false;
                    } else {
                      if (data1.ID !== undefined) {
                        let data2 = data1.ID;
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (errors === _errs5) {
                            if (typeof data2 === 'string') {
                              if (!formats0(data2)) {
                                validate41.errors = [
                                  {
                                    instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                    schemaPath:
                                      '#/properties/Devices/items/properties/ID/format',
                                    keyword: 'format',
                                    params: { format: 'uri' },
                                    message: 'must match format "' + 'uri' + '"',
                                    schema: 'uri',
                                    parentSchema:
                                      schema26.properties.Devices.items.properties.ID,
                                    data: data2,
                                  },
                                ];
                                return false;
                              }
                            } else {
                              validate41.errors = [
                                {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/properties/Devices/items/properties/ID/type',
                                  keyword: 'type',
                                  params: { type: 'string' },
                                  message: 'must be string',
                                  schema:
                                    schema26.properties.Devices.items.properties.ID.type,
                                  parentSchema:
                                    schema26.properties.Devices.items.properties.ID,
                                  data: data2,
                                },
                              ];
                              return false;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate41.errors = [
                      {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/properties/Devices/items/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                        schema: schema26.properties.Devices.items.type,
                        parentSchema: schema26.properties.Devices.items,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                }
                var valid1 = _errs3 === errors;
                if (!valid1) {
                  break;
                }
              }
            } else {
              validate41.errors = [
                {
                  instancePath: instancePath + '/Devices',
                  schemaPath: '#/properties/Devices/type',
                  keyword: 'type',
                  params: { type: 'array' },
                  message: 'must be array',
                  schema: schema26.properties.Devices.type,
                  parentSchema: schema26.properties.Devices,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Description !== undefined) {
            let data3 = data.Description;
            const _errs7 = errors;
            if (typeof data3 !== 'string') {
              validate41.errors = [
                {
                  instancePath: instancePath + '/Description',
                  schemaPath: '#/properties/Description/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema26.properties.Description.type,
                  parentSchema: schema26.properties.Description,
                  data: data3,
                },
              ];
              return false;
            }
            var valid0 = _errs7 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate41.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema26.type,
          parentSchema: schema26,
          data,
        },
      ];
      return false;
    }
  }
  validate41.errors = vErrors;
  return errors === 0;
}
exports.validateExperimentResponse = validate42;
const schema27 = {
  title: 'Experiment',
  description:
    'An experiment describes a set of devices and how they should be connected (potentially among other metadata).',
  type: 'object',
  required: ['Devices'],
  properties: {
    Devices: {
      type: 'array',
      description: 'List of devices used in experiment.',
      items: {
        title: 'Device',
        description:
          'A device might either be a physical/virtual device or a group of device.',
        type: 'object',
        required: ['ID'],
        properties: {
          ID: {
            type: 'string',
            description:
              'Unique ID of the device. Contains the institution (by having an end point at that institution)',
            format: 'uri',
          },
        },
      },
    },
    Description: {
      type: 'string',
      description:
        'User provided description, for example might be a reason for the booking (e.g. maintenance) or a link to the experiment. Might be empty or missing.',
    },
  },
  'x-standalone': true,
  'x-name': 'ExperimentResponse',
  'x-location': '#/components/schemas/Experiment_response',
  'x-schema-type': 'response',
};
function validate42(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.Devices === undefined && (missing0 = 'Devices')) {
        validate42.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema27.required,
            parentSchema: schema27,
            data,
          },
        ];
        return false;
      } else {
        if (data.Devices !== undefined) {
          let data0 = data.Devices;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (Array.isArray(data0)) {
              var valid1 = true;
              const len0 = data0.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data1 = data0[i0];
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                    let missing1;
                    if (data1.ID === undefined && (missing1 = 'ID')) {
                      validate42.errors = [
                        {
                          instancePath: instancePath + '/Devices/' + i0,
                          schemaPath: '#/properties/Devices/items/required',
                          keyword: 'required',
                          params: { missingProperty: missing1 },
                          message: "must have required property '" + missing1 + "'",
                          schema: schema27.properties.Devices.items.required,
                          parentSchema: schema27.properties.Devices.items,
                          data: data1,
                        },
                      ];
                      return false;
                    } else {
                      if (data1.ID !== undefined) {
                        let data2 = data1.ID;
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (errors === _errs5) {
                            if (typeof data2 === 'string') {
                              if (!formats0(data2)) {
                                validate42.errors = [
                                  {
                                    instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                    schemaPath:
                                      '#/properties/Devices/items/properties/ID/format',
                                    keyword: 'format',
                                    params: { format: 'uri' },
                                    message: 'must match format "' + 'uri' + '"',
                                    schema: 'uri',
                                    parentSchema:
                                      schema27.properties.Devices.items.properties.ID,
                                    data: data2,
                                  },
                                ];
                                return false;
                              }
                            } else {
                              validate42.errors = [
                                {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/properties/Devices/items/properties/ID/type',
                                  keyword: 'type',
                                  params: { type: 'string' },
                                  message: 'must be string',
                                  schema:
                                    schema27.properties.Devices.items.properties.ID.type,
                                  parentSchema:
                                    schema27.properties.Devices.items.properties.ID,
                                  data: data2,
                                },
                              ];
                              return false;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate42.errors = [
                      {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/properties/Devices/items/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                        schema: schema27.properties.Devices.items.type,
                        parentSchema: schema27.properties.Devices.items,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                }
                var valid1 = _errs3 === errors;
                if (!valid1) {
                  break;
                }
              }
            } else {
              validate42.errors = [
                {
                  instancePath: instancePath + '/Devices',
                  schemaPath: '#/properties/Devices/type',
                  keyword: 'type',
                  params: { type: 'array' },
                  message: 'must be array',
                  schema: schema27.properties.Devices.type,
                  parentSchema: schema27.properties.Devices,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Description !== undefined) {
            let data3 = data.Description;
            const _errs7 = errors;
            if (typeof data3 !== 'string') {
              validate42.errors = [
                {
                  instancePath: instancePath + '/Description',
                  schemaPath: '#/properties/Description/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema27.properties.Description.type,
                  parentSchema: schema27.properties.Description,
                  data: data3,
                },
              ];
              return false;
            }
            var valid0 = _errs7 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate42.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema27.type,
          parentSchema: schema27,
          data,
        },
      ];
      return false;
    }
  }
  validate42.errors = vErrors;
  return errors === 0;
}
exports.validateTimeslotRequest = validate43;
const schema28 = {
  title: 'Timeslot',
  description: 'A time slot represents a slice of time used for bookings.',
  type: 'object',
  required: ['Start', 'End'],
  properties: {
    Start: {
      type: 'string',
      description: 'Start time of the booking.',
      format: 'date-time',
    },
    End: { type: 'string', description: 'End time of the booking.', format: 'date-time' },
  },
  'x-standalone': true,
  'x-name': 'TimeslotRequest',
  'x-location': '#/components/schemas/Timeslot_request',
  'x-schema-type': 'request',
};
function validate43(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Start === undefined && (missing0 = 'Start')) ||
        (data.End === undefined && (missing0 = 'End'))
      ) {
        validate43.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema28.required,
            parentSchema: schema28,
            data,
          },
        ];
        return false;
      } else {
        if (data.Start !== undefined) {
          let data0 = data.Start;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats2.validate(data0)) {
                  validate43.errors = [
                    {
                      instancePath: instancePath + '/Start',
                      schemaPath: '#/properties/Start/format',
                      keyword: 'format',
                      params: { format: 'date-time' },
                      message: 'must match format "' + 'date-time' + '"',
                      schema: 'date-time',
                      parentSchema: schema28.properties.Start,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate43.errors = [
                  {
                    instancePath: instancePath + '/Start',
                    schemaPath: '#/properties/Start/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema28.properties.Start.type,
                    parentSchema: schema28.properties.Start,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.End !== undefined) {
            let data1 = data.End;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (errors === _errs3) {
                if (typeof data1 === 'string') {
                  if (!formats2.validate(data1)) {
                    validate43.errors = [
                      {
                        instancePath: instancePath + '/End',
                        schemaPath: '#/properties/End/format',
                        keyword: 'format',
                        params: { format: 'date-time' },
                        message: 'must match format "' + 'date-time' + '"',
                        schema: 'date-time',
                        parentSchema: schema28.properties.End,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                } else {
                  validate43.errors = [
                    {
                      instancePath: instancePath + '/End',
                      schemaPath: '#/properties/End/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema28.properties.End.type,
                      parentSchema: schema28.properties.End,
                      data: data1,
                    },
                  ];
                  return false;
                }
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate43.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema28.type,
          parentSchema: schema28,
          data,
        },
      ];
      return false;
    }
  }
  validate43.errors = vErrors;
  return errors === 0;
}
exports.validateTimeslotResponse = validate44;
const schema29 = {
  title: 'Timeslot',
  description: 'A time slot represents a slice of time used for bookings.',
  type: 'object',
  required: ['Start', 'End'],
  properties: {
    Start: {
      type: 'string',
      description: 'Start time of the booking.',
      format: 'date-time',
    },
    End: { type: 'string', description: 'End time of the booking.', format: 'date-time' },
  },
  'x-standalone': true,
  'x-name': 'TimeslotResponse',
  'x-location': '#/components/schemas/Timeslot_response',
  'x-schema-type': 'response',
};
function validate44(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Start === undefined && (missing0 = 'Start')) ||
        (data.End === undefined && (missing0 = 'End'))
      ) {
        validate44.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema29.required,
            parentSchema: schema29,
            data,
          },
        ];
        return false;
      } else {
        if (data.Start !== undefined) {
          let data0 = data.Start;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats2.validate(data0)) {
                  validate44.errors = [
                    {
                      instancePath: instancePath + '/Start',
                      schemaPath: '#/properties/Start/format',
                      keyword: 'format',
                      params: { format: 'date-time' },
                      message: 'must match format "' + 'date-time' + '"',
                      schema: 'date-time',
                      parentSchema: schema29.properties.Start,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate44.errors = [
                  {
                    instancePath: instancePath + '/Start',
                    schemaPath: '#/properties/Start/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema29.properties.Start.type,
                    parentSchema: schema29.properties.Start,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.End !== undefined) {
            let data1 = data.End;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (errors === _errs3) {
                if (typeof data1 === 'string') {
                  if (!formats2.validate(data1)) {
                    validate44.errors = [
                      {
                        instancePath: instancePath + '/End',
                        schemaPath: '#/properties/End/format',
                        keyword: 'format',
                        params: { format: 'date-time' },
                        message: 'must match format "' + 'date-time' + '"',
                        schema: 'date-time',
                        parentSchema: schema29.properties.End,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                } else {
                  validate44.errors = [
                    {
                      instancePath: instancePath + '/End',
                      schemaPath: '#/properties/End/type',
                      keyword: 'type',
                      params: { type: 'string' },
                      message: 'must be string',
                      schema: schema29.properties.End.type,
                      parentSchema: schema29.properties.End,
                      data: data1,
                    },
                  ];
                  return false;
                }
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate44.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema29.type,
          parentSchema: schema29,
          data,
        },
      ];
      return false;
    }
  }
  validate44.errors = vErrors;
  return errors === 0;
}
exports.validateIDRequest = validate45;
const schema30 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'IDRequest',
  'x-location': '#/components/parameters/ID/schema_request',
  'x-schema-type': 'request',
};
function validate45(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate45.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema30.type,
        parentSchema: schema30,
        data,
      },
    ];
    return false;
  }
  validate45.errors = vErrors;
  return errors === 0;
}
exports.validateIDResponse = validate46;
const schema31 = {
  type: 'string',
  'x-standalone': false,
  'x-name': 'IDResponse',
  'x-location': '#/components/parameters/ID/schema_response',
  'x-schema-type': 'response',
};
function validate46(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate46.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema31.type,
        parentSchema: schema31,
        data,
      },
    ];
    return false;
  }
  validate46.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingBodyRequest = validate47;
const schema32 = {
  type: 'object',
  required: ['Devices', 'Time'],
  properties: {
    Devices: {
      type: 'array',
      description: 'List of devices which should be added.',
      items: {
        title: 'Device',
        description:
          'A device might either be a physical/virtual device or a group of device.',
        type: 'object',
        required: ['ID'],
        properties: {
          ID: {
            type: 'string',
            description:
              'Unique ID of the device. Contains the institution (by having an end point at that institution)',
            format: 'uri',
          },
        },
      },
    },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Type: {
      description:
        "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
      type: 'string',
      enum: ['normal'],
    },
  },
  'x-standalone': false,
  'x-name': 'newBookingBodyRequest',
  'x-location':
    '#/paths//booking/post/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate47(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Devices === undefined && (missing0 = 'Devices')) ||
        (data.Time === undefined && (missing0 = 'Time'))
      ) {
        validate47.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema32.required,
            parentSchema: schema32,
            data,
          },
        ];
        return false;
      } else {
        if (data.Devices !== undefined) {
          let data0 = data.Devices;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (Array.isArray(data0)) {
              var valid1 = true;
              const len0 = data0.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data1 = data0[i0];
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                    let missing1;
                    if (data1.ID === undefined && (missing1 = 'ID')) {
                      validate47.errors = [
                        {
                          instancePath: instancePath + '/Devices/' + i0,
                          schemaPath: '#/properties/Devices/items/required',
                          keyword: 'required',
                          params: { missingProperty: missing1 },
                          message: "must have required property '" + missing1 + "'",
                          schema: schema32.properties.Devices.items.required,
                          parentSchema: schema32.properties.Devices.items,
                          data: data1,
                        },
                      ];
                      return false;
                    } else {
                      if (data1.ID !== undefined) {
                        let data2 = data1.ID;
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (errors === _errs5) {
                            if (typeof data2 === 'string') {
                              if (!formats0(data2)) {
                                validate47.errors = [
                                  {
                                    instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                    schemaPath:
                                      '#/properties/Devices/items/properties/ID/format',
                                    keyword: 'format',
                                    params: { format: 'uri' },
                                    message: 'must match format "' + 'uri' + '"',
                                    schema: 'uri',
                                    parentSchema:
                                      schema32.properties.Devices.items.properties.ID,
                                    data: data2,
                                  },
                                ];
                                return false;
                              }
                            } else {
                              validate47.errors = [
                                {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/properties/Devices/items/properties/ID/type',
                                  keyword: 'type',
                                  params: { type: 'string' },
                                  message: 'must be string',
                                  schema:
                                    schema32.properties.Devices.items.properties.ID.type,
                                  parentSchema:
                                    schema32.properties.Devices.items.properties.ID,
                                  data: data2,
                                },
                              ];
                              return false;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate47.errors = [
                      {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/properties/Devices/items/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                        schema: schema32.properties.Devices.items.type,
                        parentSchema: schema32.properties.Devices.items,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                }
                var valid1 = _errs3 === errors;
                if (!valid1) {
                  break;
                }
              }
            } else {
              validate47.errors = [
                {
                  instancePath: instancePath + '/Devices',
                  schemaPath: '#/properties/Devices/type',
                  keyword: 'type',
                  params: { type: 'array' },
                  message: 'must be array',
                  schema: schema32.properties.Devices.type,
                  parentSchema: schema32.properties.Devices,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data3 = data.Time;
            const _errs7 = errors;
            if (errors === _errs7) {
              if (data3 && typeof data3 == 'object' && !Array.isArray(data3)) {
                let missing2;
                if (
                  (data3.Start === undefined && (missing2 = 'Start')) ||
                  (data3.End === undefined && (missing2 = 'End'))
                ) {
                  validate47.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing2 },
                      message: "must have required property '" + missing2 + "'",
                      schema: schema32.properties.Time.required,
                      parentSchema: schema32.properties.Time,
                      data: data3,
                    },
                  ];
                  return false;
                } else {
                  if (data3.Start !== undefined) {
                    let data4 = data3.Start;
                    const _errs9 = errors;
                    if (errors === _errs9) {
                      if (errors === _errs9) {
                        if (typeof data4 === 'string') {
                          if (!formats2.validate(data4)) {
                            validate47.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema32.properties.Time.properties.Start,
                                data: data4,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate47.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema32.properties.Time.properties.Start.type,
                              parentSchema: schema32.properties.Time.properties.Start,
                              data: data4,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid3 = _errs9 === errors;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data3.End !== undefined) {
                      let data5 = data3.End;
                      const _errs11 = errors;
                      if (errors === _errs11) {
                        if (errors === _errs11) {
                          if (typeof data5 === 'string') {
                            if (!formats2.validate(data5)) {
                              validate47.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema32.properties.Time.properties.End,
                                  data: data5,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate47.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema32.properties.Time.properties.End.type,
                                parentSchema: schema32.properties.Time.properties.End,
                                data: data5,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid3 = _errs11 === errors;
                    } else {
                      var valid3 = true;
                    }
                  }
                }
              } else {
                validate47.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema32.properties.Time.type,
                    parentSchema: schema32.properties.Time,
                    data: data3,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs7 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Type !== undefined) {
              let data6 = data.Type;
              const _errs13 = errors;
              if (typeof data6 !== 'string') {
                validate47.errors = [
                  {
                    instancePath: instancePath + '/Type',
                    schemaPath: '#/properties/Type/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema32.properties.Type.type,
                    parentSchema: schema32.properties.Type,
                    data: data6,
                  },
                ];
                return false;
              }
              if (!(data6 === 'normal')) {
                validate47.errors = [
                  {
                    instancePath: instancePath + '/Type',
                    schemaPath: '#/properties/Type/enum',
                    keyword: 'enum',
                    params: { allowedValues: schema32.properties.Type.enum },
                    message: 'must be equal to one of the allowed values',
                    schema: schema32.properties.Type.enum,
                    parentSchema: schema32.properties.Type,
                    data: data6,
                  },
                ];
                return false;
              }
              var valid0 = _errs13 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate47.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema32.type,
          parentSchema: schema32,
          data,
        },
      ];
      return false;
    }
  }
  validate47.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingBodyResponse = validate48;
const schema33 = {
  type: 'object',
  required: ['Devices', 'Time'],
  properties: {
    Devices: {
      type: 'array',
      description: 'List of devices which should be added.',
      items: {
        title: 'Device',
        description:
          'A device might either be a physical/virtual device or a group of device.',
        type: 'object',
        required: ['ID'],
        properties: {
          ID: {
            type: 'string',
            description:
              'Unique ID of the device. Contains the institution (by having an end point at that institution)',
            format: 'uri',
          },
        },
      },
    },
    Time: {
      title: 'Timeslot',
      description: 'A time slot represents a slice of time used for bookings.',
      type: 'object',
      required: ['Start', 'End'],
      properties: {
        Start: {
          type: 'string',
          description: 'Start time of the booking.',
          format: 'date-time',
        },
        End: {
          type: 'string',
          description: 'End time of the booking.',
          format: 'date-time',
        },
      },
    },
    Type: {
      description:
        "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
      type: 'string',
      enum: ['normal'],
    },
  },
  'x-standalone': false,
  'x-name': 'newBookingBodyResponse',
  'x-location':
    '#/paths//booking/post/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate48(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Devices === undefined && (missing0 = 'Devices')) ||
        (data.Time === undefined && (missing0 = 'Time'))
      ) {
        validate48.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema33.required,
            parentSchema: schema33,
            data,
          },
        ];
        return false;
      } else {
        if (data.Devices !== undefined) {
          let data0 = data.Devices;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (Array.isArray(data0)) {
              var valid1 = true;
              const len0 = data0.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data1 = data0[i0];
                const _errs3 = errors;
                if (errors === _errs3) {
                  if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                    let missing1;
                    if (data1.ID === undefined && (missing1 = 'ID')) {
                      validate48.errors = [
                        {
                          instancePath: instancePath + '/Devices/' + i0,
                          schemaPath: '#/properties/Devices/items/required',
                          keyword: 'required',
                          params: { missingProperty: missing1 },
                          message: "must have required property '" + missing1 + "'",
                          schema: schema33.properties.Devices.items.required,
                          parentSchema: schema33.properties.Devices.items,
                          data: data1,
                        },
                      ];
                      return false;
                    } else {
                      if (data1.ID !== undefined) {
                        let data2 = data1.ID;
                        const _errs5 = errors;
                        if (errors === _errs5) {
                          if (errors === _errs5) {
                            if (typeof data2 === 'string') {
                              if (!formats0(data2)) {
                                validate48.errors = [
                                  {
                                    instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                    schemaPath:
                                      '#/properties/Devices/items/properties/ID/format',
                                    keyword: 'format',
                                    params: { format: 'uri' },
                                    message: 'must match format "' + 'uri' + '"',
                                    schema: 'uri',
                                    parentSchema:
                                      schema33.properties.Devices.items.properties.ID,
                                    data: data2,
                                  },
                                ];
                                return false;
                              }
                            } else {
                              validate48.errors = [
                                {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/properties/Devices/items/properties/ID/type',
                                  keyword: 'type',
                                  params: { type: 'string' },
                                  message: 'must be string',
                                  schema:
                                    schema33.properties.Devices.items.properties.ID.type,
                                  parentSchema:
                                    schema33.properties.Devices.items.properties.ID,
                                  data: data2,
                                },
                              ];
                              return false;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate48.errors = [
                      {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/properties/Devices/items/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                        schema: schema33.properties.Devices.items.type,
                        parentSchema: schema33.properties.Devices.items,
                        data: data1,
                      },
                    ];
                    return false;
                  }
                }
                var valid1 = _errs3 === errors;
                if (!valid1) {
                  break;
                }
              }
            } else {
              validate48.errors = [
                {
                  instancePath: instancePath + '/Devices',
                  schemaPath: '#/properties/Devices/type',
                  keyword: 'type',
                  params: { type: 'array' },
                  message: 'must be array',
                  schema: schema33.properties.Devices.type,
                  parentSchema: schema33.properties.Devices,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Time !== undefined) {
            let data3 = data.Time;
            const _errs7 = errors;
            if (errors === _errs7) {
              if (data3 && typeof data3 == 'object' && !Array.isArray(data3)) {
                let missing2;
                if (
                  (data3.Start === undefined && (missing2 = 'Start')) ||
                  (data3.End === undefined && (missing2 = 'End'))
                ) {
                  validate48.errors = [
                    {
                      instancePath: instancePath + '/Time',
                      schemaPath: '#/properties/Time/required',
                      keyword: 'required',
                      params: { missingProperty: missing2 },
                      message: "must have required property '" + missing2 + "'",
                      schema: schema33.properties.Time.required,
                      parentSchema: schema33.properties.Time,
                      data: data3,
                    },
                  ];
                  return false;
                } else {
                  if (data3.Start !== undefined) {
                    let data4 = data3.Start;
                    const _errs9 = errors;
                    if (errors === _errs9) {
                      if (errors === _errs9) {
                        if (typeof data4 === 'string') {
                          if (!formats2.validate(data4)) {
                            validate48.errors = [
                              {
                                instancePath: instancePath + '/Time/Start',
                                schemaPath: '#/properties/Time/properties/Start/format',
                                keyword: 'format',
                                params: { format: 'date-time' },
                                message: 'must match format "' + 'date-time' + '"',
                                schema: 'date-time',
                                parentSchema: schema33.properties.Time.properties.Start,
                                data: data4,
                              },
                            ];
                            return false;
                          }
                        } else {
                          validate48.errors = [
                            {
                              instancePath: instancePath + '/Time/Start',
                              schemaPath: '#/properties/Time/properties/Start/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema33.properties.Time.properties.Start.type,
                              parentSchema: schema33.properties.Time.properties.Start,
                              data: data4,
                            },
                          ];
                          return false;
                        }
                      }
                    }
                    var valid3 = _errs9 === errors;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data3.End !== undefined) {
                      let data5 = data3.End;
                      const _errs11 = errors;
                      if (errors === _errs11) {
                        if (errors === _errs11) {
                          if (typeof data5 === 'string') {
                            if (!formats2.validate(data5)) {
                              validate48.errors = [
                                {
                                  instancePath: instancePath + '/Time/End',
                                  schemaPath: '#/properties/Time/properties/End/format',
                                  keyword: 'format',
                                  params: { format: 'date-time' },
                                  message: 'must match format "' + 'date-time' + '"',
                                  schema: 'date-time',
                                  parentSchema: schema33.properties.Time.properties.End,
                                  data: data5,
                                },
                              ];
                              return false;
                            }
                          } else {
                            validate48.errors = [
                              {
                                instancePath: instancePath + '/Time/End',
                                schemaPath: '#/properties/Time/properties/End/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema: schema33.properties.Time.properties.End.type,
                                parentSchema: schema33.properties.Time.properties.End,
                                data: data5,
                              },
                            ];
                            return false;
                          }
                        }
                      }
                      var valid3 = _errs11 === errors;
                    } else {
                      var valid3 = true;
                    }
                  }
                }
              } else {
                validate48.errors = [
                  {
                    instancePath: instancePath + '/Time',
                    schemaPath: '#/properties/Time/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                    schema: schema33.properties.Time.type,
                    parentSchema: schema33.properties.Time,
                    data: data3,
                  },
                ];
                return false;
              }
            }
            var valid0 = _errs7 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.Type !== undefined) {
              let data6 = data.Type;
              const _errs13 = errors;
              if (typeof data6 !== 'string') {
                validate48.errors = [
                  {
                    instancePath: instancePath + '/Type',
                    schemaPath: '#/properties/Type/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema33.properties.Type.type,
                    parentSchema: schema33.properties.Type,
                    data: data6,
                  },
                ];
                return false;
              }
              if (!(data6 === 'normal')) {
                validate48.errors = [
                  {
                    instancePath: instancePath + '/Type',
                    schemaPath: '#/properties/Type/enum',
                    keyword: 'enum',
                    params: { allowedValues: schema33.properties.Type.enum },
                    message: 'must be equal to one of the allowed values',
                    schema: schema33.properties.Type.enum,
                    parentSchema: schema33.properties.Type,
                    data: data6,
                  },
                ];
                return false;
              }
              var valid0 = _errs13 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate48.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema33.type,
          parentSchema: schema33,
          data,
        },
      ];
      return false;
    }
  }
  validate48.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingResponse200Request = validate49;
const schema34 = {
  type: 'object',
  required: ['BookingID'],
  properties: {
    BookingID: {
      type: 'string',
      format: 'uri',
      description: 'ID at which the booking can be managed.',
    },
  },
  'x-standalone': false,
  'x-name': 'newBookingResponse200Request',
  'x-location':
    '#/paths//booking/post/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate49(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.BookingID === undefined && (missing0 = 'BookingID')) {
        validate49.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema34.required,
            parentSchema: schema34,
            data,
          },
        ];
        return false;
      } else {
        if (data.BookingID !== undefined) {
          let data0 = data.BookingID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate49.errors = [
                    {
                      instancePath: instancePath + '/BookingID',
                      schemaPath: '#/properties/BookingID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema34.properties.BookingID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate49.errors = [
                  {
                    instancePath: instancePath + '/BookingID',
                    schemaPath: '#/properties/BookingID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema34.properties.BookingID.type,
                    parentSchema: schema34.properties.BookingID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate49.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema34.type,
          parentSchema: schema34,
          data,
        },
      ];
      return false;
    }
  }
  validate49.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingResponse200Response = validate50;
const schema35 = {
  type: 'object',
  required: ['BookingID'],
  properties: {
    BookingID: {
      type: 'string',
      format: 'uri',
      description: 'ID at which the booking can be managed.',
    },
  },
  'x-standalone': false,
  'x-name': 'newBookingResponse200Response',
  'x-location':
    '#/paths//booking/post/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate50(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.BookingID === undefined && (missing0 = 'BookingID')) {
        validate50.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema35.required,
            parentSchema: schema35,
            data,
          },
        ];
        return false;
      } else {
        if (data.BookingID !== undefined) {
          let data0 = data.BookingID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate50.errors = [
                    {
                      instancePath: instancePath + '/BookingID',
                      schemaPath: '#/properties/BookingID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema35.properties.BookingID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate50.errors = [
                  {
                    instancePath: instancePath + '/BookingID',
                    schemaPath: '#/properties/BookingID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema35.properties.BookingID.type,
                    parentSchema: schema35.properties.BookingID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate50.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema35.type,
          parentSchema: schema35,
          data,
        },
      ];
      return false;
    }
  }
  validate50.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingResponse500Request = validate51;
const schema36 = {
  description: 'Error description',
  type: 'string',
  'x-standalone': false,
  'x-name': 'newBookingResponse500Request',
  'x-location':
    '#/paths//booking/post/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate51(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate51.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema36.type,
        parentSchema: schema36,
        data,
      },
    ];
    return false;
  }
  validate51.errors = vErrors;
  return errors === 0;
}
exports.validateNewBookingResponse500Response = validate52;
const schema37 = {
  description: 'Error description',
  type: 'string',
  'x-standalone': false,
  'x-name': 'newBookingResponse500Response',
  'x-location':
    '#/paths//booking/post/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate52(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate52.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema37.type,
        parentSchema: schema37,
        data,
      },
    ];
    return false;
  }
  validate52.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingBodyRequest = validate53;
const schema38 = {
  anyOf: [
    {
      type: 'object',
      description: 'Use this request for adding devices.',
      properties: {
        Locked: {
          type: 'boolean',
          description:
            'Expresses whether the devices should be locked. Must match current status of booking. Is assumed to be false if not set.',
        },
        Devices: {
          type: 'array',
          description: 'List of devices which should be added.',
          items: {
            title: 'Device',
            description:
              'A device might either be a physical/virtual device or a group of device.',
            type: 'object',
            required: ['ID'],
            properties: {
              ID: {
                type: 'string',
                description:
                  'Unique ID of the device. Contains the institution (by having an end point at that institution)',
                format: 'uri',
              },
            },
          },
        },
      },
    },
    {
      type: 'object',
      description: 'Use this request for adding callbacks.',
      properties: {
        Callback: {
          type: 'string',
          format: 'uri',
          description: 'Callback which should be called at changes.',
        },
      },
    },
  ],
  'x-standalone': false,
  'x-name': 'updateBookingBodyRequest',
  'x-location':
    '#/paths//booking/{ID}/patch/requestBody/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate53(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  let valid0 = false;
  const _errs1 = errors;
  if (errors === _errs1) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.Locked !== undefined) {
        let data0 = data.Locked;
        const _errs3 = errors;
        if (typeof data0 !== 'boolean') {
          const err0 = {
            instancePath: instancePath + '/Locked',
            schemaPath: '#/anyOf/0/properties/Locked/type',
            keyword: 'type',
            params: { type: 'boolean' },
            message: 'must be boolean',
            schema: schema38.anyOf[0].properties.Locked.type,
            parentSchema: schema38.anyOf[0].properties.Locked,
            data: data0,
          };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
        var valid1 = _errs3 === errors;
      } else {
        var valid1 = true;
      }
      if (valid1) {
        if (data.Devices !== undefined) {
          let data1 = data.Devices;
          const _errs5 = errors;
          if (errors === _errs5) {
            if (Array.isArray(data1)) {
              var valid2 = true;
              const len0 = data1.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data2 = data1[i0];
                const _errs7 = errors;
                if (errors === _errs7) {
                  if (data2 && typeof data2 == 'object' && !Array.isArray(data2)) {
                    let missing0;
                    if (data2.ID === undefined && (missing0 = 'ID')) {
                      const err1 = {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/anyOf/0/properties/Devices/items/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                        schema: schema38.anyOf[0].properties.Devices.items.required,
                        parentSchema: schema38.anyOf[0].properties.Devices.items,
                        data: data2,
                      };
                      if (vErrors === null) {
                        vErrors = [err1];
                      } else {
                        vErrors.push(err1);
                      }
                      errors++;
                    } else {
                      if (data2.ID !== undefined) {
                        let data3 = data2.ID;
                        const _errs9 = errors;
                        if (errors === _errs9) {
                          if (errors === _errs9) {
                            if (typeof data3 === 'string') {
                              if (!formats0(data3)) {
                                const err2 = {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/anyOf/0/properties/Devices/items/properties/ID/format',
                                  keyword: 'format',
                                  params: { format: 'uri' },
                                  message: 'must match format "' + 'uri' + '"',
                                  schema: 'uri',
                                  parentSchema:
                                    schema38.anyOf[0].properties.Devices.items.properties
                                      .ID,
                                  data: data3,
                                };
                                if (vErrors === null) {
                                  vErrors = [err2];
                                } else {
                                  vErrors.push(err2);
                                }
                                errors++;
                              }
                            } else {
                              const err3 = {
                                instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                schemaPath:
                                  '#/anyOf/0/properties/Devices/items/properties/ID/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema:
                                  schema38.anyOf[0].properties.Devices.items.properties.ID
                                    .type,
                                parentSchema:
                                  schema38.anyOf[0].properties.Devices.items.properties
                                    .ID,
                                data: data3,
                              };
                              if (vErrors === null) {
                                vErrors = [err3];
                              } else {
                                vErrors.push(err3);
                              }
                              errors++;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    const err4 = {
                      instancePath: instancePath + '/Devices/' + i0,
                      schemaPath: '#/anyOf/0/properties/Devices/items/type',
                      keyword: 'type',
                      params: { type: 'object' },
                      message: 'must be object',
                      schema: schema38.anyOf[0].properties.Devices.items.type,
                      parentSchema: schema38.anyOf[0].properties.Devices.items,
                      data: data2,
                    };
                    if (vErrors === null) {
                      vErrors = [err4];
                    } else {
                      vErrors.push(err4);
                    }
                    errors++;
                  }
                }
                var valid2 = _errs7 === errors;
                if (!valid2) {
                  break;
                }
              }
            } else {
              const err5 = {
                instancePath: instancePath + '/Devices',
                schemaPath: '#/anyOf/0/properties/Devices/type',
                keyword: 'type',
                params: { type: 'array' },
                message: 'must be array',
                schema: schema38.anyOf[0].properties.Devices.type,
                parentSchema: schema38.anyOf[0].properties.Devices,
                data: data1,
              };
              if (vErrors === null) {
                vErrors = [err5];
              } else {
                vErrors.push(err5);
              }
              errors++;
            }
          }
          var valid1 = _errs5 === errors;
        } else {
          var valid1 = true;
        }
      }
    } else {
      const err6 = {
        instancePath,
        schemaPath: '#/anyOf/0/type',
        keyword: 'type',
        params: { type: 'object' },
        message: 'must be object',
        schema: schema38.anyOf[0].type,
        parentSchema: schema38.anyOf[0],
        data,
      };
      if (vErrors === null) {
        vErrors = [err6];
      } else {
        vErrors.push(err6);
      }
      errors++;
    }
  }
  var _valid0 = _errs1 === errors;
  valid0 = valid0 || _valid0;
  if (!valid0) {
    const _errs11 = errors;
    if (errors === _errs11) {
      if (data && typeof data == 'object' && !Array.isArray(data)) {
        if (data.Callback !== undefined) {
          let data4 = data.Callback;
          const _errs13 = errors;
          if (errors === _errs13) {
            if (errors === _errs13) {
              if (typeof data4 === 'string') {
                if (!formats0(data4)) {
                  const err7 = {
                    instancePath: instancePath + '/Callback',
                    schemaPath: '#/anyOf/1/properties/Callback/format',
                    keyword: 'format',
                    params: { format: 'uri' },
                    message: 'must match format "' + 'uri' + '"',
                    schema: 'uri',
                    parentSchema: schema38.anyOf[1].properties.Callback,
                    data: data4,
                  };
                  if (vErrors === null) {
                    vErrors = [err7];
                  } else {
                    vErrors.push(err7);
                  }
                  errors++;
                }
              } else {
                const err8 = {
                  instancePath: instancePath + '/Callback',
                  schemaPath: '#/anyOf/1/properties/Callback/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema38.anyOf[1].properties.Callback.type,
                  parentSchema: schema38.anyOf[1].properties.Callback,
                  data: data4,
                };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors++;
              }
            }
          }
        }
      } else {
        const err9 = {
          instancePath,
          schemaPath: '#/anyOf/1/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema38.anyOf[1].type,
          parentSchema: schema38.anyOf[1],
          data,
        };
        if (vErrors === null) {
          vErrors = [err9];
        } else {
          vErrors.push(err9);
        }
        errors++;
      }
    }
    var _valid0 = _errs11 === errors;
    valid0 = valid0 || _valid0;
  }
  if (!valid0) {
    const err10 = {
      instancePath,
      schemaPath: '#/anyOf',
      keyword: 'anyOf',
      params: {},
      message: 'must match a schema in anyOf',
      schema: schema38.anyOf,
      parentSchema: schema38,
      data,
    };
    if (vErrors === null) {
      vErrors = [err10];
    } else {
      vErrors.push(err10);
    }
    errors++;
    validate53.errors = vErrors;
    return false;
  } else {
    errors = _errs0;
    if (vErrors !== null) {
      if (_errs0) {
        vErrors.length = _errs0;
      } else {
        vErrors = null;
      }
    }
  }
  validate53.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingBodyResponse = validate54;
const schema39 = {
  anyOf: [
    {
      type: 'object',
      description: 'Use this request for adding devices.',
      properties: {
        Locked: {
          type: 'boolean',
          description:
            'Expresses whether the devices should be locked. Must match current status of booking. Is assumed to be false if not set.',
        },
        Devices: {
          type: 'array',
          description: 'List of devices which should be added.',
          items: {
            title: 'Device',
            description:
              'A device might either be a physical/virtual device or a group of device.',
            type: 'object',
            required: ['ID'],
            properties: {
              ID: {
                type: 'string',
                description:
                  'Unique ID of the device. Contains the institution (by having an end point at that institution)',
                format: 'uri',
              },
            },
          },
        },
      },
    },
    {
      type: 'object',
      description: 'Use this request for adding callbacks.',
      properties: {
        Callback: {
          type: 'string',
          format: 'uri',
          description: 'Callback which should be called at changes.',
        },
      },
    },
  ],
  'x-standalone': false,
  'x-name': 'updateBookingBodyResponse',
  'x-location':
    '#/paths//booking/{ID}/patch/requestBody/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate54(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  let valid0 = false;
  const _errs1 = errors;
  if (errors === _errs1) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      if (data.Locked !== undefined) {
        let data0 = data.Locked;
        const _errs3 = errors;
        if (typeof data0 !== 'boolean') {
          const err0 = {
            instancePath: instancePath + '/Locked',
            schemaPath: '#/anyOf/0/properties/Locked/type',
            keyword: 'type',
            params: { type: 'boolean' },
            message: 'must be boolean',
            schema: schema39.anyOf[0].properties.Locked.type,
            parentSchema: schema39.anyOf[0].properties.Locked,
            data: data0,
          };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
        var valid1 = _errs3 === errors;
      } else {
        var valid1 = true;
      }
      if (valid1) {
        if (data.Devices !== undefined) {
          let data1 = data.Devices;
          const _errs5 = errors;
          if (errors === _errs5) {
            if (Array.isArray(data1)) {
              var valid2 = true;
              const len0 = data1.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data2 = data1[i0];
                const _errs7 = errors;
                if (errors === _errs7) {
                  if (data2 && typeof data2 == 'object' && !Array.isArray(data2)) {
                    let missing0;
                    if (data2.ID === undefined && (missing0 = 'ID')) {
                      const err1 = {
                        instancePath: instancePath + '/Devices/' + i0,
                        schemaPath: '#/anyOf/0/properties/Devices/items/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                        schema: schema39.anyOf[0].properties.Devices.items.required,
                        parentSchema: schema39.anyOf[0].properties.Devices.items,
                        data: data2,
                      };
                      if (vErrors === null) {
                        vErrors = [err1];
                      } else {
                        vErrors.push(err1);
                      }
                      errors++;
                    } else {
                      if (data2.ID !== undefined) {
                        let data3 = data2.ID;
                        const _errs9 = errors;
                        if (errors === _errs9) {
                          if (errors === _errs9) {
                            if (typeof data3 === 'string') {
                              if (!formats0(data3)) {
                                const err2 = {
                                  instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                  schemaPath:
                                    '#/anyOf/0/properties/Devices/items/properties/ID/format',
                                  keyword: 'format',
                                  params: { format: 'uri' },
                                  message: 'must match format "' + 'uri' + '"',
                                  schema: 'uri',
                                  parentSchema:
                                    schema39.anyOf[0].properties.Devices.items.properties
                                      .ID,
                                  data: data3,
                                };
                                if (vErrors === null) {
                                  vErrors = [err2];
                                } else {
                                  vErrors.push(err2);
                                }
                                errors++;
                              }
                            } else {
                              const err3 = {
                                instancePath: instancePath + '/Devices/' + i0 + '/ID',
                                schemaPath:
                                  '#/anyOf/0/properties/Devices/items/properties/ID/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema:
                                  schema39.anyOf[0].properties.Devices.items.properties.ID
                                    .type,
                                parentSchema:
                                  schema39.anyOf[0].properties.Devices.items.properties
                                    .ID,
                                data: data3,
                              };
                              if (vErrors === null) {
                                vErrors = [err3];
                              } else {
                                vErrors.push(err3);
                              }
                              errors++;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    const err4 = {
                      instancePath: instancePath + '/Devices/' + i0,
                      schemaPath: '#/anyOf/0/properties/Devices/items/type',
                      keyword: 'type',
                      params: { type: 'object' },
                      message: 'must be object',
                      schema: schema39.anyOf[0].properties.Devices.items.type,
                      parentSchema: schema39.anyOf[0].properties.Devices.items,
                      data: data2,
                    };
                    if (vErrors === null) {
                      vErrors = [err4];
                    } else {
                      vErrors.push(err4);
                    }
                    errors++;
                  }
                }
                var valid2 = _errs7 === errors;
                if (!valid2) {
                  break;
                }
              }
            } else {
              const err5 = {
                instancePath: instancePath + '/Devices',
                schemaPath: '#/anyOf/0/properties/Devices/type',
                keyword: 'type',
                params: { type: 'array' },
                message: 'must be array',
                schema: schema39.anyOf[0].properties.Devices.type,
                parentSchema: schema39.anyOf[0].properties.Devices,
                data: data1,
              };
              if (vErrors === null) {
                vErrors = [err5];
              } else {
                vErrors.push(err5);
              }
              errors++;
            }
          }
          var valid1 = _errs5 === errors;
        } else {
          var valid1 = true;
        }
      }
    } else {
      const err6 = {
        instancePath,
        schemaPath: '#/anyOf/0/type',
        keyword: 'type',
        params: { type: 'object' },
        message: 'must be object',
        schema: schema39.anyOf[0].type,
        parentSchema: schema39.anyOf[0],
        data,
      };
      if (vErrors === null) {
        vErrors = [err6];
      } else {
        vErrors.push(err6);
      }
      errors++;
    }
  }
  var _valid0 = _errs1 === errors;
  valid0 = valid0 || _valid0;
  if (!valid0) {
    const _errs11 = errors;
    if (errors === _errs11) {
      if (data && typeof data == 'object' && !Array.isArray(data)) {
        if (data.Callback !== undefined) {
          let data4 = data.Callback;
          const _errs13 = errors;
          if (errors === _errs13) {
            if (errors === _errs13) {
              if (typeof data4 === 'string') {
                if (!formats0(data4)) {
                  const err7 = {
                    instancePath: instancePath + '/Callback',
                    schemaPath: '#/anyOf/1/properties/Callback/format',
                    keyword: 'format',
                    params: { format: 'uri' },
                    message: 'must match format "' + 'uri' + '"',
                    schema: 'uri',
                    parentSchema: schema39.anyOf[1].properties.Callback,
                    data: data4,
                  };
                  if (vErrors === null) {
                    vErrors = [err7];
                  } else {
                    vErrors.push(err7);
                  }
                  errors++;
                }
              } else {
                const err8 = {
                  instancePath: instancePath + '/Callback',
                  schemaPath: '#/anyOf/1/properties/Callback/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                  schema: schema39.anyOf[1].properties.Callback.type,
                  parentSchema: schema39.anyOf[1].properties.Callback,
                  data: data4,
                };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors++;
              }
            }
          }
        }
      } else {
        const err9 = {
          instancePath,
          schemaPath: '#/anyOf/1/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema39.anyOf[1].type,
          parentSchema: schema39.anyOf[1],
          data,
        };
        if (vErrors === null) {
          vErrors = [err9];
        } else {
          vErrors.push(err9);
        }
        errors++;
      }
    }
    var _valid0 = _errs11 === errors;
    valid0 = valid0 || _valid0;
  }
  if (!valid0) {
    const err10 = {
      instancePath,
      schemaPath: '#/anyOf',
      keyword: 'anyOf',
      params: {},
      message: 'must match a schema in anyOf',
      schema: schema39.anyOf,
      parentSchema: schema39,
      data,
    };
    if (vErrors === null) {
      vErrors = [err10];
    } else {
      vErrors.push(err10);
    }
    errors++;
    validate54.errors = vErrors;
    return false;
  } else {
    errors = _errs0;
    if (vErrors !== null) {
      if (_errs0) {
        vErrors.length = _errs0;
      } else {
        vErrors = null;
      }
    }
  }
  validate54.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse200Request = validate55;
const schema40 = {
  type: 'object',
  required: ['BookingID'],
  properties: { BookingID: { type: 'string', format: 'uri' } },
  'x-standalone': false,
  'x-name': 'updateBookingResponse200Request',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate55(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.BookingID === undefined && (missing0 = 'BookingID')) {
        validate55.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema40.required,
            parentSchema: schema40,
            data,
          },
        ];
        return false;
      } else {
        if (data.BookingID !== undefined) {
          let data0 = data.BookingID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate55.errors = [
                    {
                      instancePath: instancePath + '/BookingID',
                      schemaPath: '#/properties/BookingID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema40.properties.BookingID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate55.errors = [
                  {
                    instancePath: instancePath + '/BookingID',
                    schemaPath: '#/properties/BookingID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema40.properties.BookingID.type,
                    parentSchema: schema40.properties.BookingID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate55.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema40.type,
          parentSchema: schema40,
          data,
        },
      ];
      return false;
    }
  }
  validate55.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse200Response = validate56;
const schema41 = {
  type: 'object',
  required: ['BookingID'],
  properties: { BookingID: { type: 'string', format: 'uri' } },
  'x-standalone': false,
  'x-name': 'updateBookingResponse200Response',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate56(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (data.BookingID === undefined && (missing0 = 'BookingID')) {
        validate56.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema41.required,
            parentSchema: schema41,
            data,
          },
        ];
        return false;
      } else {
        if (data.BookingID !== undefined) {
          let data0 = data.BookingID;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === 'string') {
                if (!formats0(data0)) {
                  validate56.errors = [
                    {
                      instancePath: instancePath + '/BookingID',
                      schemaPath: '#/properties/BookingID/format',
                      keyword: 'format',
                      params: { format: 'uri' },
                      message: 'must match format "' + 'uri' + '"',
                      schema: 'uri',
                      parentSchema: schema41.properties.BookingID,
                      data: data0,
                    },
                  ];
                  return false;
                }
              } else {
                validate56.errors = [
                  {
                    instancePath: instancePath + '/BookingID',
                    schemaPath: '#/properties/BookingID/type',
                    keyword: 'type',
                    params: { type: 'string' },
                    message: 'must be string',
                    schema: schema41.properties.BookingID.type,
                    parentSchema: schema41.properties.BookingID,
                    data: data0,
                  },
                ];
                return false;
              }
            }
          }
        }
      }
    } else {
      validate56.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema41.type,
          parentSchema: schema41,
          data,
        },
      ];
      return false;
    }
  }
  validate56.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse400Request = validate57;
const schema42 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'updateBookingResponse400Request',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/400/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate57(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate57.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema42.type,
        parentSchema: schema42,
        data,
      },
    ];
    return false;
  }
  validate57.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse400Response = validate58;
const schema43 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'updateBookingResponse400Response',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/400/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate58(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate58.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema43.type,
        parentSchema: schema43,
        data,
      },
    ];
    return false;
  }
  validate58.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse500Request = validate59;
const schema44 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'updateBookingResponse500Request',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate59(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate59.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema44.type,
        parentSchema: schema44,
        data,
      },
    ];
    return false;
  }
  validate59.errors = vErrors;
  return errors === 0;
}
exports.validateUpdateBookingResponse500Response = validate60;
const schema45 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'updateBookingResponse500Response',
  'x-location':
    '#/paths//booking/{ID}/patch/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate60(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate60.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema45.type,
        parentSchema: schema45,
        data,
      },
    ];
    return false;
  }
  validate60.errors = vErrors;
  return errors === 0;
}
exports.validateDeleteBookingResponse500Request = validate61;
const schema46 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'deleteBookingResponse500Request',
  'x-location':
    '#/paths//booking/{ID}/delete/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate61(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate61.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema46.type,
        parentSchema: schema46,
        data,
      },
    ];
    return false;
  }
  validate61.errors = vErrors;
  return errors === 0;
}
exports.validateDeleteBookingResponse500Response = validate62;
const schema47 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'deleteBookingResponse500Response',
  'x-location':
    '#/paths//booking/{ID}/delete/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate62(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate62.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema47.type,
        parentSchema: schema47,
        data,
      },
    ];
    return false;
  }
  validate62.errors = vErrors;
  return errors === 0;
}
exports.validateGetBookingResponse200Request = validate63;
const schema48 = {
  type: 'object',
  required: ['Booking', 'Locked'],
  properties: {
    Booking: {
      title: 'Booking',
      description: 'A booking in the booking system.',
      type: 'object',
      required: ['ID', 'Time', 'Devices', 'Status', 'You', 'External'],
      properties: {
        ID: { type: 'string', format: 'uri', description: 'Unique ID of the booking.' },
        Time: {
          title: 'Timeslot',
          description: 'A time slot represents a slice of time used for bookings.',
          type: 'object',
          required: ['Start', 'End'],
          properties: {
            Start: {
              type: 'string',
              description: 'Start time of the booking.',
              format: 'date-time',
            },
            End: {
              type: 'string',
              description: 'End time of the booking.',
              format: 'date-time',
            },
          },
        },
        Devices: { type: 'array', items: { type: 'string', format: 'uri' } },
        Type: {
          description:
            "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
          type: 'string',
          enum: ['normal'],
        },
        Status: {
          description:
            "Current status of the booking. While the booking is pending, it can not be used. Will change automatically and can not be set by user. 'rejected' is set when the initial booking failed, 'cancelled' when the booking was deleted / cancelled after it was once active. The 'active-*' will be used when a device was added after the booking was locked.",
          type: 'string',
          enum: [
            'pending',
            'booked',
            'rejected',
            'cancelled',
            'active',
            'active-pending',
            'active-rejected',
          ],
        },
        You: { type: 'boolean', description: 'If true, this booking was done by you.' },
        External: {
          type: 'boolean',
          description: 'Shows whether the booking was done by an external institution.',
        },
        Message: {
          type: 'string',
          description:
            'User readable notes about the status of the booking (e.g. if devices are unknown).',
        },
      },
    },
    Locked: {
      type: 'boolean',
      description: 'Shows if the booking is in a locked status.',
    },
  },
  'x-standalone': false,
  'x-name': 'getBookingResponse200Request',
  'x-location':
    '#/paths//booking/{ID}/get/responses/200/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate63(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Booking === undefined && (missing0 = 'Booking')) ||
        (data.Locked === undefined && (missing0 = 'Locked'))
      ) {
        validate63.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema48.required,
            parentSchema: schema48,
            data,
          },
        ];
        return false;
      } else {
        if (data.Booking !== undefined) {
          let data0 = data.Booking;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
              let missing1;
              if (
                (data0.ID === undefined && (missing1 = 'ID')) ||
                (data0.Time === undefined && (missing1 = 'Time')) ||
                (data0.Devices === undefined && (missing1 = 'Devices')) ||
                (data0.Status === undefined && (missing1 = 'Status')) ||
                (data0.You === undefined && (missing1 = 'You')) ||
                (data0.External === undefined && (missing1 = 'External'))
              ) {
                validate63.errors = [
                  {
                    instancePath: instancePath + '/Booking',
                    schemaPath: '#/properties/Booking/required',
                    keyword: 'required',
                    params: { missingProperty: missing1 },
                    message: "must have required property '" + missing1 + "'",
                    schema: schema48.properties.Booking.required,
                    parentSchema: schema48.properties.Booking,
                    data: data0,
                  },
                ];
                return false;
              } else {
                if (data0.ID !== undefined) {
                  let data1 = data0.ID;
                  const _errs3 = errors;
                  if (errors === _errs3) {
                    if (errors === _errs3) {
                      if (typeof data1 === 'string') {
                        if (!formats0(data1)) {
                          validate63.errors = [
                            {
                              instancePath: instancePath + '/Booking/ID',
                              schemaPath: '#/properties/Booking/properties/ID/format',
                              keyword: 'format',
                              params: { format: 'uri' },
                              message: 'must match format "' + 'uri' + '"',
                              schema: 'uri',
                              parentSchema: schema48.properties.Booking.properties.ID,
                              data: data1,
                            },
                          ];
                          return false;
                        }
                      } else {
                        validate63.errors = [
                          {
                            instancePath: instancePath + '/Booking/ID',
                            schemaPath: '#/properties/Booking/properties/ID/type',
                            keyword: 'type',
                            params: { type: 'string' },
                            message: 'must be string',
                            schema: schema48.properties.Booking.properties.ID.type,
                            parentSchema: schema48.properties.Booking.properties.ID,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    }
                  }
                  var valid1 = _errs3 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.Time !== undefined) {
                    let data2 = data0.Time;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (data2 && typeof data2 == 'object' && !Array.isArray(data2)) {
                        let missing2;
                        if (
                          (data2.Start === undefined && (missing2 = 'Start')) ||
                          (data2.End === undefined && (missing2 = 'End'))
                        ) {
                          validate63.errors = [
                            {
                              instancePath: instancePath + '/Booking/Time',
                              schemaPath: '#/properties/Booking/properties/Time/required',
                              keyword: 'required',
                              params: { missingProperty: missing2 },
                              message: "must have required property '" + missing2 + "'",
                              schema:
                                schema48.properties.Booking.properties.Time.required,
                              parentSchema: schema48.properties.Booking.properties.Time,
                              data: data2,
                            },
                          ];
                          return false;
                        } else {
                          if (data2.Start !== undefined) {
                            let data3 = data2.Start;
                            const _errs7 = errors;
                            if (errors === _errs7) {
                              if (errors === _errs7) {
                                if (typeof data3 === 'string') {
                                  if (!formats2.validate(data3)) {
                                    validate63.errors = [
                                      {
                                        instancePath:
                                          instancePath + '/Booking/Time/Start',
                                        schemaPath:
                                          '#/properties/Booking/properties/Time/properties/Start/format',
                                        keyword: 'format',
                                        params: { format: 'date-time' },
                                        message:
                                          'must match format "' + 'date-time' + '"',
                                        schema: 'date-time',
                                        parentSchema:
                                          schema48.properties.Booking.properties.Time
                                            .properties.Start,
                                        data: data3,
                                      },
                                    ];
                                    return false;
                                  }
                                } else {
                                  validate63.errors = [
                                    {
                                      instancePath: instancePath + '/Booking/Time/Start',
                                      schemaPath:
                                        '#/properties/Booking/properties/Time/properties/Start/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema48.properties.Booking.properties.Time
                                          .properties.Start.type,
                                      parentSchema:
                                        schema48.properties.Booking.properties.Time
                                          .properties.Start,
                                      data: data3,
                                    },
                                  ];
                                  return false;
                                }
                              }
                            }
                            var valid2 = _errs7 === errors;
                          } else {
                            var valid2 = true;
                          }
                          if (valid2) {
                            if (data2.End !== undefined) {
                              let data4 = data2.End;
                              const _errs9 = errors;
                              if (errors === _errs9) {
                                if (errors === _errs9) {
                                  if (typeof data4 === 'string') {
                                    if (!formats2.validate(data4)) {
                                      validate63.errors = [
                                        {
                                          instancePath:
                                            instancePath + '/Booking/Time/End',
                                          schemaPath:
                                            '#/properties/Booking/properties/Time/properties/End/format',
                                          keyword: 'format',
                                          params: { format: 'date-time' },
                                          message:
                                            'must match format "' + 'date-time' + '"',
                                          schema: 'date-time',
                                          parentSchema:
                                            schema48.properties.Booking.properties.Time
                                              .properties.End,
                                          data: data4,
                                        },
                                      ];
                                      return false;
                                    }
                                  } else {
                                    validate63.errors = [
                                      {
                                        instancePath: instancePath + '/Booking/Time/End',
                                        schemaPath:
                                          '#/properties/Booking/properties/Time/properties/End/type',
                                        keyword: 'type',
                                        params: { type: 'string' },
                                        message: 'must be string',
                                        schema:
                                          schema48.properties.Booking.properties.Time
                                            .properties.End.type,
                                        parentSchema:
                                          schema48.properties.Booking.properties.Time
                                            .properties.End,
                                        data: data4,
                                      },
                                    ];
                                    return false;
                                  }
                                }
                              }
                              var valid2 = _errs9 === errors;
                            } else {
                              var valid2 = true;
                            }
                          }
                        }
                      } else {
                        validate63.errors = [
                          {
                            instancePath: instancePath + '/Booking/Time',
                            schemaPath: '#/properties/Booking/properties/Time/type',
                            keyword: 'type',
                            params: { type: 'object' },
                            message: 'must be object',
                            schema: schema48.properties.Booking.properties.Time.type,
                            parentSchema: schema48.properties.Booking.properties.Time,
                            data: data2,
                          },
                        ];
                        return false;
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data0.Devices !== undefined) {
                      let data5 = data0.Devices;
                      const _errs11 = errors;
                      if (errors === _errs11) {
                        if (Array.isArray(data5)) {
                          var valid3 = true;
                          const len0 = data5.length;
                          for (let i0 = 0; i0 < len0; i0++) {
                            let data6 = data5[i0];
                            const _errs13 = errors;
                            if (errors === _errs13) {
                              if (errors === _errs13) {
                                if (typeof data6 === 'string') {
                                  if (!formats0(data6)) {
                                    validate63.errors = [
                                      {
                                        instancePath:
                                          instancePath + '/Booking/Devices/' + i0,
                                        schemaPath:
                                          '#/properties/Booking/properties/Devices/items/format',
                                        keyword: 'format',
                                        params: { format: 'uri' },
                                        message: 'must match format "' + 'uri' + '"',
                                        schema: 'uri',
                                        parentSchema:
                                          schema48.properties.Booking.properties.Devices
                                            .items,
                                        data: data6,
                                      },
                                    ];
                                    return false;
                                  }
                                } else {
                                  validate63.errors = [
                                    {
                                      instancePath:
                                        instancePath + '/Booking/Devices/' + i0,
                                      schemaPath:
                                        '#/properties/Booking/properties/Devices/items/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema48.properties.Booking.properties.Devices
                                          .items.type,
                                      parentSchema:
                                        schema48.properties.Booking.properties.Devices
                                          .items,
                                      data: data6,
                                    },
                                  ];
                                  return false;
                                }
                              }
                            }
                            var valid3 = _errs13 === errors;
                            if (!valid3) {
                              break;
                            }
                          }
                        } else {
                          validate63.errors = [
                            {
                              instancePath: instancePath + '/Booking/Devices',
                              schemaPath: '#/properties/Booking/properties/Devices/type',
                              keyword: 'type',
                              params: { type: 'array' },
                              message: 'must be array',
                              schema: schema48.properties.Booking.properties.Devices.type,
                              parentSchema:
                                schema48.properties.Booking.properties.Devices,
                              data: data5,
                            },
                          ];
                          return false;
                        }
                      }
                      var valid1 = _errs11 === errors;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data0.Type !== undefined) {
                        let data7 = data0.Type;
                        const _errs15 = errors;
                        if (typeof data7 !== 'string') {
                          validate63.errors = [
                            {
                              instancePath: instancePath + '/Booking/Type',
                              schemaPath: '#/properties/Booking/properties/Type/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema48.properties.Booking.properties.Type.type,
                              parentSchema: schema48.properties.Booking.properties.Type,
                              data: data7,
                            },
                          ];
                          return false;
                        }
                        if (!(data7 === 'normal')) {
                          validate63.errors = [
                            {
                              instancePath: instancePath + '/Booking/Type',
                              schemaPath: '#/properties/Booking/properties/Type/enum',
                              keyword: 'enum',
                              params: {
                                allowedValues:
                                  schema48.properties.Booking.properties.Type.enum,
                              },
                              message: 'must be equal to one of the allowed values',
                              schema: schema48.properties.Booking.properties.Type.enum,
                              parentSchema: schema48.properties.Booking.properties.Type,
                              data: data7,
                            },
                          ];
                          return false;
                        }
                        var valid1 = _errs15 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data0.Status !== undefined) {
                          let data8 = data0.Status;
                          const _errs17 = errors;
                          if (typeof data8 !== 'string') {
                            validate63.errors = [
                              {
                                instancePath: instancePath + '/Booking/Status',
                                schemaPath: '#/properties/Booking/properties/Status/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema:
                                  schema48.properties.Booking.properties.Status.type,
                                parentSchema:
                                  schema48.properties.Booking.properties.Status,
                                data: data8,
                              },
                            ];
                            return false;
                          }
                          if (
                            !(
                              data8 === 'pending' ||
                              data8 === 'booked' ||
                              data8 === 'rejected' ||
                              data8 === 'cancelled' ||
                              data8 === 'active' ||
                              data8 === 'active-pending' ||
                              data8 === 'active-rejected'
                            )
                          ) {
                            validate63.errors = [
                              {
                                instancePath: instancePath + '/Booking/Status',
                                schemaPath: '#/properties/Booking/properties/Status/enum',
                                keyword: 'enum',
                                params: {
                                  allowedValues:
                                    schema48.properties.Booking.properties.Status.enum,
                                },
                                message: 'must be equal to one of the allowed values',
                                schema:
                                  schema48.properties.Booking.properties.Status.enum,
                                parentSchema:
                                  schema48.properties.Booking.properties.Status,
                                data: data8,
                              },
                            ];
                            return false;
                          }
                          var valid1 = _errs17 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data0.You !== undefined) {
                            let data9 = data0.You;
                            const _errs19 = errors;
                            if (typeof data9 !== 'boolean') {
                              validate63.errors = [
                                {
                                  instancePath: instancePath + '/Booking/You',
                                  schemaPath: '#/properties/Booking/properties/You/type',
                                  keyword: 'type',
                                  params: { type: 'boolean' },
                                  message: 'must be boolean',
                                  schema: schema48.properties.Booking.properties.You.type,
                                  parentSchema:
                                    schema48.properties.Booking.properties.You,
                                  data: data9,
                                },
                              ];
                              return false;
                            }
                            var valid1 = _errs19 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data0.External !== undefined) {
                              let data10 = data0.External;
                              const _errs21 = errors;
                              if (typeof data10 !== 'boolean') {
                                validate63.errors = [
                                  {
                                    instancePath: instancePath + '/Booking/External',
                                    schemaPath:
                                      '#/properties/Booking/properties/External/type',
                                    keyword: 'type',
                                    params: { type: 'boolean' },
                                    message: 'must be boolean',
                                    schema:
                                      schema48.properties.Booking.properties.External
                                        .type,
                                    parentSchema:
                                      schema48.properties.Booking.properties.External,
                                    data: data10,
                                  },
                                ];
                                return false;
                              }
                              var valid1 = _errs21 === errors;
                            } else {
                              var valid1 = true;
                            }
                            if (valid1) {
                              if (data0.Message !== undefined) {
                                let data11 = data0.Message;
                                const _errs23 = errors;
                                if (typeof data11 !== 'string') {
                                  validate63.errors = [
                                    {
                                      instancePath: instancePath + '/Booking/Message',
                                      schemaPath:
                                        '#/properties/Booking/properties/Message/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema48.properties.Booking.properties.Message
                                          .type,
                                      parentSchema:
                                        schema48.properties.Booking.properties.Message,
                                      data: data11,
                                    },
                                  ];
                                  return false;
                                }
                                var valid1 = _errs23 === errors;
                              } else {
                                var valid1 = true;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              validate63.errors = [
                {
                  instancePath: instancePath + '/Booking',
                  schemaPath: '#/properties/Booking/type',
                  keyword: 'type',
                  params: { type: 'object' },
                  message: 'must be object',
                  schema: schema48.properties.Booking.type,
                  parentSchema: schema48.properties.Booking,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Locked !== undefined) {
            let data12 = data.Locked;
            const _errs25 = errors;
            if (typeof data12 !== 'boolean') {
              validate63.errors = [
                {
                  instancePath: instancePath + '/Locked',
                  schemaPath: '#/properties/Locked/type',
                  keyword: 'type',
                  params: { type: 'boolean' },
                  message: 'must be boolean',
                  schema: schema48.properties.Locked.type,
                  parentSchema: schema48.properties.Locked,
                  data: data12,
                },
              ];
              return false;
            }
            var valid0 = _errs25 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate63.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema48.type,
          parentSchema: schema48,
          data,
        },
      ];
      return false;
    }
  }
  validate63.errors = vErrors;
  return errors === 0;
}
exports.validateGetBookingResponse200Response = validate64;
const schema49 = {
  type: 'object',
  required: ['Booking', 'Locked'],
  properties: {
    Booking: {
      title: 'Booking',
      description: 'A booking in the booking system.',
      type: 'object',
      required: ['ID', 'Time', 'Devices', 'Status', 'You', 'External'],
      properties: {
        ID: { type: 'string', format: 'uri', description: 'Unique ID of the booking.' },
        Time: {
          title: 'Timeslot',
          description: 'A time slot represents a slice of time used for bookings.',
          type: 'object',
          required: ['Start', 'End'],
          properties: {
            Start: {
              type: 'string',
              description: 'Start time of the booking.',
              format: 'date-time',
            },
            End: {
              type: 'string',
              description: 'End time of the booking.',
              format: 'date-time',
            },
          },
        },
        Devices: { type: 'array', items: { type: 'string', format: 'uri' } },
        Type: {
          description:
            "Type of booking. Currently, only one type is defined, but others might follow (e.g. priority booking). If empty, 'normal' is assumed.",
          type: 'string',
          enum: ['normal'],
        },
        Status: {
          description:
            "Current status of the booking. While the booking is pending, it can not be used. Will change automatically and can not be set by user. 'rejected' is set when the initial booking failed, 'cancelled' when the booking was deleted / cancelled after it was once active. The 'active-*' will be used when a device was added after the booking was locked.",
          type: 'string',
          enum: [
            'pending',
            'booked',
            'rejected',
            'cancelled',
            'active',
            'active-pending',
            'active-rejected',
          ],
        },
        You: { type: 'boolean', description: 'If true, this booking was done by you.' },
        External: {
          type: 'boolean',
          description: 'Shows whether the booking was done by an external institution.',
        },
        Message: {
          type: 'string',
          description:
            'User readable notes about the status of the booking (e.g. if devices are unknown).',
        },
      },
    },
    Locked: {
      type: 'boolean',
      description: 'Shows if the booking is in a locked status.',
    },
  },
  'x-standalone': false,
  'x-name': 'getBookingResponse200Response',
  'x-location':
    '#/paths//booking/{ID}/get/responses/200/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate64(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == 'object' && !Array.isArray(data)) {
      let missing0;
      if (
        (data.Booking === undefined && (missing0 = 'Booking')) ||
        (data.Locked === undefined && (missing0 = 'Locked'))
      ) {
        validate64.errors = [
          {
            instancePath,
            schemaPath: '#/required',
            keyword: 'required',
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'",
            schema: schema49.required,
            parentSchema: schema49,
            data,
          },
        ];
        return false;
      } else {
        if (data.Booking !== undefined) {
          let data0 = data.Booking;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
              let missing1;
              if (
                (data0.ID === undefined && (missing1 = 'ID')) ||
                (data0.Time === undefined && (missing1 = 'Time')) ||
                (data0.Devices === undefined && (missing1 = 'Devices')) ||
                (data0.Status === undefined && (missing1 = 'Status')) ||
                (data0.You === undefined && (missing1 = 'You')) ||
                (data0.External === undefined && (missing1 = 'External'))
              ) {
                validate64.errors = [
                  {
                    instancePath: instancePath + '/Booking',
                    schemaPath: '#/properties/Booking/required',
                    keyword: 'required',
                    params: { missingProperty: missing1 },
                    message: "must have required property '" + missing1 + "'",
                    schema: schema49.properties.Booking.required,
                    parentSchema: schema49.properties.Booking,
                    data: data0,
                  },
                ];
                return false;
              } else {
                if (data0.ID !== undefined) {
                  let data1 = data0.ID;
                  const _errs3 = errors;
                  if (errors === _errs3) {
                    if (errors === _errs3) {
                      if (typeof data1 === 'string') {
                        if (!formats0(data1)) {
                          validate64.errors = [
                            {
                              instancePath: instancePath + '/Booking/ID',
                              schemaPath: '#/properties/Booking/properties/ID/format',
                              keyword: 'format',
                              params: { format: 'uri' },
                              message: 'must match format "' + 'uri' + '"',
                              schema: 'uri',
                              parentSchema: schema49.properties.Booking.properties.ID,
                              data: data1,
                            },
                          ];
                          return false;
                        }
                      } else {
                        validate64.errors = [
                          {
                            instancePath: instancePath + '/Booking/ID',
                            schemaPath: '#/properties/Booking/properties/ID/type',
                            keyword: 'type',
                            params: { type: 'string' },
                            message: 'must be string',
                            schema: schema49.properties.Booking.properties.ID.type,
                            parentSchema: schema49.properties.Booking.properties.ID,
                            data: data1,
                          },
                        ];
                        return false;
                      }
                    }
                  }
                  var valid1 = _errs3 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data0.Time !== undefined) {
                    let data2 = data0.Time;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (data2 && typeof data2 == 'object' && !Array.isArray(data2)) {
                        let missing2;
                        if (
                          (data2.Start === undefined && (missing2 = 'Start')) ||
                          (data2.End === undefined && (missing2 = 'End'))
                        ) {
                          validate64.errors = [
                            {
                              instancePath: instancePath + '/Booking/Time',
                              schemaPath: '#/properties/Booking/properties/Time/required',
                              keyword: 'required',
                              params: { missingProperty: missing2 },
                              message: "must have required property '" + missing2 + "'",
                              schema:
                                schema49.properties.Booking.properties.Time.required,
                              parentSchema: schema49.properties.Booking.properties.Time,
                              data: data2,
                            },
                          ];
                          return false;
                        } else {
                          if (data2.Start !== undefined) {
                            let data3 = data2.Start;
                            const _errs7 = errors;
                            if (errors === _errs7) {
                              if (errors === _errs7) {
                                if (typeof data3 === 'string') {
                                  if (!formats2.validate(data3)) {
                                    validate64.errors = [
                                      {
                                        instancePath:
                                          instancePath + '/Booking/Time/Start',
                                        schemaPath:
                                          '#/properties/Booking/properties/Time/properties/Start/format',
                                        keyword: 'format',
                                        params: { format: 'date-time' },
                                        message:
                                          'must match format "' + 'date-time' + '"',
                                        schema: 'date-time',
                                        parentSchema:
                                          schema49.properties.Booking.properties.Time
                                            .properties.Start,
                                        data: data3,
                                      },
                                    ];
                                    return false;
                                  }
                                } else {
                                  validate64.errors = [
                                    {
                                      instancePath: instancePath + '/Booking/Time/Start',
                                      schemaPath:
                                        '#/properties/Booking/properties/Time/properties/Start/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema49.properties.Booking.properties.Time
                                          .properties.Start.type,
                                      parentSchema:
                                        schema49.properties.Booking.properties.Time
                                          .properties.Start,
                                      data: data3,
                                    },
                                  ];
                                  return false;
                                }
                              }
                            }
                            var valid2 = _errs7 === errors;
                          } else {
                            var valid2 = true;
                          }
                          if (valid2) {
                            if (data2.End !== undefined) {
                              let data4 = data2.End;
                              const _errs9 = errors;
                              if (errors === _errs9) {
                                if (errors === _errs9) {
                                  if (typeof data4 === 'string') {
                                    if (!formats2.validate(data4)) {
                                      validate64.errors = [
                                        {
                                          instancePath:
                                            instancePath + '/Booking/Time/End',
                                          schemaPath:
                                            '#/properties/Booking/properties/Time/properties/End/format',
                                          keyword: 'format',
                                          params: { format: 'date-time' },
                                          message:
                                            'must match format "' + 'date-time' + '"',
                                          schema: 'date-time',
                                          parentSchema:
                                            schema49.properties.Booking.properties.Time
                                              .properties.End,
                                          data: data4,
                                        },
                                      ];
                                      return false;
                                    }
                                  } else {
                                    validate64.errors = [
                                      {
                                        instancePath: instancePath + '/Booking/Time/End',
                                        schemaPath:
                                          '#/properties/Booking/properties/Time/properties/End/type',
                                        keyword: 'type',
                                        params: { type: 'string' },
                                        message: 'must be string',
                                        schema:
                                          schema49.properties.Booking.properties.Time
                                            .properties.End.type,
                                        parentSchema:
                                          schema49.properties.Booking.properties.Time
                                            .properties.End,
                                        data: data4,
                                      },
                                    ];
                                    return false;
                                  }
                                }
                              }
                              var valid2 = _errs9 === errors;
                            } else {
                              var valid2 = true;
                            }
                          }
                        }
                      } else {
                        validate64.errors = [
                          {
                            instancePath: instancePath + '/Booking/Time',
                            schemaPath: '#/properties/Booking/properties/Time/type',
                            keyword: 'type',
                            params: { type: 'object' },
                            message: 'must be object',
                            schema: schema49.properties.Booking.properties.Time.type,
                            parentSchema: schema49.properties.Booking.properties.Time,
                            data: data2,
                          },
                        ];
                        return false;
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data0.Devices !== undefined) {
                      let data5 = data0.Devices;
                      const _errs11 = errors;
                      if (errors === _errs11) {
                        if (Array.isArray(data5)) {
                          var valid3 = true;
                          const len0 = data5.length;
                          for (let i0 = 0; i0 < len0; i0++) {
                            let data6 = data5[i0];
                            const _errs13 = errors;
                            if (errors === _errs13) {
                              if (errors === _errs13) {
                                if (typeof data6 === 'string') {
                                  if (!formats0(data6)) {
                                    validate64.errors = [
                                      {
                                        instancePath:
                                          instancePath + '/Booking/Devices/' + i0,
                                        schemaPath:
                                          '#/properties/Booking/properties/Devices/items/format',
                                        keyword: 'format',
                                        params: { format: 'uri' },
                                        message: 'must match format "' + 'uri' + '"',
                                        schema: 'uri',
                                        parentSchema:
                                          schema49.properties.Booking.properties.Devices
                                            .items,
                                        data: data6,
                                      },
                                    ];
                                    return false;
                                  }
                                } else {
                                  validate64.errors = [
                                    {
                                      instancePath:
                                        instancePath + '/Booking/Devices/' + i0,
                                      schemaPath:
                                        '#/properties/Booking/properties/Devices/items/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema49.properties.Booking.properties.Devices
                                          .items.type,
                                      parentSchema:
                                        schema49.properties.Booking.properties.Devices
                                          .items,
                                      data: data6,
                                    },
                                  ];
                                  return false;
                                }
                              }
                            }
                            var valid3 = _errs13 === errors;
                            if (!valid3) {
                              break;
                            }
                          }
                        } else {
                          validate64.errors = [
                            {
                              instancePath: instancePath + '/Booking/Devices',
                              schemaPath: '#/properties/Booking/properties/Devices/type',
                              keyword: 'type',
                              params: { type: 'array' },
                              message: 'must be array',
                              schema: schema49.properties.Booking.properties.Devices.type,
                              parentSchema:
                                schema49.properties.Booking.properties.Devices,
                              data: data5,
                            },
                          ];
                          return false;
                        }
                      }
                      var valid1 = _errs11 === errors;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data0.Type !== undefined) {
                        let data7 = data0.Type;
                        const _errs15 = errors;
                        if (typeof data7 !== 'string') {
                          validate64.errors = [
                            {
                              instancePath: instancePath + '/Booking/Type',
                              schemaPath: '#/properties/Booking/properties/Type/type',
                              keyword: 'type',
                              params: { type: 'string' },
                              message: 'must be string',
                              schema: schema49.properties.Booking.properties.Type.type,
                              parentSchema: schema49.properties.Booking.properties.Type,
                              data: data7,
                            },
                          ];
                          return false;
                        }
                        if (!(data7 === 'normal')) {
                          validate64.errors = [
                            {
                              instancePath: instancePath + '/Booking/Type',
                              schemaPath: '#/properties/Booking/properties/Type/enum',
                              keyword: 'enum',
                              params: {
                                allowedValues:
                                  schema49.properties.Booking.properties.Type.enum,
                              },
                              message: 'must be equal to one of the allowed values',
                              schema: schema49.properties.Booking.properties.Type.enum,
                              parentSchema: schema49.properties.Booking.properties.Type,
                              data: data7,
                            },
                          ];
                          return false;
                        }
                        var valid1 = _errs15 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data0.Status !== undefined) {
                          let data8 = data0.Status;
                          const _errs17 = errors;
                          if (typeof data8 !== 'string') {
                            validate64.errors = [
                              {
                                instancePath: instancePath + '/Booking/Status',
                                schemaPath: '#/properties/Booking/properties/Status/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                                schema:
                                  schema49.properties.Booking.properties.Status.type,
                                parentSchema:
                                  schema49.properties.Booking.properties.Status,
                                data: data8,
                              },
                            ];
                            return false;
                          }
                          if (
                            !(
                              data8 === 'pending' ||
                              data8 === 'booked' ||
                              data8 === 'rejected' ||
                              data8 === 'cancelled' ||
                              data8 === 'active' ||
                              data8 === 'active-pending' ||
                              data8 === 'active-rejected'
                            )
                          ) {
                            validate64.errors = [
                              {
                                instancePath: instancePath + '/Booking/Status',
                                schemaPath: '#/properties/Booking/properties/Status/enum',
                                keyword: 'enum',
                                params: {
                                  allowedValues:
                                    schema49.properties.Booking.properties.Status.enum,
                                },
                                message: 'must be equal to one of the allowed values',
                                schema:
                                  schema49.properties.Booking.properties.Status.enum,
                                parentSchema:
                                  schema49.properties.Booking.properties.Status,
                                data: data8,
                              },
                            ];
                            return false;
                          }
                          var valid1 = _errs17 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data0.You !== undefined) {
                            let data9 = data0.You;
                            const _errs19 = errors;
                            if (typeof data9 !== 'boolean') {
                              validate64.errors = [
                                {
                                  instancePath: instancePath + '/Booking/You',
                                  schemaPath: '#/properties/Booking/properties/You/type',
                                  keyword: 'type',
                                  params: { type: 'boolean' },
                                  message: 'must be boolean',
                                  schema: schema49.properties.Booking.properties.You.type,
                                  parentSchema:
                                    schema49.properties.Booking.properties.You,
                                  data: data9,
                                },
                              ];
                              return false;
                            }
                            var valid1 = _errs19 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data0.External !== undefined) {
                              let data10 = data0.External;
                              const _errs21 = errors;
                              if (typeof data10 !== 'boolean') {
                                validate64.errors = [
                                  {
                                    instancePath: instancePath + '/Booking/External',
                                    schemaPath:
                                      '#/properties/Booking/properties/External/type',
                                    keyword: 'type',
                                    params: { type: 'boolean' },
                                    message: 'must be boolean',
                                    schema:
                                      schema49.properties.Booking.properties.External
                                        .type,
                                    parentSchema:
                                      schema49.properties.Booking.properties.External,
                                    data: data10,
                                  },
                                ];
                                return false;
                              }
                              var valid1 = _errs21 === errors;
                            } else {
                              var valid1 = true;
                            }
                            if (valid1) {
                              if (data0.Message !== undefined) {
                                let data11 = data0.Message;
                                const _errs23 = errors;
                                if (typeof data11 !== 'string') {
                                  validate64.errors = [
                                    {
                                      instancePath: instancePath + '/Booking/Message',
                                      schemaPath:
                                        '#/properties/Booking/properties/Message/type',
                                      keyword: 'type',
                                      params: { type: 'string' },
                                      message: 'must be string',
                                      schema:
                                        schema49.properties.Booking.properties.Message
                                          .type,
                                      parentSchema:
                                        schema49.properties.Booking.properties.Message,
                                      data: data11,
                                    },
                                  ];
                                  return false;
                                }
                                var valid1 = _errs23 === errors;
                              } else {
                                var valid1 = true;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              validate64.errors = [
                {
                  instancePath: instancePath + '/Booking',
                  schemaPath: '#/properties/Booking/type',
                  keyword: 'type',
                  params: { type: 'object' },
                  message: 'must be object',
                  schema: schema49.properties.Booking.type,
                  parentSchema: schema49.properties.Booking,
                  data: data0,
                },
              ];
              return false;
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.Locked !== undefined) {
            let data12 = data.Locked;
            const _errs25 = errors;
            if (typeof data12 !== 'boolean') {
              validate64.errors = [
                {
                  instancePath: instancePath + '/Locked',
                  schemaPath: '#/properties/Locked/type',
                  keyword: 'type',
                  params: { type: 'boolean' },
                  message: 'must be boolean',
                  schema: schema49.properties.Locked.type,
                  parentSchema: schema49.properties.Locked,
                  data: data12,
                },
              ];
              return false;
            }
            var valid0 = _errs25 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate64.errors = [
        {
          instancePath,
          schemaPath: '#/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
          schema: schema49.type,
          parentSchema: schema49,
          data,
        },
      ];
      return false;
    }
  }
  validate64.errors = vErrors;
  return errors === 0;
}
exports.validateGetBookingResponse500Request = validate65;
const schema50 = {
  type: 'string',
  description: 'Error code',
  'x-standalone': false,
  'x-name': 'getBookingResponse500Request',
  'x-location':
    '#/paths//booking/{ID}/get/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate65(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate65.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema50.type,
        parentSchema: schema50,
        data,
      },
    ];
    return false;
  }
  validate65.errors = vErrors;
  return errors === 0;
}
exports.validateGetBookingResponse500Response = validate66;
const schema51 = {
  type: 'string',
  description: 'Error code',
  'x-standalone': false,
  'x-name': 'getBookingResponse500Response',
  'x-location':
    '#/paths//booking/{ID}/get/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate66(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate66.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema51.type,
        parentSchema: schema51,
        data,
      },
    ];
    return false;
  }
  validate66.errors = vErrors;
  return errors === 0;
}
exports.validateDestroyBookingResponse500Request = validate67;
const schema52 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'destroyBookingResponse500Request',
  'x-location':
    '#/paths//booking/{ID}/destroy/delete/responses/500/content/application/json/schema_request',
  'x-schema-type': 'request',
};
function validate67(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate67.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema52.type,
        parentSchema: schema52,
        data,
      },
    ];
    return false;
  }
  validate67.errors = vErrors;
  return errors === 0;
}
exports.validateDestroyBookingResponse500Response = validate68;
const schema53 = {
  type: 'string',
  description: 'Error description',
  'x-standalone': false,
  'x-name': 'destroyBookingResponse500Response',
  'x-location':
    '#/paths//booking/{ID}/destroy/delete/responses/500/content/application/json/schema_response',
  'x-schema-type': 'response',
};
function validate68(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {},
) {
  let vErrors = null;
  let errors = 0;
  if (typeof data !== 'string') {
    validate68.errors = [
      {
        instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: { type: 'string' },
        message: 'must be string',
        schema: schema53.type,
        parentSchema: schema53,
        data,
      },
    ];
    return false;
  }
  validate68.errors = vErrors;
  return errors === 0;
}
