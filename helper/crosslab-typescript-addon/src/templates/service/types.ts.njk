{%- macro generateTypes() -%}
{%- set schemas = (api | resolveSchemas) -%}
{%- set securitySchemes = [] -%}
{%- set validationDependencies = [] -%}
{%- for schema in schemas | selectattr("x-typeguard") | select("attrequalto", ["x-standalone", true]) -%}
    {%- set validationDependencies = (validationDependencies.push("validate" + schema["x-name"]), validationDependencies) -%}
{%- endfor -%}

{%- if components.securitySchemes | list | length > 0 -%}
    {%- for name, scheme in components.securitySchemes -%}
        {%- set securitySchemes = (securitySchemes.push(name | formatName), securitySchemes) -%}
    {%- endfor -%}
{%- endif -%}
/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */
import { Request, ErrorRequestHandler } from "express"

{%- if validationDependencies | length > 0 %}

import {
    {{ validationDependencies | join(",\n\t") }}
} from "./basicValidation"
{%- endif %}

export type SecurityScheme = "{{ securitySchemes | join('" | "') }}"

export type TypedRequest<P,B,Q> = Request<P, {}, B, Q, {}>

export type initServiceOptions<T extends SecurityScheme> = {
    {%- if securitySchemes | length > 0 %}
    security: {
        [k in T]: <P,B,Q>(req: TypedRequest<P,B,Q>, scopes: string[]) => Promise<UserType> | UserType | undefined
    }
    {%- endif %}
    errorHandler?: ErrorRequestHandler
}

export type UserData<T extends SecurityScheme> = {
    [k in T]?: UserType
}

export interface ResponseData {
    status: number,
    headers?: {
        [key: string]: string | undefined
    },
    body?: any
}

export interface SuccessResponse extends ResponseData {
    success?: true
}

export interface ErrorResponse extends ResponseData {
    success?: false
}

export function isSuccessResponse(response: ResponseData): response is SuccessResponse {
    return response.status < 400
}

export function isErrorResponse(response: ResponseData): response is ErrorResponse {
    return response.status >= 400
}

export abstract class ErrorWithStatus extends Error {
    public status: number | undefined

    constructor(message: string, status?: number) {
        super(message)
        this.status = status
        this.name = "ErrorWithStatus"
    }
}

export class ValidationError extends ErrorWithStatus {
    public errors: any

    constructor(message: string, errors?: any, status?: number) {
        super(message, status)
        this.name = "ValidationError"
        this.errors = errors
    }
}

/**
 * This type allows to pick the required properties of another type.
 */
export type Require<Type, Key extends keyof Type> = Partial<Type> & {
    [Property in Key]-?: Type[Property]
}

{{ schemas | standaloneTypings }}

{%- for schema in schemas | selectattr("x-typeguard") | select("attrequalto", ["x-standalone", true]) | select("attrequalto", ["x-schema-type", "all"]) %}

export function is{{ schema["x-name"] }}<T extends "request"|"response"|"all" = "all">(obj: any, type?: T): obj is {{ schema["x-name"] }}<T> {
    switch (type) {
        case "request":
            return validate{{ schema["x-name"] }}Request(obj)
        case "response":
            return validate{{ schema["x-name"] }}Response(obj)
        default:
            return validate{{ schema["x-name"] }}(obj)
    }
}
{%- endfor %}
{%- endmacro -%}
{{ generateTypes() | prettier }}