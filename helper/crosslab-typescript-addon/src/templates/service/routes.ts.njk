{%- macro generateRoutes() -%}
{%- set typeDependencies = ["UserData","TypedRequest","ValidationError","initServiceOptions","SecurityScheme"] -%}
{%- set validationDependencies = [] -%}
{%- set signatureDependencies = [] -%}
{%- set operations = api | resolveOperations -%}

{%- for operation in operations -%}
    {%- set validationDependencies = (validationDependencies.push("validate" + (operation.name | cap) + "Input"), validationDependencies) -%}
    {%- set validationDependencies = (validationDependencies.push("validate" + (operation.name | cap) + "Output"), validationDependencies) -%}
    {%- if operation.parameters -%}
        {%- set signatureDependencies = (signatureDependencies.push(operation.name + "ParametersType"), signatureDependencies) -%}
    {%- endif -%}
    {%- if operation.requestBody -%}
        {%- set signatureDependencies = (signatureDependencies.push(operation.name + "RequestBodyType"), signatureDependencies) -%}
    {%- endif -%}
{%- endfor -%}

{%- set securityOptionsDefaults = [] -%}

{%- if components.securitySchemes | list | length > 0 -%}
    {%- for name, scheme in components.securitySchemes -%}
        {%- set securityOptionsDefaults = 
            (securityOptionsDefaults.push(
                '"' + (name | formatName) + '"'
                + ': (_req, _scopes) => { throw new Error("' 
                + (name | formatName) 
                + ' authentication not implemented") }'
            ), securityOptionsDefaults) -%}
    {%- endfor -%}
{%- endif -%}

/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */
import express from "express"
import * as operations from "../operations"

import {
    {{ typeDependencies | unique | join(",\n\t") }}
} from "./types"

import {
    {{ signatureDependencies | unique | join(",\n\t") }}
} from "./signatures"

import {
    {{ validationDependencies | unique | join(",\n\t") }}
} from "./requestValidation"

export default function routes(
    options: initServiceOptions<SecurityScheme> = {
        {%- if securityOptionsDefaults | length > 0 %}
        security: {
            {{ securityOptionsDefaults | join(",\n\t\t\t") }}
        }
        {%- endif %}
    }
): express.Router {
    const router = express.Router()

    async function handleSecurityRequirement<T extends SecurityScheme,P,B,Q>(
        request: TypedRequest<P,B,Q>,
        securityRequirement: {
            [k in T]: string[]
        }
    ): Promise<UserData<T>> {
        let userData: UserData<T> = {}
        for (const method in securityRequirement) {
            userData[method] = await options.security[method](request, securityRequirement[method])
        }
        return userData
    }

    {%- for operation in operations %}

    {% set pathParameters = [] -%}
    {%- set queryParameters = [] -%}

    {%- for parameter in operation.parameters -%}
        {%- if parameter.in == "path" -%}
            {%- set pathParameters = (pathParameters.push('"' + parameter.name + '": ' + parameter.schema | typeDeclaration), pathParameters) -%}
        {%- endif -%}
        {%- if parameter.in == "query" -%}               
            {%- set queryParameters = (queryParameters.push('"' + parameter.name + '": ' + parameter.schema | typeDeclaration), queryParameters) -%}
        {%- endif -%}
    {%- endfor -%}

    router.{{ operation.method }}("{{ operation.path | expressPath }}", async (req: TypedRequest<
        {{- "{ " + (pathParameters | join(", ")) + " }" if pathParameters | length > 0 else "{}" -}},
        {{- operation.name + "RequestBodyType" if operation.requestBody else "{}" -}},
        {{- "{ " + (queryParameters | join(", ")) + " }" if queryParameters | length > 0 else "{}" -}}
    >, res, next) => {
        {% if operation.security and operation.security | length > 0 %}

        {%- set userDataTypes = [] -%}
        {%- for securityRequirement in operation.security -%}
            {%- set temp = [] -%}
            {%- for securityMethod, scopes in securityRequirement -%}
                {%- set temp = (temp.push(securityMethod | formatName), temp) -%}
            {%- endfor -%}
            {%- set userDataTypes = (userDataTypes.push("UserData<" + (temp | strings | join("|")) + ">"), userDataTypes) -%}
        {%- endfor -%}

        const security = {{ operation.security | stringify(4) | indent(8) }}

        let userData: {{ userDataTypes | join(" | ") }} | undefined = undefined

        for (const securityRequirement of security) {
            try {
                userData = await handleSecurityRequirement(req, securityRequirement)
                break
            } catch {
                continue
            }
        }

        if (!userData) {
            throw new Error("Request could not be authenticated")
        }

        {% if operation.parameters -%}
        const parameters: {{ operation.name }}ParametersType = {
            {%- set parameterDefinitions = [] -%}
            {%- for parameter in operation.parameters %}
            {%- set parameterDefinitions = (
                parameterDefinitions.push(
                    '"' + parameter.name + '": '
                    + ('req.params["' + parameter.name + '"]' if parameter.in == "path")
                    + ('req.query["' + parameter.name + '"]' if parameter.in == "query")
                    + ('req.get("' + parameter.name + '")' if parameter.in == "header")
                    + ('req.cookies["' + parameter.name + '"' if parameter.in == "cookie")
                ), parameterDefinitions) -%}
            {%- endfor %}
            {{ parameterDefinitions | join(",\n\t\t\t") }}
        }

        {% endif -%}

        {% if operation.requestBody -%}
        const body: {{ operation.name }}RequestBodyType = req.body

        {% endif -%}

        try {
            if (!validate{{ operation.name | cap }}Input(
                {{- "parameters" if operation.parameters -}}
                {{- ", " if (operation.parameters and operation.requestBody) -}}
                {{- "body" if operation.requestBody -}}
            )) {
                throw new ValidationError("Request validation failed", 400)
            }

            const result = await operations.{{ operation.name }}(
                {{- "parameters" if operation.parameters -}}
                {{- ", " if (operation.parameters and operation.requestBody) or (operation.parameters and operation.security) -}}
                {{- "body" if operation.requestBody -}}
                {{- ", " if (operation.requestBody and operation.security) -}}
                {{- "userData" if operation.security -}}
            )

            if (!validate{{ operation.name | cap }}Output(result)) {
                throw new ValidationError("Response validation failed", 500)
            }

            if (result.headers) {
                for (const headerName in result.headers) {
                    const header = result.headers[headerName]
                    if (header) {
                        res.setHeader(headerName, header)
                    }
                }
            }

            return res.status(result.status || 200).send(result.body)
        } catch(error) {
            next(error)
            return
        }

        {%- endif %}
    })

    {%- endfor %}

    return router
}
{%- endmacro -%}
{{ generateRoutes() | prettier }}