{%- macro generateTypes() -%}
{%- set unsortedSchemas = (api | resolveSchemas) -%}
{%- set sortedSchemas = unsortedSchemas | sortByAttribute('x-service-name') -%}
{%- set securitySchemes = [] -%}
{%- set validationDependencies = [] -%}
{%- for schema in unsortedSchemas | selectattr("x-typeguard") | select("attrequalto", ["x-standalone", true]) -%}
    {%- set validationDependencies = (validationDependencies.push((schema["x-service-name"] | formatName) + "BasicValidation"), validationDependencies) -%}
{%- endfor -%}

{%- if components.securitySchemes | list | length > 0 -%}
    {%- for name, scheme in components.securitySchemes -%}
        {%- set securitySchemes = (securitySchemes.push(name | formatName), securitySchemes) -%}
    {%- endfor -%}
{%- endif -%}
/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */
{% if validationDependencies | length > 0 -%}
import {
    {{ validationDependencies | unique | join(",\n\t") }}
} from "./basicValidation"

{% endif -%}

export interface RequestInfo {
    method?: "GET" | "POST" | "PUT" | "DELETE" | "TRACE" | "OPTIONS" | "PATCH" | "HEAD"
    body?: string
    headers?: [string, string][]
}

export type FetchFunction = (url: string, info?: RequestInfo) => ResponseData

export interface ResponseData {
    status: number,
    headers?: {
        [key: string]: string | undefined
    },
    body?: any
}

export interface SuccessResponse extends ResponseData {
    success?: true
}

export interface ErrorResponse extends ResponseData {
    success?: false
}

export function isSuccessResponse(response: ResponseData): response is SuccessResponse {
    return response.status < 400
}

export function isErrorResponse(response: ResponseData): response is ErrorResponse {
    return response.status >= 400
}

/**
 * This error class should be used if an error occurs during validation of a request/response.
 */
export class ValidationError extends Error {
    public errors: any

    constructor(message: string, errors: any) {
        super(message)
        this.name = "ValidationError"
        this.errors = errors
    }
}

/**
 * This error class should be used if an error occurs while fetching a request.
 */
export class FetchError extends Error {
    constructor(message: string) {
        super(message)
        this.name = "FetchError"
    }
}

/**
 * This error class should be used if the response of the server has a status greater than or equal to 400.
 * This error should contain the validated response.
 */
export class UnsuccessfulRequestError extends Error {
    public response: ResponseData

    constructor(message: string, response: ResponseData) {
        super(message)
        this.response = response
        this.name = 'UnsuccessfulRequestError'
    }
}

/**
 * This error class should be used if the validation of an url fails.
 */
export class InvalidUrlError extends Error {
    constructor(message: string) {
        super(message)
        this.name = 'InvalidUrlError'
    }
}

export async function parseResponse(response: Response): Promise<ResponseData> {
    let text = null
    try {
        text = await response.text()
        const json = JSON.parse(text)
        return { status: response.status, body: json }
    } catch {
        return { status: response.status, body: text }
    }
}

/**
 * This type allows to pick the required properties of another type.
 */
export type Require<Type, Key extends keyof Type> = Partial<Type> & {
    [Property in Key]-?: Type[Property]
}

{%- for serviceName, schemas in sortedSchemas %}

/**
 * Namespace containing the types for the {{ serviceName }}.
 */
export namespace {{ serviceName | formatName }}Types {
{{ "    " + schemas | standaloneTypings | indent(4) }}
    
    {%- for schema in schemas | selectattr("x-typeguard") | select("attrequalto", ["x-standalone", true]) %}

    export function is{{ schema["x-name"] }}(obj: any): obj is {{ schema["x-name"] }} {
        return {{ schema["x-service-name"] | formatName }}BasicValidation.validate{{ schema["x-name"] }}(obj)
    }
    {%- endfor %}
}
{%- endfor %}
{%- endmacro -%}
{{ generateTypes() | prettier }}