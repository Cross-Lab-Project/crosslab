{%- macro generateIndex() -%}
{%- set operations = (api | resolveOperations) -%}
{%- set typeDependencies = ["FetchFunction", "isErrorResponse", "ValidationError", "UnsuccessfulRequestError"] -%}
{%- set signatureDependencies = [] -%}
{%- set validationDependencies = [] -%}

{%- for operation in operations -%}
    {%- if operation.external -%}
        {%- set validationDependencies = (validationDependencies.push((operation.serviceName | formatName) + "RequestValidation"), validationDependencies) -%}
        {%- if operation.parameters -%}
            {%- set signatureDependencies = (signatureDependencies.push((operation.serviceName | formatName) + "Signatures"), signatureDependencies) -%}
        {%- endif -%}
        {%- if operation.requestBody -%}
            {%- set signatureDependencies = (signatureDependencies.push((operation.serviceName | formatName) + "Signatures"), signatureDependencies) -%}
        {%- endif -%}
        {%- if operation.responses -%}
            {%- set signatureDependencies = (signatureDependencies.push((operation.serviceName | formatName) + "Signatures"), signatureDependencies) -%}
        {%- endif -%}
    {%- endif -%}
{%- endfor -%}

/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */
import {
    {{ typeDependencies | unique | join(",\n\t") }}
} from "./types"

import {
    {{ signatureDependencies | unique | join(",\n\t") }}
} from "./signatures"

import {
    {{ validationDependencies | unique | join(",\n\t") }}
} from "./requestValidation"

/**
 * Client for the use of the Crosslab API
 */
export class APIClient {
    private _url: string
    private _accessToken: string
    private fetch: FetchFunction
    
    constructor(url: string, fetch: FetchFunction, accessToken?: string) {
        this._url = url.endsWith('/') ? url.slice(0,-1) : url
        this._accessToken = accessToken ?? ''
        this.fetch = fetch
    }

    get url() {
        return this._url
    }

    set url(url: string) {
        this._url = url.endsWith('/') ? url.slice(0,-1) : url
    }

    set accessToken(accessToken: string) {
        this._accessToken = accessToken
    }

    {%- for operation in operations | selectattr("external") %}
    {%- set requestValidation = (operation.serviceName | formatName) + "RequestValidation" %}
    {%- set signatures = (operation.serviceName | formatName) + "Signatures" %}
    {%- set pathParameters = (operation.parameters | select("attrequalto", ["in", "path"])) if operation.parameters else [] %}
    {%- set headerParameter = (operation.parameters | select("attrequalto", ["in", "header"])) if operation.parameters else [] %}

    /**
     * {{ operation.summary }}
     * @category {{ operation.serviceName }}
     */
    public async {{ operation.operationId | formatName(false) }}(
        {{- "parameters: " + signatures + "." + operation.name + "ParametersType" if operation.parameters -}}
        {{- ", " if (operation.parameters and operation.requestBody) -}}
        {{- "body: " + signatures + "." + operation.name + "RequestBodyType" if operation.requestBody -}}
    ): Promise<{{ signatures }}.{{ operation.name }}SuccessResponseType> {
        const url = this._url + "{{ operation.path }}"
        {%- for pathParameter in pathParameters %}
            .replace("{ {{- pathParameter.name -}} }", parameters.{{ pathParameter.name }})
        {%- endfor %}

        if (!{{ requestValidation }}.validate{{ operation.name | cap }}Input(
            {{- "parameters" if operation.parameters -}}
            {{- ", " if (operation.parameters and operation.requestBody) -}}
            {{- "body" if operation.requestBody -}}
        ))
            throw new ValidationError(
                'Request validation failed!', 
                ({{ requestValidation }}.validate{{ operation.name | cap }}Input as any).errors
            )
        
        {%- if operation.security | selectattr("JWT") | length > 0 %}

        const authorization: string = `Bearer ${this._accessToken}`
        {%- endif %}

        const response = this.fetch(url, {
            method: "{{ operation.method | upper }}"
            {%- if (headerParameters | length > 0) or (operation.security | selectattr("JWT") | length > 0) -%}
            , 
            headers: [
                {%- for headerParameter in headerParameters %}
                "{{ headerParameter.name }}", parameters.{{ headerParameter.name }}
                {%- endfor %}
                {%- if operation.security | selectattr("JWT") | length > 0 -%}
                {{ "," if headerParameters | length > 0 }}
                ["Authorization", authorization]
                {%- endif %}
            ] 
            {%- endif %}
            {%- if operation.requestBody | length > 0 -%}
            , 
            body: JSON.stringify(body)
            {%- endif %}
        })

        if (!{{ requestValidation }}.validate{{ operation.name | cap }}Output(response))
            throw new ValidationError(
                'Response validation failed!', 
                ({{ requestValidation }}.validate{{ operation.name | cap }}Output as any).errors
            )

        if (isErrorResponse(response)) 
            throw new UnsuccessfulRequestError(
                `Server returned response with status ${response.status}`, 
                response
            )
        
        return response
    }
    {%- endfor %}
}
{%- endmacro -%}
{{ generateIndex() | prettier }}