{%- macro generateRoutes() -%}
{%- set typeDependencies = ["UserData","TypedRequest","ValidationError","initServiceOptions","SecurityScheme"] -%}
{%- set validationDependencies = [] -%}
{%- set signatureDependencies = [] -%}
{%- set operationDependencies = [] -%}
{%- set operations = api | resolveOperations -%}

{%- for operation in operations -%}
    {%- set operationDependencies = (operationDependencies.push(operation.name), operationDependencies) -%}
    {%- set validationDependencies = (validationDependencies.push("validate" + (operation.name | cap) + "Input"), validationDependencies) -%}
    {%- set validationDependencies = (validationDependencies.push("validate" + (operation.name | cap) + "Output"), validationDependencies) -%}
    {%- if operation.parameters -%}
        {%- set signatureDependencies = (signatureDependencies.push(operation.name + "ParametersType"), signatureDependencies) -%}
    {%- endif -%}
    {%- if (operation.requestBody or operation.isProxyRequest) -%}
        {%- set signatureDependencies = (signatureDependencies.push(operation.name + "RequestBodyType"), signatureDependencies) -%}
    {%- endif -%}
{%- endfor -%}

{%- set securityOptionsDefaults = [] -%}

{%- if components.securitySchemes | list | length > 0 -%}
    {%- for name, scheme in components.securitySchemes -%}
        {%- set securityOptionsDefaults = 
            (securityOptionsDefaults.push(
                '"' + (name | formatName) + '"'
                + ': (_req, _scopes) => { throw new Error("' 
                + (name | formatName) 
                + ' authentication not implemented") }'
            ), securityOptionsDefaults) -%}
    {%- endfor -%}
{%- endif -%}

/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */
import express from "express"

import operations from "../operations"

import {
    UserType,
    isUserType,
    {{ typeDependencies | unique | join(",\n\t") }}
} from "./types"

import {
    {{ signatureDependencies | unique | join(",\n\t") }}
} from "./signatures"

import {
    {{ validationDependencies | unique | join(",\n\t") }}
} from "./requestValidation"

import * as core from 'express-serve-static-core'

export default function routes(
    options: initServiceOptions<SecurityScheme>
): express.Router {
    const router = express.Router()

    async function handleSecurityRequirement<T extends SecurityScheme,P extends core.ParamsDictionary,B,Q extends core.Query>(
        request: TypedRequest<P,B,Q>,
        securityRequirement: {
            [k in T]: string[]
        }
    ): Promise<UserData<T>> {
        const userDataEntries: [T, UserType<T>][] = []
        for (const method in securityRequirement) {
            const user = await options.security[method](
                request,
                securityRequirement[method]
            )
            if (!isUserType(user, method)) throw new Error(`User resolved by method ${method} is not of type 'UserType'`)
            userDataEntries.push([method, user])
        }
        return Object.fromEntries(userDataEntries) as UserData<T>;
    }

    {%- for operation in operations %}

    {% set pathParameters = [] -%}
    {%- set queryParameters = [] -%}

    {%- for parameter in operation.parameters -%}
        {%- if parameter.in == "path" -%}
            {%- set pathParameters = (pathParameters.push('"' + parameter.name + '": string'), pathParameters) -%}
        {%- endif -%}
        {%- if parameter.in == "query" -%}               
            {%- set queryParameters = (queryParameters.push('"' + parameter.name + '": string'), queryParameters) -%}
        {%- endif -%}
    {%- endfor -%}

    router.{{ operation.method }}("{{ operation.path | formatExpressPath }}", async (req: TypedRequest<
        {{- "{ " + (pathParameters | join(", ")) + " }" if pathParameters | length > 0 else "{}" -}},
        {{- operation.name + "RequestBodyType" if operation.requestBody else "{}" -}},
        {{- "{ " + (queryParameters | join(", ")) + " }" if queryParameters | length > 0 else "{}" -}}
    >, res, next) => {
        {% if operation.security and (operation.security | length) > 0 %}

        {%- set userDataTypes = [] -%}
        {%- for securityRequirement in operation.security -%}
            {%- set temp = [] -%}
            {%- for securityMethod, scopes in securityRequirement -%}
                {%- set temp = (temp.push(securityMethod | formatName), temp) -%}
            {%- endfor -%}
            {%- set userDataTypes = (userDataTypes.push("UserData<" + (temp | toStrings | join("|")) + ">"), userDataTypes) -%}
        {%- endfor -%}

        const security = {{ operation.security | stringify(4) | indent(8) }}

        let userData: {{ userDataTypes | join(" | ") }} | undefined = undefined

        for (const securityRequirement of security) {
            try {
                userData = await handleSecurityRequirement(req, securityRequirement)
                break
            } catch (error) {
                console.error(error)
                continue
            }
        }

        if (!userData) {
            next(new Error("Request could not be authenticated"))
            return
        }
        {%- endif %}

        {% if operation.parameters -%}
        const parameters: {{ operation.name }}ParametersType = {
            {%- set parameterDefinitions = [] -%}
            {%- for parameter in operation.parameters %}
            {%- set parameterDefinitions = (
                parameterDefinitions.push(
                    '"' + parameter.name + '": '
                    + ('req.params["' + parameter.name + '"]' if parameter.in == "path")
                    + ('req.query["' + parameter.name + '"]' + (' === "true"' if parameter.schema.type == "boolean") if parameter.in == "query")
                    + ('req.get("' + parameter.name + '")' if parameter.in == "header")
                    + ('req.cookies["' + parameter.name + '"' if parameter.in == "cookie")
                ), parameterDefinitions) -%}
            {%- endfor %}
            {{ parameterDefinitions | join(",\n\t\t\t") }}
        }

        {% endif -%}

        {% if (operation.requestBody or operation.isProxyRequest) -%}
        const body: {{ operation.name }}RequestBodyType = req.body

        {% endif -%}

        try {
            if (!validate{{ operation.name | cap }}Input(
                {{- "parameters" if operation.parameters -}}
                {{- ", " if (operation.parameters and (operation.requestBody or operation.isProxyRequest)) -}}
                {{- "body" if operation.requestBody -}}
            )) {
                throw new ValidationError("Request validation failed", (validate{{ operation.name | cap }}Input as any).errors, 400)
            }

            const result = await operations.{{ operation.name }}(
                {{- "parameters" if operation.parameters -}}
                {{- ", " if (operation.parameters and operation.requestBody) or (operation.parameters and operation.security) -}}
                {{- "body" if (operation.requestBody or operation.isProxyRequest) -}}
                {{- ", " if ((operation.requestBody or operation.isProxyRequest) and operation.security) -}}
                {{- "userData" if operation.security and (operation.security | length) > 0 -}}
            )

            if (!validate{{ operation.name | cap }}Output(result)) {
                throw new ValidationError("Response validation failed", (validate{{ operation.name | cap }}Output as any).errors, 500)
            }

            for (const headerName in result.headers) {
                const header = result.headers[headerName]
                if (header) {
                    res.setHeader(headerName, header)
                }
            }

            return res.status(result.status).send(result.body)
        } catch(error) {
            next(error)
            return
        }
    })

    {%- endfor %}

    return router
}
{%- endmacro -%}
{{ generateRoutes() | prettier }}