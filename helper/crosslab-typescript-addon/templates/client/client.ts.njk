{%- macro generateIndex() -%}
{%- set schemas = (api | resolveSchemas) -%}
{%- set operations = (api | resolveOperations) -%}
{%- set typeDependencies = ["FetchFunction", "isErrorResponse", "ResponseData"] -%}
{%- set signatureDependencies = [] -%}
{%- set validationDependencies = [] -%}

{%- for operation in operations -%}
    {%- if operation.external -%}
        {%- set validationDependencies = (validationDependencies.push((operation.serviceName | formatName) + "RequestValidation"), validationDependencies) -%}
        {%- if operation.parameters -%}
            {%- set signatureDependencies = (signatureDependencies.push((operation.serviceName | formatName) + "Signatures"), signatureDependencies) -%}
            {%- set typeDependencies = (typeDependencies.push((operation.serviceName | formatName) + "Types"), typeDependencies) -%}
        {%- endif -%}
        {%- if operation.requestBody -%}
            {%- set signatureDependencies = (signatureDependencies.push((operation.serviceName | formatName) + "Signatures"), signatureDependencies) -%}
            {%- set typeDependencies = (typeDependencies.push((operation.serviceName | formatName) + "Types"), typeDependencies) -%}
        {%- endif -%}
        {%- if operation.responses -%}
            {%- set signatureDependencies = (signatureDependencies.push((operation.serviceName | formatName) + "Signatures"), signatureDependencies) -%}
            {%- set typeDependencies = (typeDependencies.push((operation.serviceName | formatName) + "Types"), typeDependencies) -%}
        {%- endif -%}
    {%- endif -%}
{%- endfor -%}

/**
 * This file was automatically generated by openapi-codegeneration.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,
 * and run openapi-codegeneration to regenerate this file.
 */
import {
    {{ typeDependencies | unique | join(",\n\t") }}
} from "./types"

import {
    {{ signatureDependencies | unique | join(",\n\t") }}
} from "./signatures"

import {
    {{ validationDependencies | unique | join(",\n\t") }}
} from "./requestValidation"

import fetch from "cross-fetch"

/**
 * This error class should be used if an error occurs during validation of a request/response.
 * @category Errors
 */
export class ValidationError extends Error {
    public errors: any

    constructor(message: string, errors: any) {
        super(message)
        this.name = "ValidationError"
        this.errors = errors
    }
}

/**
 * This error class should be used if an error occurs while fetching a request.
 * @category Errors
 */
export class FetchError extends Error {
    constructor(message: string) {
        super(message)
        this.name = "FetchError"
    }
}

/**
 * This error class should be used if the response of the server has a status 
 * greater than or equal to 400. This error should contain the validated response.
 * @category Errors
 */
export class UnsuccessfulRequestError extends Error {
    public response: ResponseData

    constructor(message: string, response: ResponseData) {
        super(message)
        this.response = response
        this.name = 'UnsuccessfulRequestError'
    }
}

/**
 * This error class should be used if the validation of an url fails.
 * @category Errors
 */
export class InvalidUrlError extends Error {
    constructor(message: string) {
        super(message)
        this.name = 'InvalidUrlError'
    }
}

/**
 * This function attempts to parse a Response as ResponseData.
 */
async function parseResponse(response: Response): Promise<ResponseData> {
    let text = null
    try {
        text = await response.text()
        const json = JSON.parse(text)
        return { status: response.status, body: json }
    } catch {
        return { status: response.status, body: text }
    }
}

/**
 * This function checks if a string is a valid http url.
 * @param string The string to be checked.
 * @returns True if the string is a valid http url.
 */
function isValidHttpUrl(string: string) {
    let url

    try {
        url = new URL(string)
    } catch (_) {
        return false
    }

    return url.protocol === 'http:' || url.protocol === 'https:'
}

/**
 * This function takes an url and a pattern for the requested endpoint and parses the contained path parameters.
 * @param url The url to be parsed.
 * @param endpoint Pattern of the requested endpoint.
 * @throws {InvalidUrlError} Thrown if the provided url does not end with the provided endpoint.
 * @returns An array containing all parsed path parameters in order of appearance.
 * @example
 * // returns ["username", "role_name"]
 * parsePathParameters("https://api.example.com/users/username/roles/role_name", "/users/{}/roles/{}")
 */
function parsePathParameters(url: string, endpoint: string): string[] {
    const parameterRegex = '([a-zA-Z0-9-:]+)'
    const regex = new RegExp(
        endpoint.replaceAll('{}', parameterRegex) + '(?:.(?!\\\\))?$'
    )
    const matches = url.match(regex)

    if (!matches) throw new InvalidUrlError('Url does not end with the provided endpoint')

    return matches.slice(1)
}

/**
 * This function validates a given http url and parses its path parameters.
 * @param url The url to be validated.
 * @param endpoint Pattern of the requested endpoint.
 * @throws {InvalidUrlError} Thrown if the validation of the provided url fails.
 * @returns An array containing all parsed path parameters in order of appearance (see {@link parsePathParameters}).
 * @example
 * // returns ["username", "role_name"]
 * validateUrl("https://api.example.com/users/username/roles/role_name", "/users/{}/roles/{}")
 */
function validateUrl(url: string, endpoint: string): string[] {
    if (!isValidHttpUrl(url)) throw new InvalidUrlError('Provided url is not a valid http url')
    return parsePathParameters(url, endpoint)
}

/**
 * This function appends a given endpoint to an url.
 * @param url The url to append the endpoint to.
 * @param endpoint The endpoint to be appended.
 * @example
 * // returns "https://api.example.com/devices/device_id/token"
 * appendToUrl("https://api.example.com/devices/device_id", "/token")
 * @example
 * // returns "https://api.example.com/devices/device_id/token"
 * appendToUrl("https://api.example.com/devices/device_id/", "/token")
 * @returns The url with the appended endpoint.
 */
function appendToUrl(url: string, endpoint: string) {
    return url.endsWith('/') ? `${url.slice(0, -1)}${endpoint}` : `${url}${endpoint}`
}

/**
 * Client for the use of the Crosslab API
 * @category Client
 */
export class APIClient {
    private _url: string
    private _accessToken: string
    private fetch: FetchFunction = async (url, info) => {
        let raw_response
        try {
            if (url.startsWith(this._url)) {
                raw_response = await fetch(url, info);
            } else {
                raw_response = await fetch(appendToUrl(this._url, "/proxy?" + new URLSearchParams([["URL", url]]).toString()), info)      
            }
        } catch (error) {
            if (error instanceof Error) {
                throw new FetchError(error.message)
            } else if (typeof error === "string") {
                throw new FetchError(error)
            } else {
                throw new FetchError("Something went wrong while trying to fetch the request")
            }
        }
        return await parseResponse(raw_response)
    }
    
    /**
     * @category Constructors
     */
    constructor(url: string, accessToken?: string) {
        this._url = url.endsWith('/') ? url.slice(0,-1) : url
        this._accessToken = accessToken ?? ''
    }

    /**
     * @category Accessors
     */
    get url() {
        return this._url
    }

    /**
     * @category Accessors
     */
    set url(url: string) {
        this._url = url.endsWith('/') ? url.slice(0,-1) : url
    }
    
    /**
     * @category Accessors
     */
    set accessToken(accessToken: string) {
        this._accessToken = accessToken
    }

    /**
     * @category Accessors
     */
    get accessToken() {
        return this._accessToken
    }

    {%- for operation in operations | selectattr("external") %}
    {%- set low_name = operation.operationId | formatName(false) %}
    {%- set cap_name = operation.operationId | formatName %}
    {%- set requestValidation = (operation.serviceName | formatName) + "RequestValidation" %}
    {%- set types = (operation.serviceName | formatName) + "Types" %}
    {%- set signatures = (operation.serviceName | formatName) + "Signatures" %}
    {%- set pathParameters = (operation.parameters | select("attrequalto", ["in", "path"])) if operation.parameters else [] %}
    {%- set queryParameters = (operation.parameters | select("attrequalto", ["in", "query"])) if operation.parameters else [] %}
    {%- set headerParameter = (operation.parameters | select("attrequalto", ["in", "header"])) if operation.parameters else [] %}
    {%- set bodyName = (operation.requestBody.schema.title | formatName(false)) if operation.requestBody.schema.title else "body" %}
    {%- set requiredUrl = true if operation.parameters and operation.parameters | select("attrequalto", ["in", "path"]) | length > 0 else false %}
    {%- set buildUrl = operation.buildUrl %}
    {%- set optionalUrl = operation.optionalUrl %}

    {#- Handle destructuring of input #}
    {%- if operation.destructureInput %}

        {#- Destructure request body schema #}
        {%- set destructured = (
            operation.requestBody.schema | destructureSchema({ 
                "prefixDirectlyResolved": (operation.serviceName | formatName) + "Types." 
            })
        ) if operation.requestBody else [] %}

        {#- Construct input declaration #}
        {%- set input %}
            {#- Add url parameter if needed #}
            {{- "url: string," if requiredUrl and not buildUrl -}}

            {#- Add required properties of destructured request body schema #}
            {%- for property in (destructured | select("attrequalto", ["required", true])) %}
                {{ property.name }}: {{ property.declaration }},
            {%- endfor %}

            {#- Add required parameters of operation #}
            {%- if operation.parameters %}
                {%- for parameter in operation.parameters | select("attrequalto", ["required", true]) %}
                    {%- if parameter.in != "path" or buildUrl %}
                        {{ parameter.name }}: {{ parameter.schema | typeDeclaration({ "prefixDirectlyResolved": (operation.serviceName | formatName) + "Types.", "inline": true }) }}
                    {%- endif %}
                {%- endfor %}
            {%- endif %}

            {#- Construct optional parameters #}
            {%- if  (destructured | select("attrequalto", ["required", false]) | length > 0) or 
                    (operation.parameters and operation.parameters | select("attrequalto", ["required", false]) | length > 0) or
                    optionalUrl %}
                options?: {
                    {#- Add optional properties of destructured request body schema #}
                    {%- for property in destructured | select("attrequalto", ["required", false]) %}
                        {{ property.name }}?: {{ property.declaration }},
                    {%- endfor %}
                    {#- Add optional parameters #}
                    {%- if operation.parameters %}
                        {%- for parameter in operation.parameters | select("attrequalto", ["required", false]) %}
                            {{ parameter.name }}?: {{ parameter.schema | typeDeclaration({ "prefixDirectlyResolved": (operation.serviceName | formatName) + "Types.", "inline": true }) }}
                        {%- endfor %}
                    {%- endif %}
                    {{- "url?: string" if optionalUrl -}}
                }
            {%- endif %}
        {%- endset %}

        {#- Construct body variable declaration #}
        {%- set body %}
            const body: {{ signatures }}.{{ cap_name }}Body = 
            {%- if destructured | length == 1 and destructured[0].top %}
                {{ destructured[0].name }}
            {%- else %}
                {
                {%- for property in destructured %}
                    {{ property.name }}: {{ "options?." if not property.required }}{{ property.name }},
                {%- endfor %}
                }
            {%- endif %}
        {%- endset %}

        {#- Construct param tsdoc tags #}
        {%- set params -%}
            {#- Construct param tag for url #}
            {%- if requiredUrl and not buildUrl -%}
                {{- "\n\t * " -}} @param url
                {{- "\n\t * " -}} Url of the resource to be accessed.
            {%- endif -%}

            {#- Construct param tag for required properties of destructured request body schema #}
            {%- for property in destructured | select("attrequalto", ["required", true]) -%}
                {{- "\n\t * " -}} @param {{ property.name }}
                {{- "\n\t * " -}} {{ property.description }}
            {%- endfor -%}

            {#- Construct param tag for required parameters #}
            {%- if operation.parameters -%}
                {%- for parameter in operation.parameters | select("attrequalto", ["required", true]) -%}
                    {%- if parameter.in != "path" or buildUrl -%}
                        {{- "\n\t * " -}} @param {{ parameter.name }}
                        {{- "\n\t * " -}} {{ parameter.description }}
                    {%- endif -%}
                {%- endfor -%}
            {%- endif -%}

            {#- Construct param tag for optional properties of destructured request body schema #}
            {%- for property in destructured | select("attrequalto", ["required", false]) -%}
                {{- "\n\t * " -}} @param options.{{ property.name }}
                {{- "\n\t * " -}} {{ property.description }}
            {%- endfor -%}

            {#- Construct param tag for optional parameters #}
            {%- if operation.parameters -%}
                {%- for parameter in operation.parameters | select("attrequalto", ["required", false]) -%}
                    {{- "\n\t * " -}} @param options.{{ parameter.name }}
                    {{- "\n\t * " -}} {{ parameter.description }}
                {%- endfor -%}
            {%- endif -%}

            {#- Construct param tag for optional url #}
            {%- if optionalUrl -%}
                {{- "\n\t *" }} @param options.url 
                {{- "\n\t *" }} Url of the {{ operation.serviceName }} to be used.
            {%- endif -%}
        {%- endset %}

    {%- else %}

        {#- Construct input declaration #}
        {%- set input %}
            {#- Add url parameter if needed #}
            {{- "url: string," if requiredUrl and not buildUrl -}}

            {#- Add declaration of request body if defined #}
            {%- if operation.requestBody -%}
            {{- bodyName + ": " -}}
            {{- operation.requestBody.schema | typeDeclaration(schemas, { "prefixDirectlyResolved": types + ".", "schemaType": "request" }) if operation.requestBody.schema else signatures + "." + cap_name + "Body" -}},
            {%- endif -%}

            {#- Add declaration of parameters and optional url if defined #}
            {%- if operation.parameters or optionalUrl -%}
                {#- Add declaration of required parameters #}
                {%- if operation.parameters -%}
                    {%- for parameter in operation.parameters | select("attrequalto", ["required", true]) -%}
                        {{- parameter.name + ": " + (parameter.schema | typeDeclaration) + "," if (parameter.in != "path" or buildUrl) -}}
                    {%- endfor -%}
                {%- endif -%}

                {#- Add declaration of optional parameters / optional url #}
                {%- if (operation.parameters and operation.parameters | select("attrequalto", ["required", false]) | length > 0) or optionalUrl -%}
                    options?: {
                        {%- if operation.parameters -%}
                            {%- for parameter in operation.parameters | select("attrequalto", ["required", false]) -%}
                                {{- parameter.name + "?: " + (parameter.schema | typeDeclaration) -}},
                            {%- endfor -%}
                        {%- endif -%}
                        {{- "url?: string" if optionalUrl -}}
                    }
                {%- endif -%}
            {%- endif -%}
        {%- endset %}

        {#- Construct body variable declaration #}
        {%- set body = "const body = " + bodyName if bodyName != "body" else "" %}

        {#- Construct param tsdoc tags #}
        {%- set params -%}
            {#- Construct param tag for url #}
            {%- if requiredUrl and not buildUrl -%}
                {{- "\n\t * " -}} @param url
                {{- "\n\t * " -}} Url of the resource to be accessed.
            {%- endif -%}

            {#- Construct param tag for request body #}
            {%- if operation.requestBody -%}
                {{- "\n\t * " -}} @param {{ bodyName }}
                {%- if operation.requestBody.description -%}
                    {{- "\n\t * " -}} {{ operation.requestBody.description | replace(r/\n$/, "") | replace("\n", "\n\t * ") }}
                {%- elif operation.requestBody.schema.description -%}
                    {{- "\n\t * " -}} {{ operation.requestBody.schema.description | replace(r/\n$/, "") | replace("\n", "\n\t * ") }}
                {%- endif -%}
            {%- endif -%}

            {#- Construct param tag for parameters #}
            {%- if operation.parameters -%}
                {%- for parameter in operation.parameters -%}
                    {%- if parameter.in != "path" or buildUrl -%}
                        {{- "\n\t * " -}} @param {{ "options." if not parameter.required }}{{ parameter.name }}
                        {{- "\n\t * " -}} {{- parameter.description | replace(r/\n$/, "") | replace("\n", "\n\t * ") if parameter.description -}}
                    {%- endif -%}
                {%- endfor -%}
            {%- endif -%}

            {#- Construct param tag for optional url #}
            {%- if optionalUrl -%}
                {{- "\n\t * " -}} @param options.url 
                {{- "\n\t * " -}} Url of the {{ operation.serviceName }} to be used.
            {%- endif -%}
        {%- endset %}

    {%- endif %}

    {#- Construct parameter variable declaration #}
    {%- if operation.parameters %}
        {%- set parameters %}
        const parameters = {
        {%- for parameter in operation.parameters %}
            {{ parameter.name }}: {{ parameter.name if parameter.required else "options?." + parameter.name }},
        {%- endfor %}
        }
        {%- endset %}
    {%- endif %}

    {#- Construct returns tsdoc tag #}
    {%- if operation.responses -%}
        {#- Collect all success responses of operation #}
        {%- set successResponses = [] -%}
        {%- for response in operation.responses -%}
            {%- if response.status < 400 -%}
                {%- set successResponses = (successResponses.push(response), successResponses) if response.status < 400 -%}
            {%- endif -%}
        {%- endfor -%}
        {#- Construct returns tsdoc tag #}
        {%- set returns -%}
            {{- "" -}} @returns
            {%- if successResponses | length == 1 -%}
                {{ "\n\t * " -}} {{ successResponses[0].description }}
            {%- else -%}
                {%- for successResponse in successResponses -%}
                    {{ "\n\t * " -}} {{ successResponse.status }}: {{ successResponse.description }}
                {%- endfor -%}
            {%- endif -%}
        {%- endset -%}
    {%- endif -%}

    {#- Override input, params and body for logout operation #}
    {%- set input = ("" if low_name == "logout" else input) -%}
    {%- set params = ("" if low_name == "logout" else params) -%}
    {%- set body = ("const body: AuthenticationServiceSignatures.LogoutBody = { token: this._accessToken }" if low_name == "logout" else body) -%}

    /**
     * {{ operation.summary }} {{ ("\n\t * " if params) + params }}
     *
     * @throws {@link FetchError | FetchError } 
     * Thrown if fetch fails.
     * @throws {@link ValidationError | ValidationError } 
     * Thrown if the request/response validation fails.
     * @throws {@link InvalidUrlError | InvalidUrlError } 
     * Thrown if the provided url is not valid for this request.
     * @throws {@link UnsuccessfulRequestError | UnsuccessfulRequestError } 
     * Thrown if response is validated but has status greater than or equal to 400.
     * 
     * {{ returns }}
     *
     * @category {{ operation.serviceName }} Methods
     */
    public async {{ low_name }}({{ input }}): Promise<
        {%- if successResponses | selectattr("schema") | length > 0 and low_name != "login" -%}
            {{ signatures }}.{{ cap_name }}SuccessResponse["body"]
        {%- else -%}
            void
        {%- endif -%}
    > {
        {%- if requiredUrl %}
            {%- if not buildUrl %}
                const urlSuffix = '{{ operation.path | replace(r/{.*?}/g, "{}") }}'.split('{}').at(-1) ?? ''
                if (!url.endsWith(urlSuffix)) url = appendToUrl(url, urlSuffix)
                const [{{ operation.path | replace(r/(.*?{(.*?)})(\/\w*)*/g, "$2,") }}] = 
                {{- "" }} validateUrl(url, '{{ operation.path | replace(r/{.*?}/g, "{}") }}')
            {%- else %}
                const url = appendToUrl(
                    {{ "options?.url ?? " if optionalUrl }}this._url, 
                    `{{ operation.path | replace(r/{(.*?)}/g, "\${$1}") }}`
                )
            {%- endif %}
        {%- elif optionalUrl %}
            const url = appendToUrl({{ "options?.url ?? " if optionalUrl }}this._url, "{{ operation.path }}")
        {%- else %}
            const url = appendToUrl(this._url, "{{ operation.path }}")
        {%- endif %}

        {{ body if operation.requestBody }}

        {{ parameters if operation.parameters }}

        {%- if queryParameters | length > 0 %}

            const query: [string,string][] = []
            {%- for queryParameter in queryParameters %}
            
                if (parameters["{{ queryParameter.name }}"]) 
                    query.push(["{{ queryParameter.name }}", parameters["{{ queryParameter.name }}"].toString()])
            {%- endfor %}
        {%- endif %}

        if (!{{ requestValidation }}.validate{{ cap_name }}Input(
            {{- "parameters" if operation.parameters -}}
            {{- ", " if (operation.parameters and operation.requestBody) -}}
            {{- "body" if operation.requestBody -}}
        ))
            throw new ValidationError(
                'Request validation failed!', 
                ({{ requestValidation }}.validate{{ cap_name }}Input as any).errors
            )
        
        {%- if operation.security | selectattr("JWT") | length > 0 %}

        const authorization: string = `Bearer ${this._accessToken}`
        {%- endif %}

        const response = await this.fetch(url {{ "+ '?' + new URLSearchParams(query)" if queryParameters | length > 0 }}, {
            method: "{{ operation.method | upper }}", 
            headers: [
                ["Content-Type", "application/json"],
                {%- for headerParameter in headerParameters %}
                "{{ headerParameter.name }}", parameters.{{ headerParameter.name }}
                {%- endfor %}
                {%- if operation.security | selectattr("JWT") | length > 0 -%}
                {{ "," if headerParameters | length > 0 }}
                ["Authorization", authorization]
                {%- endif %}
            ] 
            {%- if operation.requestBody | length > 0 -%}
            , 
            body: JSON.stringify(body)
            {%- endif %}
        })

        if (!{{ requestValidation }}.validate{{ cap_name }}Output(response))
            throw new ValidationError(
                'Response validation failed!', 
                ({{ requestValidation }}.validate{{ cap_name }}Output as any).errors
            )

        if (isErrorResponse(response)) 
            throw new UnsuccessfulRequestError(
                `Server returned response with status ${response.status}`, 
                response
            )
        
        {{ "this._accessToken = response.body" if low_name == "login" }}
        {{- "this._accessToken = ''" if low_name == "logout" }}

        {%- if successResponses | selectattr("schema") | length > 0 and low_name != "login" %}

            return response.body
        {%- endif %}
    }
    {%- endfor %}
}
{%- endmacro -%}
{{ generateIndex() | prettier }}